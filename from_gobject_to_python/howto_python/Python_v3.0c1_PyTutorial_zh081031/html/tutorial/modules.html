<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Modules 模块 &mdash; Python v3.0c1 documentation</title>
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
          URL_ROOT:    '../',
          VERSION:     '3.0c1',
          COLLAPSE_MODINDEX: false,
          FILE_SUFFIX: '.html'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Python v3.0c1 documentation"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="Python v3.0c1 documentation" href="../index.html" />
    <link rel="up" title="The Python tutorial Python 入门指南" href="index.html" />
    <link rel="next" title="Input and Output 输出和输出" href="inputoutput.html" />
    <link rel="prev" title="Data Structures 数据结构" href="datastructures.html" />
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../modindex.html" title="Global Module Index"
             accesskey="M">modules</a> |</li>
        <li class="right" >
          <a href="inputoutput.html" title="Input and Output 输出和输出"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="datastructures.html" title="Data Structures 数据结构"
             accesskey="P">previous</a> |</li>
<li><img src="../_static/py.png" alt="" style="vertical-align: middle; margin-top: -1px"/></li>

        <li><a href="../contents.html">Python v3.0c1 documentation</a> &raquo;</li>

          <li><a href="index.html" accesskey="U">The Python tutorial Python 入门指南</a> &raquo;</li>
      </ul>
    </div>
    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  
  <div class="section" id="modules">
<span id="tut-modules"></span><h1>Modules 模块<a class="headerlink" href="#modules" title="Permalink to this headline">¶</a></h1>
<p>If you quit from the Python interpreter and enter it again, the definitions you
have made (functions and variables) are lost. Therefore, if you want to write a
somewhat longer program, you are better off using a text editor to prepare the
input for the interpreter and running it with that file as input instead.  This
is known as creating a <em>script</em>.  As your program gets longer, you may want to
split it into several files for easier maintenance.  You may also want to use a
handy function that you&#8217;ve written in several programs without copying its
definition into each program.</p>
<p>如果你从Python解释器退出再进入，那么你定义的所有的方法和变量就都消失了。所以，如果你想写一个能
保存长一点的程序，你最好使用一个文本编辑器保存这些代码，把保存好的文件作为Python解释器的输入。
这就是传说中的*脚本*。当你的程序能够长时间保存了，你就更加希望把他们（按照某种形式）拆分以便于
管理。你可能还需要有个办法，在不同的程序中方便的调用，而不是把一坨代码拷来拷去。</p>
<p>To support this, Python has a way to put definitions in a file and use them in a
script or in an interactive instance of the interpreter. Such a file is called a
<em>module</em>; definitions from a module can be <em>imported</em> into other modules or into
the <em>main</em> module (the collection of variables that you have access to in a
script executed at the top level and in calculator mode).</p>
<p>为此 Python 提供了一个办法，把这些定义存放在文件中，为一些脚本或者交互式的解释器实例使用。这个
文件被称为*模块*，模块中的定义可以被*导入*到其他的模块或者*主*模块（*主*模块是执行脚本的最上层
或计算模式下的一组可访问变量的集合）</p>
<p>A module is a file containing Python definitions and statements.  The file name
is the module name with the suffix <tt class="docutils literal"><span class="pre">.py</span></tt> appended.  Within a module, the
module&#8217;s name (as a string) is available as the value of the global variable
<tt class="docutils literal"><span class="pre">__name__</span></tt>.  For instance, use your favorite text editor to create a file
called <tt class="docutils literal"><span class="pre">fibo.py</span></tt> in the current directory with the following contents:</p>
<p>模块就是拥有 Python 定义和声明的文件。文件名就是模块名称，以 <tt class="docutils literal"><span class="pre">.py</span></tt> 结尾。针对一个模块，
模块的名称（字符串）和这个模块提供的全局变量 <tt class="docutils literal"><span class="pre">__name__</span></tt> 是一样的。例如，用你贴心的编辑器在
当前目录创建一个叫做 <tt class="docutils literal"><span class="pre">fibo.py</span></tt> 的文件，内容如下:</p>
<div class="highlight"><pre><span class="c"># Fibonacci numbers module</span>
<span class="c"># 斐波那契数 模块</span>

<span class="k">def</span> <span class="nf">fib</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>    <span class="c"># write Fibonacci series up to n</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s">&#39; &#39;</span><span class="p">)</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span>

<span class="k">def</span> <span class="nf">fib2</span><span class="p">(</span><span class="n">n</span><span class="p">):</span> <span class="c"># return Fibonacci series up to n</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span>
    <span class="k">return</span> <span class="n">result</span>
</pre></div>
<p>Now enter the Python interpreter and import this module with the following
command:</p>
<p>现在进入 Python 解释器，通过如下命令导入这个模块</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">fibo</span>
</pre></div>
<p>This does not enter the names of the functions defined in <tt class="docutils literal"><span class="pre">fibo</span></tt>  directly in
the current symbol table; it only enters the module name <tt class="docutils literal"><span class="pre">fibo</span></tt> there. Using
the module name you can access the functions:</p>
<p>这并没有把``fibo``里面定义的方法名称直接导入符号表，他只是把 <tt class="docutils literal"><span class="pre">fibo</span></tt> 这个模块放在这了。
你可以通过模块的名称来使用这些方法:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">fibo</span><span class="o">.</span><span class="n">fib</span><span class="p">(</span><span class="mf">1000</span><span class="p">)</span>
<span class="go">1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fibo</span><span class="o">.</span><span class="n">fib2</span><span class="p">(</span><span class="mf">100</span><span class="p">)</span>
<span class="go">[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fibo</span><span class="o">.</span><span class="n">__name__</span>
<span class="go">&#39;fibo&#39;</span>
</pre></div>
<p>If you intend to use a function often you can assign it to a local name:</p>
<p>你也可以用一个本地的名字来存放某个方法，这样用起来会比较方便。</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">fib</span> <span class="o">=</span> <span class="n">fibo</span><span class="o">.</span><span class="n">fib</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fib</span><span class="p">(</span><span class="mf">500</span><span class="p">)</span>
<span class="go">1 1 2 3 5 8 13 21 34 55 89 144 233 377</span>
</pre></div>
<div class="section" id="more-on-modules">
<span id="tut-moremodules"></span><h2>More on Modules 深入模块<a class="headerlink" href="#more-on-modules" title="Permalink to this headline">¶</a></h2>
<p>A module can contain executable statements as well as function definitions.
These statements are intended to initialize the module. They are executed only
the <em>first</em> time the module is imported somewhere. <a class="footnote-reference" href="#id81" id="id1">[1]</a></p>
<p>模块除了方法定义，还可以包括可执行的代码。这些代码一般用来初始化这个模块。这些代码只有在*第一
次*被导入时才会被执行。 <a class="footnote-reference" href="#id82" id="id2">[2]</a></p>
<p>Each module has its own private symbol table, which is used as the global symbol
table by all functions defined in the module. Thus, the author of a module can
use global variables in the module without worrying about accidental clashes
with a user&#8217;s global variables. On the other hand, if you know what you are
doing you can touch a module&#8217;s global variables with the same notation used to
refer to its functions, <tt class="docutils literal"><span class="pre">modname.itemname</span></tt>.</p>
<p>每个模块有各自独立的符号表，在模块内部为所有的函数当作全局符号表来使用。所以，模块的作者可以放心大
胆的在模块内部使用这些全局变量，而不用担心把其他用户的全局变量搞花。从另一个方面，当你确实知道你在
做什么的话，你也可以通过``modname.itemname``这样的表示法来访问模块内的函数。</p>
<p>Modules can import other modules.  It is customary but not required to place all
<a class="reference external" href="../reference/simple_stmts.html#import"><tt class="xref docutils literal"><span class="pre">import</span></tt></a> statements at the beginning of a module (or script, for that
matter).  The imported module names are placed in the importing module&#8217;s global
symbol table.</p>
<p>模块是可以导入其他模块的。在一个模块（或者脚本，或者其他地方）的最前面使用 <a class="reference external" href="../reference/simple_stmts.html#import"><tt class="xref docutils literal"><span class="pre">import</span></tt></a>
来导入一个模块，当然这只是一个惯例，而不是强制的。被导入的模块的名称将被放入当前操作的模块的符号表中。</p>
<p>There is a variant of the <a class="reference external" href="../reference/simple_stmts.html#import"><tt class="xref docutils literal"><span class="pre">import</span></tt></a> statement that imports names from a
module directly into the importing module&#8217;s symbol table.  For example:</p>
<p>还有一种导入的方法，可以使用:keyword:<a href="#id3"><span class="problematic" id="id4">`</span></a>import`直接把模块内（函数，变量的）名称导入到当前操
作模块。比如:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fibo</span> <span class="kn">import</span> <span class="n">fib</span><span class="p">,</span> <span class="n">fib2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fib</span><span class="p">(</span><span class="mf">500</span><span class="p">)</span>
<span class="go">1 1 2 3 5 8 13 21 34 55 89 144 233 377</span>
</pre></div>
<p>This does not introduce the module name from which the imports are taken in the
local symbol table (so in the example, <tt class="docutils literal"><span class="pre">fibo</span></tt> is not defined).</p>
<p>这种导入的方法不会把被导入的模块的名称放在当前的字符表中（所以在这个例子里面，``fibo``这个名称
是没有定义的）。</p>
<p>There is even a variant to import all names that a module defines:</p>
<p>这还有一种方法，可以一次性的把模块中的所有（函数，变量）名称都导入到当前模块的字符表:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fibo</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fib</span><span class="p">(</span><span class="mf">500</span><span class="p">)</span>
<span class="go">1 1 2 3 5 8 13 21 34 55 89 144 233 377</span>
</pre></div>
<p>This imports all names except those beginning with an underscore (<tt class="docutils literal"><span class="pre">_</span></tt>).
In most cases Python programmers do not use this facility since it introduces
an unknown set of names into the interpreter, possibly hiding some things
you have already defined.</p>
<p>这将把所有的名字都导入进来，但是那些由单一下划线（``_``）开头的名字不在此例。大多数情况，
Python程序员不使用这种方法，因为引入的其它来源的命名，很可能覆盖了已有的定义。</p>
<div class="section" id="executing-modules-as-scripts">
<span id="tut-modulesasscripts"></span><h3>Executing modules as scripts 像脚本一样运行模块<a class="headerlink" href="#executing-modules-as-scripts" title="Permalink to this headline">¶</a></h3>
<p>When you run a Python module with</p>
<p>使用下面的命令运行一个 Python 模块:</p>
<div class="highlight"><pre><span class="n">python</span> <span class="n">fibo</span><span class="o">.</span><span class="n">py</span> <span class="o">&lt;</span><span class="n">arguments</span><span class="o">&gt;</span>
</pre></div>
<p>the code in the module will be executed, just as if you imported it, but with
the <tt class="docutils literal"><span class="pre">__name__</span></tt> set to <tt class="docutils literal"><span class="pre">&quot;__main__&quot;</span></tt>.  That means that by adding this code at
the end of your module:</p>
<p>如果你的模块里面的代码就会执行，就好像你导入他们一样，``__name__`` 会赋值为
<a href="#id5"><span class="problematic" id="id6">``</span></a>&#8220;__main__&#8221;<a href="#id7"><span class="problematic" id="id8">``</span></a>。也就是说，你在模块的最下面加上如下代码:</p>
<pre>if __name__ == "__main__":
    import sys
    fib(int(sys.argv[1]))</pre>
<p>you can make the file usable as a script as well as an importable module,
because the code that parses the command line only runs if the module is
executed as the &#8220;main&#8221; file:</p>
<p>这个文件可以当作一个脚本来使用。而这部分代码只有在这个模块被当作&#8221;主&#8221;程序执行时才会被执行:</p>
<pre>$ python fibo.py 50
1 1 2 3 5 8 13 21 34</pre>
<p>If the module is imported, the code is not run:</p>
<p>如果这个模块是被导入的，那么这些代码是不被执行的:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">fibo</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
<p>This is often used either to provide a convenient user interface to a module, or
for testing purposes (running the module as a script executes a test suite).</p>
<p>模块经常通过这种写法来提供一些方便的接口，或者用来测试（直接运行脚本，会执行一个/组测试用例）。</p>
</div>
<div class="section" id="the-module-search-path">
<span id="tut-searchpath"></span><h3>The Module Search Path 模块的搜索路径<a class="headerlink" href="#the-module-search-path" title="Permalink to this headline">¶</a></h3>
<p id="index-982">When a module named <tt class="xref docutils literal"><span class="pre">spam</span></tt> is imported, the interpreter searches for a file
named <tt class="docutils literal"><span class="pre">spam.py</span></tt> in the current directory, and then in the list of
directories specified by the environment variable <span class="target" id="index-983"></span><a class="reference external" href="../using/cmdline.html#envvar-PYTHONPATH"><strong class="xref">PYTHONPATH</strong></a>.  This
has the same syntax as the shell variable <span class="target" id="index-984"></span><strong class="xref">PATH</strong>, that is, a list of
directory names.  When <span class="target" id="index-985"></span><a class="reference external" href="../using/cmdline.html#envvar-PYTHONPATH"><strong class="xref">PYTHONPATH</strong></a> is not set, or when the file is not
found there, the search continues in an installation-dependent default path; on
Unix, this is usually <tt class="docutils literal"><span class="pre">.:/usr/local/lib/python</span></tt>.</p>
<p>当试图导入一个叫做 <tt class="xref docutils literal"><span class="pre">spam</span></tt> 的模块，解释器会首先在当前目录搜索一个叫做 <tt class="docutils literal"><span class="pre">spam.py</span></tt>
的文件，然后会依次寻找定义在环境变量 <span class="target" id="index-986"></span><a class="reference external" href="../using/cmdline.html#envvar-PYTHONPATH"><strong class="xref">PYTHONPATH</strong></a> 中的所有目录。定义
<span class="target" id="index-987"></span><strong class="xref">PYTHONPATH`的语法和定义环境变量:envvar:`PATH`一样，都是一系列目录的列表。如果
:envvar:`PYTHONPATH`没有定义，或者按照上面的路径没有找到这个文件，那么解释器会继续在Python
安装时定义的默认目录来寻找。在Unix中，通常都是在:file:</strong>.:/usr/local/lib/python`。</p>
<p>Actually, modules are searched in the list of directories given by the variable
<tt class="docutils literal"><span class="pre">sys.path</span></tt> which is initialized from the directory containing the input script
(or the current directory), <span class="target" id="index-988"></span><a class="reference external" href="../using/cmdline.html#envvar-PYTHONPATH"><strong class="xref">PYTHONPATH</strong></a> and the installation- dependent
default.  This allows Python programs that know what they&#8217;re doing to modify or
replace the module search path.  Note that because the directory containing the
script being run is on the search path, it is important that the script not have
the same name as a standard module, or Python will attempt to load the script as
a module when that module is imported. This will generally be an error.  See
section <a class="reference internal" href="#tut-standardmodules"><em>Standard Modules    标准组件</em></a> for more information.</p>
<p>实际上，这些模块都是在变量 <tt class="docutils literal"><span class="pre">sys.path</span></tt> 定义的目录里寻找。``sys.path`` 包含了输入脚本的目录
（或者说当前目录），:envvar:<cite>PYTHONPATH</cite> 和安装时候的默认目录。Python 程序员可以去修改这个
搜索路径。注意，因为被执行的脚本所在的目录也在模块的搜索路径中，那么被执行的脚本的名字一定要和标
准的模块名称区别开来。这非常重要，否则当要导入标准模块的时候，Python 会试图导入这个脚本。这会导
致错误的发生。请参阅 <a class="reference internal" href="#tut-standardmodules"><em>Standard Modules    标准组件</em></a> 章节获取更多信息。</p>
</div>
<div class="section" id="compiled-python-files-python">
<h3>&#8220;Compiled&#8221; Python files “编译的”Python文件<a class="headerlink" href="#compiled-python-files-python" title="Permalink to this headline">¶</a></h3>
<p>As an important speed-up of the start-up time for short programs that use a lot
of standard modules, if a file called <tt class="docutils literal"><span class="pre">spam.pyc</span></tt> exists in the directory
where <tt class="docutils literal"><span class="pre">spam.py</span></tt> is found, this is assumed to contain an
already-&#8220;byte-compiled&#8221; version of the module <tt class="xref docutils literal"><span class="pre">spam</span></tt>. The modification time
of the version of <tt class="docutils literal"><span class="pre">spam.py</span></tt> used to create <tt class="docutils literal"><span class="pre">spam.pyc</span></tt> is recorded in
<tt class="docutils literal"><span class="pre">spam.pyc</span></tt>, and the <tt class="docutils literal"><span class="pre">.pyc</span></tt> file is ignored if these don&#8217;t match.</p>
<p>在一个名为 <tt class="docutils literal"><span class="pre">spam.py</span></tt> 的文件启动时候，Python 会在同一个目录寻找一个叫 <tt class="docutils literal"><span class="pre">spam.pyc</span></tt>
的文件并且运行，这是一个重要的启动提速方式，尤其是你使用了大量的标准组件。 <tt class="docutils literal"><span class="pre">spam.pyc</span></tt> 是
模块 <tt class="xref docutils literal"><span class="pre">spam</span></tt> 的“字节编译”的版本。文件 <tt class="docutils literal"><span class="pre">spam.py</span></tt> 的修改时间将被记录在
<tt class="docutils literal"><span class="pre">spam.pyc</span></tt> 当中，如果当前的修改时间和记录的时间不一致，那么 <tt class="docutils literal"><span class="pre">spam.pyc</span></tt>
就会被忽略掉。</p>
<p>Normally, you don&#8217;t need to do anything to create the <tt class="docutils literal"><span class="pre">spam.pyc</span></tt> file.
Whenever <tt class="docutils literal"><span class="pre">spam.py</span></tt> is successfully compiled, an attempt is made to write
the compiled version to <tt class="docutils literal"><span class="pre">spam.pyc</span></tt>.  It is not an error if this attempt
fails; if for any reason the file is not written completely, the resulting
<tt class="docutils literal"><span class="pre">spam.pyc</span></tt> file will be recognized as invalid and thus ignored later.  The
contents of the <tt class="docutils literal"><span class="pre">spam.pyc</span></tt> file are platform independent, so a Python
module directory can be shared by machines of different architectures.</p>
<p>通常你不用操心如何去创建 <tt class="docutils literal"><span class="pre">spam.pyc`。每次</span> <span class="pre">:file:`spam.py</span></tt> 成功的编译之后，这个编译好
的内容便写入 <tt class="docutils literal"><span class="pre">spam.pyc</span></tt> 。这不会有任何的问题，如果在生成 <tt class="docutils literal"><span class="pre">spam.pyc`时候发生了</span>
<span class="pre">任何的错误，那么这个文件将会被识别为不可用的，并接会被忽略。:file:`spam.pyc</span></tt> 的内容是操作系
统无关的，所以 Python 的模块目录可以在不同的体系架构中共享。</p>
<p>Some tips for experts:</p>
<p>专家提醒：</p>
<ul class="simple">
<li>When the Python interpreter is invoked with the <a class="reference external" href="../using/cmdline.html#cmdoption-O"><em class="xref">-O</em></a> flag, optimized
code is generated and stored in <tt class="docutils literal"><span class="pre">.pyo</span></tt> files.  The optimizer currently
doesn&#8217;t help much; it only removes <a class="reference external" href="../reference/simple_stmts.html#assert"><tt class="xref docutils literal"><span class="pre">assert</span></tt></a> statements.  When
<a class="reference external" href="../using/cmdline.html#cmdoption-O"><em class="xref">-O</em></a> is used, <em>all</em> <a class="reference external" href="../glossary.html#term-bytecode"><em class="xref">bytecode</em></a> is optimized; <tt class="docutils literal"><span class="pre">.pyc</span></tt> files are
ignored and <tt class="docutils literal"><span class="pre">.py</span></tt> files are compiled to optimized bytecode.</li>
<li>当采用 <a class="reference external" href="../using/cmdline.html#cmdoption-O"><em class="xref">-O</em></a> 参数来启动 Python 的解析器时，Python 会生成优化的代码，并且存入</li>
</ul>
<p><tt class="docutils literal"><span class="pre">.pyo`文件中。当前的优化器只能去掉采用:keyword:`assert`标记的语句，除此之外就没</span>
<span class="pre">什么用了。当:option:</span></tt>-O`参数启用，*所有*:term:<cite>字节码`都会被优化，忽略`</cite>.pyc``文件，
并且所有的``.py``文件都被优化成为字节码。</p>
<ul class="simple">
<li>Passing two <a class="reference external" href="../using/cmdline.html#cmdoption-O"><em class="xref">-O</em></a> flags to the Python interpreter (<a class="reference external" href="../using/cmdline.html#cmdoption-OO"><em class="xref">-OO</em></a>) will
cause the bytecode compiler to perform optimizations that could in some rare
cases result in malfunctioning programs.  Currently only <tt class="docutils literal"><span class="pre">__doc__</span></tt> strings are
removed from the bytecode, resulting in more compact <tt class="docutils literal"><span class="pre">.pyo</span></tt> files.  Since
some programs may rely on having these available, you should only use this
option if you know what you&#8217;re doing.</li>
<li>Python解析器使用两个 <a class="reference external" href="../using/cmdline.html#cmdoption-O"><em class="xref">-O</em></a> 参数（:option:<a href="#id9"><span class="problematic" id="id10">`</span></a>-OO`）将采用字节码编译以便提高性能，不</li>
</ul>
<p>过在一些罕见的情况下会导致程序执行异常。暂时这个工作只会把字节码中的 <tt class="docutils literal"><span class="pre">`__doc__</span></tt> 字符串去掉，
字节码也会更加紧凑，然后存到 <tt class="docutils literal"><span class="pre">.pyo</span></tt> 文件中。虽然很多的程序都相信这些优化工作，但是还是
建议你在做之前，确认一下自己是在干什么。</p>
<ul class="simple">
<li>A program doesn&#8217;t run any faster when it is read from a <tt class="docutils literal"><span class="pre">.pyc</span></tt> or
<tt class="docutils literal"><span class="pre">.pyo</span></tt> file than when it is read from a <tt class="docutils literal"><span class="pre">.py</span></tt> file; the only thing
that&#8217;s faster about <tt class="docutils literal"><span class="pre">.pyc</span></tt> or <tt class="docutils literal"><span class="pre">.pyo</span></tt> files is the speed with which
they are loaded.</li>
<li>程序并不会因为读取 <tt class="docutils literal"><span class="pre">.pyc</span></tt> 或者 <tt class="docutils literal"><span class="pre">.pyo</span></tt> 文件而比 <tt class="docutils literal"><span class="pre">.py</span></tt> 文件运行的更快。</li>
</ul>
<p>唯一会提升的只是他们加载的速度。</p>
<ul class="simple">
<li>When a script is run by giving its name on the command line, the bytecode for
the script is never written to a <tt class="docutils literal"><span class="pre">.pyc</span></tt> or <tt class="docutils literal"><span class="pre">.pyo</span></tt> file.  Thus, the
startup time of a script may be reduced by moving most of its code to a module
and having a small bootstrap script that imports that module.  It is also
possible to name a <tt class="docutils literal"><span class="pre">.pyc</span></tt> or <tt class="docutils literal"><span class="pre">.pyo</span></tt> file directly on the command
line.</li>
<li>在命令行中直接运行的脚本文件不会把编译的字节码写入 <tt class="docutils literal"><span class="pre">.pyc</span></tt> 或 <tt class="docutils literal"><span class="pre">.pyo</span></tt> 中。所以，</li>
</ul>
<p>你应该把大部分的代码转移到你的模块当中，用一个短小的启动脚本来导入它们。或者把这个脚本的
<tt class="docutils literal"><span class="pre">.pyc</span></tt> 或 <tt class="docutils literal"><span class="pre">.pyo</span></tt> 文件直接放在要执行的目录中也可以。</p>
<ul class="simple">
<li>It is possible to have a file called <tt class="docutils literal"><span class="pre">spam.pyc</span></tt> (or <tt class="docutils literal"><span class="pre">spam.pyo</span></tt>
when <a class="reference external" href="../using/cmdline.html#cmdoption-O"><em class="xref">-O</em></a> is used) without a file <tt class="docutils literal"><span class="pre">spam.py</span></tt> for the same module.
This can be used to distribute a library of Python code in a form that is
moderately hard to reverse engineer.</li>
<li>你还可以在提供一个模块的时候只提供类似 <tt class="docutils literal"><span class="pre">spam.pyc</span></tt> （或者通过 <a class="reference external" href="../using/cmdline.html#cmdoption-O"><em class="xref">-O</em></a> 生成的</li>
</ul>
<p><tt class="docutils literal"><span class="pre">spam.pyo</span></tt> ）文件，而没有 <tt class="docutils literal"><span class="pre">spam.py</span></tt> 。这主要是为了把你的 Python 文件当作库
文件来发布，目的嘛，还不是为了让那些反向工程者多费一些脑细胞。</p>
<blockquote>
</blockquote>
<ul class="simple" id="index-989">
<li>The module <a title="Tools for byte-compiling all Python source files in a directory tree." class="reference external" href="../library/compileall.html"><tt class="xref docutils literal"><span class="pre">compileall</span></tt></a> can create <tt class="docutils literal"><span class="pre">.pyc</span></tt> files (or <tt class="docutils literal"><span class="pre">.pyo</span></tt>
files when <a class="reference external" href="../using/cmdline.html#cmdoption-O"><em class="xref">-O</em></a> is used) for all modules in a directory.</li>
<li>这个叫做 <a title="Tools for byte-compiling all Python source files in a directory tree." class="reference external" href="../library/compileall.html"><tt class="xref docutils literal"><span class="pre">compileall</span></tt></a> 的组件可以帮助你把一个目录中的所有模块都编译成为</li>
</ul>
<p><tt class="docutils literal"><span class="pre">.pyc</span></tt> （或者用 <a class="reference external" href="../using/cmdline.html#cmdoption-O"><em class="xref">-O</em></a> 来生成 <tt class="docutils literal"><span class="pre">.pyo</span></tt> ）</p>
<ul class="simple">
<li>If using Python in a parallel processing system with a shared file system,
you need to patch Python to disable the creation of the compiled files
because otherwise the multiple Python interpreters will encounter race
conditions in creating them.</li>
<li>如果你的 Python 程序存放在一个共享的文件系统，供并行处理的系统使用，那么你应该告诉 Python</li>
</ul>
<p>不要创建编译的字节码文件。因为这会让多个 Python 解析器在创建文件时候发生资源竞争。</p>
</div>
</div>
<div class="section" id="standard-modules">
<span id="tut-standardmodules"></span><h2>Standard Modules    标准组件<a class="headerlink" href="#standard-modules" title="Permalink to this headline">¶</a></h2>
<p id="index-990">Python comes with a library of standard modules, described in a separate
document, the Python Library Reference (&#8220;Library Reference&#8221; hereafter).  Some
modules are built into the interpreter; these provide access to operations that
are not part of the core of the language but are nevertheless built in, either
for efficiency or to provide access to operating system primitives such as
system calls.  The set of such modules is a configuration option which also
depends on the underlying platform For example, the <a title="(Windows) Routines and objects for manipulating the Windows registry." class="reference external" href="../library/winreg.html"><tt class="xref docutils literal"><span class="pre">winreg</span></tt></a> module is only
provided on Windows systems. One particular module deserves some attention:
<a title="Access system-specific parameters and functions." class="reference external" href="../library/sys.html"><tt class="xref docutils literal"><span class="pre">sys</span></tt></a>, which is built into every Python interpreter.  The variables
<tt class="docutils literal"><span class="pre">sys.ps1</span></tt> and <tt class="docutils literal"><span class="pre">sys.ps2</span></tt> define the strings used as primary and secondary
prompts:</p>
<p>Python 本身带着一些标准的模块库，在 Python 库参考文档中将会介绍到（就是后面的“库参考文档”）。
有些模块直接被构建在解析器里，这些虽然不是一些语言内置的功能，但是他却能很高效的使用，甚至是系统
级调用也没问题。这些组件会根据不同的操作系统进行不同形式的配置，比如 <a title="(Windows) Routines and objects for manipulating the Windows registry." class="reference external" href="../library/winreg.html"><tt class="xref docutils literal"><span class="pre">winreg</span></tt></a> 这个模块就
只会提供给 Windows 系统。应该注意到这有一个特别的模块 <a title="Access system-specific parameters and functions." class="reference external" href="../library/sys.html"><tt class="xref docutils literal"><span class="pre">sys</span></tt></a> ，它内置在每一个 Python
解析器中。变量 <tt class="docutils literal"><span class="pre">sys.ps1</span></tt> 和 <tt class="docutils literal"><span class="pre">sys.ps2</span></tt> 定义了主提示符和副提示符所对应的字符串:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sys</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">ps1</span>
<span class="go">&#39;&gt;&gt;&gt; &#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">ps2</span>
<span class="go">&#39;... &#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">ps1</span> <span class="o">=</span> <span class="s">&#39;C&gt; &#39;</span>
<span class="go">C&gt; print(&#39;Yuck!&#39;)</span>
<span class="go">Yuck!</span>
<span class="go">C&gt;</span>
</pre></div>
<p>These two variables are only defined if the interpreter is in interactive mode.</p>
<p>只有在交互式模式中，这两个变量才有定义。</p>
<p>The variable <tt class="docutils literal"><span class="pre">sys.path</span></tt> is a list of strings that determines the interpreter&#8217;s
search path for modules. It is initialized to a default path taken from the
environment variable <span class="target" id="index-991"></span><a class="reference external" href="../using/cmdline.html#envvar-PYTHONPATH"><strong class="xref">PYTHONPATH</strong></a>, or from a built-in default if
<span class="target" id="index-992"></span><a class="reference external" href="../using/cmdline.html#envvar-PYTHONPATH"><strong class="xref">PYTHONPATH</strong></a> is not set.  You can modify it using standard list
operations:</p>
<p>我们说过，解释器从 <tt class="docutils literal"><span class="pre">sys.path</span></tt> 搜索模块，``sys.path`` 是一个存放着所有路径的字符串列表。
如果定义了环境变量 <span class="target" id="index-993"></span><a class="reference external" href="../using/cmdline.html#envvar-PYTHONPATH"><strong class="xref">PYTHONPATH</strong></a> ，那么从这里构建 <tt class="docutils literal"><span class="pre">sys.path</span></tt> ，否则使用一个内
置的默认值。你可以使用标准用的列表操作来改变这个列表。</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sys</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;/ufs/guido/lib/python&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="section" id="the-dir-function-dir">
<span id="tut-dir"></span><h2>The <a title="dir" class="reference external" href="../library/functions.html#dir"><tt class="xref docutils literal"><span class="pre">dir()</span></tt></a> Function    <a title="dir" class="reference external" href="../library/functions.html#dir"><tt class="xref docutils literal"><span class="pre">dir()</span></tt></a> 函数<a class="headerlink" href="#the-dir-function-dir" title="Permalink to this headline">¶</a></h2>
<p>The built-in function <a title="dir" class="reference external" href="../library/functions.html#dir"><tt class="xref docutils literal"><span class="pre">dir()</span></tt></a> is used to find out which names a module
defines.  It returns a sorted list of strings:</p>
<p>内置的函数 <a title="dir" class="reference external" href="../library/functions.html#dir"><tt class="xref docutils literal"><span class="pre">dir()</span></tt></a> 可以找到模块内定义的所有名称。以一个字符串列表的形式返回:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">fibo</span><span class="o">,</span> <span class="nn">sys</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">dir</span><span class="p">(</span><span class="n">fibo</span><span class="p">)</span>
<span class="go">[&#39;__name__&#39;, &#39;fib&#39;, &#39;fib2&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">dir</span><span class="p">(</span><span class="n">sys</span><span class="p">)</span>
<span class="go">[&#39;__displayhook__&#39;, &#39;__doc__&#39;, &#39;__excepthook__&#39;, &#39;__name__&#39;, &#39;__stderr__&#39;,</span>
<span class="go"> &#39;__stdin__&#39;, &#39;__stdout__&#39;, &#39;_getframe&#39;, &#39;api_version&#39;, &#39;argv&#39;,</span>
<span class="go"> &#39;builtin_module_names&#39;, &#39;byteorder&#39;, &#39;callstats&#39;, &#39;copyright&#39;,</span>
<span class="go"> &#39;displayhook&#39;, &#39;exc_info&#39;, &#39;excepthook&#39;,</span>
<span class="go"> &#39;exec_prefix&#39;, &#39;executable&#39;, &#39;exit&#39;, &#39;getdefaultencoding&#39;, &#39;getdlopenflags&#39;,</span>
<span class="go"> &#39;getrecursionlimit&#39;, &#39;getrefcount&#39;, &#39;hexversion&#39;, &#39;maxint&#39;, &#39;maxunicode&#39;,</span>
<span class="go"> &#39;meta_path&#39;, &#39;modules&#39;, &#39;path&#39;, &#39;path_hooks&#39;, &#39;path_importer_cache&#39;,</span>
<span class="go"> &#39;platform&#39;, &#39;prefix&#39;, &#39;ps1&#39;, &#39;ps2&#39;, &#39;setcheckinterval&#39;, &#39;setdlopenflags&#39;,</span>
<span class="go"> &#39;setprofile&#39;, &#39;setrecursionlimit&#39;, &#39;settrace&#39;, &#39;stderr&#39;, &#39;stdin&#39;, &#39;stdout&#39;,</span>
<span class="go"> &#39;version&#39;, &#39;version_info&#39;, &#39;warnoptions&#39;]</span>
</pre></div>
<p>Without arguments, <a title="dir" class="reference external" href="../library/functions.html#dir"><tt class="xref docutils literal"><span class="pre">dir()</span></tt></a> lists the names you have defined currently:</p>
<p>如果没有给定参数，那么 <a title="dir" class="reference external" href="../library/functions.html#dir"><tt class="xref docutils literal"><span class="pre">dir()</span></tt></a> 函数会罗列出当前定义的所有名称:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1</span><span class="p">,</span> <span class="mf">2</span><span class="p">,</span> <span class="mf">3</span><span class="p">,</span> <span class="mf">4</span><span class="p">,</span> <span class="mf">5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">fibo</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fib</span> <span class="o">=</span> <span class="n">fibo</span><span class="o">.</span><span class="n">fib</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">dir</span><span class="p">()</span>
<span class="go">[&#39;__builtins__&#39;, &#39;__doc__&#39;, &#39;__file__&#39;, &#39;__name__&#39;, &#39;a&#39;, &#39;fib&#39;, &#39;fibo&#39;, &#39;sys&#39;]</span>
</pre></div>
<p>Note that it lists all types of names: variables, modules, functions, etc.</p>
<p>注意，它会把所有的名称都列出来: 变量，模块，函数等等。</p>
<p id="index-994"><a title="dir" class="reference external" href="../library/functions.html#dir"><tt class="xref docutils literal"><span class="pre">dir()</span></tt></a> does not list the names of built-in functions and variables.  If you
want a list of those, they are defined in the standard module
<a title="The module that provides the built-in namespace." class="reference external" href="../library/builtins.html"><tt class="xref docutils literal"><span class="pre">builtins</span></tt></a>:</p>
<pre>:func:`dir` 函数并不会列出内置的函数和变量的名称，如果你坚持你想得到它们，那么你去问一个叫做
:mod:`builtins` 的标准模块好了::</pre>
<blockquote>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">builtins</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">dir</span><span class="p">(</span><span class="n">builtins</span><span class="p">)</span>
</pre></div>
<p>[&#8216;ArithmeticError&#8217;, &#8216;AssertionError&#8217;, &#8216;AttributeError&#8217;, &#8216;BaseException&#8217;, &#8216;Buffer
Error&#8217;, &#8216;DeprecationWarning&#8217;, &#8216;EOFError&#8217;, &#8216;Ellipsis&#8217;, &#8216;EnvironmentError&#8217;, &#8216;Excep
tion&#8217;, &#8216;False&#8217;, &#8216;FloatingPointError&#8217;, &#8216;FutureWarning&#8217;, &#8216;GeneratorExit&#8217;, &#8216;IOError
&#8216;, &#8216;ImportError&#8217;, &#8216;ImportWarning&#8217;, &#8216;IndentationError&#8217;, &#8216;IndexError&#8217;, &#8216;KeyError&#8217;,</p>
<blockquote>
&#8216;KeyboardInterrupt&#8217;, &#8216;LookupError&#8217;, &#8216;MemoryError&#8217;, &#8216;NameError&#8217;, &#8216;None&#8217;, &#8216;NotImp</blockquote>
<p>lemented&#8217;, &#8216;NotImplementedError&#8217;, &#8216;OSError&#8217;, &#8216;OverflowError&#8217;, &#8216;PendingDeprecatio
nWarning&#8217;, &#8216;ReferenceError&#8217;, &#8216;RuntimeError&#8217;, &#8216;RuntimeWarning&#8217;, &#8216;StopIteration&#8217;,
&#8216;SyntaxError&#8217;, &#8216;SyntaxWarning&#8217;, &#8216;SystemError&#8217;, &#8216;SystemExit&#8217;, &#8216;TabError&#8217;, &#8216;True&#8217;,</p>
<blockquote>
&#8216;TypeError&#8217;, &#8216;UnboundLocalError&#8217;, &#8216;UnicodeDecodeError&#8217;, &#8216;UnicodeEncodeError&#8217;, &#8216;</blockquote>
<p>UnicodeError&#8217;, &#8216;UnicodeTranslateError&#8217;, &#8216;UnicodeWarning&#8217;, &#8216;UserWarning&#8217;, &#8216;ValueE
rror&#8217;, &#8216;Warning&#8217;, &#8216;ZeroDivisionError&#8217;, &#8216;__build_class__&#8217;, &#8216;__debug__&#8217;, &#8216;__doc__&#8217;
, &#8216;__import__&#8217;, &#8216;__name__&#8217;, &#8216;abs&#8217;, &#8216;all&#8217;, &#8216;any&#8217;, &#8216;basestring&#8217;, &#8216;bin&#8217;, &#8216;bool&#8217;, &#8216;b
uffer&#8217;, &#8216;bytes&#8217;, &#8216;chr&#8217;, &#8216;chr8&#8217;, &#8216;classmethod&#8217;, &#8216;cmp&#8217;, &#8216;compile&#8217;, &#8216;complex&#8217;, &#8216;cop
yright&#8217;, &#8216;credits&#8217;, &#8216;delattr&#8217;, &#8216;dict&#8217;, &#8216;dir&#8217;, &#8216;divmod&#8217;, &#8216;enumerate&#8217;, &#8216;eval&#8217;, &#8216;ex
ec&#8217;, &#8216;exit&#8217;, &#8216;filter&#8217;, &#8216;float&#8217;, &#8216;frozenset&#8217;, &#8216;getattr&#8217;, &#8216;globals&#8217;, &#8216;hasattr&#8217;, &#8216;h
ash&#8217;, &#8216;help&#8217;, &#8216;hex&#8217;, &#8216;id&#8217;, &#8216;input&#8217;, &#8216;int&#8217;, &#8216;isinstance&#8217;, &#8216;issubclass&#8217;, &#8216;iter&#8217;, &#8216;
len&#8217;, &#8216;license&#8217;, &#8216;list&#8217;, &#8216;locals&#8217;, &#8216;map&#8217;, &#8216;max&#8217;, &#8216;memoryview&#8217;, &#8216;min&#8217;, &#8216;next&#8217;, &#8216;o
bject&#8217;, &#8216;oct&#8217;, &#8216;open&#8217;, &#8216;ord&#8217;, &#8216;pow&#8217;, &#8216;print&#8217;, &#8216;property&#8217;, &#8216;quit&#8217;, &#8216;range&#8217;, &#8216;repr
&#8216;, &#8216;reversed&#8217;, &#8216;round&#8217;, &#8216;set&#8217;, &#8216;setattr&#8217;, &#8216;slice&#8217;, &#8216;sorted&#8217;, &#8216;staticmethod&#8217;, &#8216;st
r&#8217;, &#8216;str8&#8217;, &#8216;sum&#8217;, &#8216;super&#8217;, &#8216;trunc&#8217;, &#8216;tuple&#8217;, &#8216;type&#8217;, &#8216;vars&#8217;, &#8216;zip&#8217;]</p>
</blockquote>
</div>
<div class="section" id="packages">
<span id="tut-packages"></span><h2>Packages    包<a class="headerlink" href="#packages" title="Permalink to this headline">¶</a></h2>
<p>Packages are a way of structuring Python&#8217;s module namespace by using &#8220;dotted
module names&#8221;.  For example, the module name <tt class="xref docutils literal"><span class="pre">A.B</span></tt> designates a submodule
named <tt class="docutils literal"><span class="pre">B</span></tt> in a package named <tt class="docutils literal"><span class="pre">A</span></tt>.  Just like the use of modules saves the
authors of different modules from having to worry about each other&#8217;s global
variable names, the use of dotted module names saves the authors of multi-module
packages like NumPy or the Python Imaging Library from having to worry about
each other&#8217;s module names.</p>
<p>包是一种管理 Python 模块命名空间的形式，采用“点模块名称”。比如一个模块的名称是 <tt class="xref docutils literal"><span class="pre">A.B`，</span>
<span class="pre">那么他表示一个包</span> <span class="pre">``A`</span></tt> 中的子模块 <tt class="docutils literal"><span class="pre">B</span></tt> 。就好像使用模块的时候，你不用担心不同模块之间的全局
变量相互影响一样，采用点模块名称这种形式也不用担心不同库之间的模块重名的情况。这样不同的作者都可
以提供 NumPy 模块，或者是 Python 图形库。</p>
<p>Suppose you want to design a collection of modules (a &#8220;package&#8221;) for the uniform
handling of sound files and sound data.  There are many different sound file
formats (usually recognized by their extension, for example: <tt class="docutils literal"><span class="pre">.wav</span></tt>,
<tt class="docutils literal"><span class="pre">.aiff</span></tt>, <tt class="docutils literal"><span class="pre">.au</span></tt>), so you may need to create and maintain a growing
collection of modules for the conversion between the various file formats.
There are also many different operations you might want to perform on sound data
(such as mixing, adding echo, applying an equalizer function, creating an
artificial stereo effect), so in addition you will be writing a never-ending
stream of modules to perform these operations.  Here&#8217;s a possible structure for
your package (expressed in terms of a hierarchical filesystem):</p>
<p>不妨假设你想设计一套统一处理声音文件和数据的模块（或者称之为一个“包”）。现存很多种不同的音频文件
格式（基本上都是通过后缀名区分的，例如： <tt class="docutils literal"><span class="pre">.wav`，:file:</span></tt>.aiff`，:file:<a href="#id11"><span class="problematic" id="id12">`</span></a>.au`，），所
以你需要有一组不断增加的模块，用来在不同的格式之间转换。并且针对这些音频数据，还有很多不同的操作
（比如混音，添加回声，增加均衡器功能，创建人造立体声效果），所你还需要一组怎么也写不完的模块来处
理这些操作。这里给出了一种可能的包结构（在分层的文件系统中）:</p>
<pre>sound/                          Top-level package                         最顶层包
      __init__.py               Initialize the sound package              包声明和加载文件
      formats/                  Subpackage for file format conversions    文件格式相关的子包
              __init__.py
              wavread.py
              wavwrite.py
              aiffread.py
              aiffwrite.py
              auread.py
              auwrite.py
              ...
      effects/                  Subpackage for sound effects              音效相关的子包
              __init__.py
              echo.py
              surround.py
              reverse.py
              ...
      filters/                  Subpackage for filters                    滤镜相关的子包
              __init__.py
              equalizer.py
              vocoder.py
              karaoke.py
              ...</pre>
<p>When importing the package, Python searches through the directories on
<tt class="docutils literal"><span class="pre">sys.path</span></tt> looking for the package subdirectory.</p>
<p>在导入一个包的时候，Python 会根据 <tt class="docutils literal"><span class="pre">sys.path</span></tt> 中的目录来寻找这个包中包含的子目录。</p>
<p>The <tt class="docutils literal"><span class="pre">__init__.py</span></tt> files are required to make Python treat the directories
as containing packages; this is done to prevent directories with a common name,
such as <tt class="docutils literal"><span class="pre">string</span></tt>, from unintentionally hiding valid modules that occur later
on the module search path. In the simplest case, <tt class="docutils literal"><span class="pre">__init__.py</span></tt> can just be
an empty file, but it can also execute initialization code for the package or
set the <tt class="docutils literal"><span class="pre">__all__</span></tt> variable, described later.</p>
<p>目录只有包含一个叫做 <tt class="docutils literal"><span class="pre">__init__.py</span></tt> 的文件才会被认作是一个包，主要是为了避免一些滥俗的名字
（比如叫做``string``）不小心的影响搜索路径中的有效模块。最简单的情况，放一个空的
:file:<a href="#id13"><span class="problematic" id="id14">`</span></a>__init__.py`就可以了。当然这个文件中也可以包含一些初始化代码或者为（将在后面介绍的）
<a href="#id15"><span class="problematic" id="id16">``</span></a>__all__``变量赋值。</p>
<p>Users of the package can import individual modules from the package, for
example:</p>
<p>用户可以每次只导入一个包里面的特定模块，比如:</p>
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">sound.effects.echo</span>
</pre></div>
<p>This loads the submodule <tt class="xref docutils literal"><span class="pre">sound.effects.echo</span></tt>.  It must be referenced with
its full name.</p>
<p>这将会导入子模块:mod:<a href="#id17"><span class="problematic" id="id18">`</span></a>song.effects.echo`。 他必须使用全名去访问。:</p>
<div class="highlight"><pre><span class="n">sound</span><span class="o">.</span><span class="n">effects</span><span class="o">.</span><span class="n">echo</span><span class="o">.</span><span class="n">echofilter</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span> <span class="n">atten</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
<p>An alternative way of importing the submodule is:</p>
<p>还有一种导入子模块的方法是:</p>
<div class="highlight"><pre><span class="kn">from</span> <span class="nn">sound.effects</span> <span class="k">import</span> <span class="n">echo</span>
</pre></div>
<p>This also loads the submodule <tt class="xref docutils literal"><span class="pre">echo</span></tt>, and makes it available without its
package prefix, so it can be used as follows:</p>
<p>这同样会导入子模块:mod:<a href="#id19"><span class="problematic" id="id20">`</span></a>echo`，并且他不需要那些冗长的前缀，所以他可以这样使用:</p>
<div class="highlight"><pre><span class="n">echo</span><span class="o">.</span><span class="n">echofilter</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span> <span class="n">atten</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
<p>Yet another variation is to import the desired function or variable directly:</p>
<p>还有一种变化就是直接导入一个函数或者变量:</p>
<div class="highlight"><pre><span class="kn">from</span> <span class="nn">sound.effects.echo</span> <span class="k">import</span> <span class="n">echofilter</span>
</pre></div>
<p>Again, this loads the submodule <tt class="xref docutils literal"><span class="pre">echo</span></tt>, but this makes its function
<tt class="xref docutils literal"><span class="pre">echofilter()</span></tt> directly available:</p>
<p>同样的，这种方法会导入子模块:mod:<a href="#id21"><span class="problematic" id="id22">`</span></a>echo`，并且可以直接使用他的:func:<a href="#id23"><span class="problematic" id="id24">`</span></a>echofilter`函数:</p>
<div class="highlight"><pre><span class="n">echofilter</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span> <span class="n">atten</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
<p>Note that when using <tt class="docutils literal"><span class="pre">from</span> <span class="pre">package</span> <span class="pre">import</span> <span class="pre">item</span></tt>, the item can be either a
submodule (or subpackage) of the package, or some  other name defined in the
package, like a function, class or variable.  The <tt class="docutils literal"><span class="pre">import</span></tt> statement first
tests whether the item is defined in the package; if not, it assumes it is a
module and attempts to load it.  If it fails to find it, an <a title="exceptions.ImportError" class="reference external" href="../library/exceptions.html#exceptions.ImportError"><tt class="xref docutils literal"><span class="pre">ImportError</span></tt></a>
exception is raised.</p>
<p>注意当使用``from package import item``这种形式的时候，对应的item既可以是包里面的子模块
（子包），或者包里面定义的其他名称，比如函数，类或者变量。``import``语法会首先把item当作一
个包定义的名称，如果没找到，再试图按照一个模块去导入。如果还没找到，恭喜，一个:exc:<cite>ImportError</cite>
异常被抛出了。</p>
<p>Contrarily, when using syntax like <tt class="docutils literal"><span class="pre">import</span> <span class="pre">item.subitem.subsubitem</span></tt>, each item
except for the last must be a package; the last item can be a module or a
package but can&#8217;t be a class or function or variable defined in the previous
item.</p>
<p>反之，如果使用形如``import item.subitem.subsubitem``这种导入形式，除了最后一项，都必须
是包，而最后一项则可以是模块或者是包，但是不可以是类，函数或者变量的名字。</p>
<div class="section" id="importing-from-a-package">
<span id="tut-pkg-import-star"></span><h3>Importing * From a Package    导入一个包中的*<a class="headerlink" href="#importing-from-a-package" title="Permalink to this headline">¶</a></h3>
<p id="index-995">Now what happens when the user writes <tt class="docutils literal"><span class="pre">from</span> <span class="pre">sound.effects</span> <span class="pre">import</span> <span class="pre">*</span></tt>?  Ideally,
one would hope that this somehow goes out to the filesystem, finds which
submodules are present in the package, and imports them all.  Unfortunately,
this operation does not work very well on Windows platforms, where the
filesystem does not always have accurate information about the case of a
filename!  On these platforms, there is no guaranteed way to know whether a file
<tt class="docutils literal"><span class="pre">ECHO.PY</span></tt> should be imported as a module <tt class="xref docutils literal"><span class="pre">echo</span></tt>, <tt class="xref docutils literal"><span class="pre">Echo</span></tt> or
<tt class="xref docutils literal"><span class="pre">ECHO</span></tt>.  (For example, Windows 95 has the annoying practice of showing all
file names with a capitalized first letter.)  The DOS 8+3 filename restriction
adds another interesting problem for long module names.</p>
<p>设想一下，如果我们使用``from sound.effects import <a href="#id25"><span class="problematic" id="id26">*</span></a><a href="#id27"><span class="problematic" id="id28">``</span></a>会发生什么？ 只是想想嘛。Python
会进入文件系统，找到这个包里面所有的子模块，一个一个的把它们都导入进来。但是很不幸，这个方法在
Windows平台上工作的就不是非常好，因为Windows是一个大小写不区分的系统。在这类平台上，没有人敢
担保一个叫做 <tt class="docutils literal"><span class="pre">ECHO.py</span></tt> 的文件导入为模块:mod:<a href="#id29"><span class="problematic" id="id30">`</span></a>echo`还是:mod:<a href="#id31"><span class="problematic" id="id32">`</span></a>Echo`甚至:mod:<a href="#id33"><span class="problematic" id="id34">`</span></a>ECHO`。
（例如，Windows 95就很讨厌的把每一个文件的首字母大写显示。）而且 DOS 的 8+3 命名规则对长模
块名称的处理会把问题搞得更纠结。</p>
<p>The only solution is for the package author to provide an explicit index of the
package.  The import statement uses the following convention: if a package&#8217;s
<tt class="docutils literal"><span class="pre">__init__.py</span></tt> code defines a list named <tt class="docutils literal"><span class="pre">__all__</span></tt>, it is taken to be the
list of module names that should be imported when <tt class="docutils literal"><span class="pre">from</span> <span class="pre">package</span> <span class="pre">import</span> <span class="pre">*</span></tt> is
encountered.  It is up to the package author to keep this list up-to-date when a
new version of the package is released.  Package authors may also decide not to
support it, if they don&#8217;t see a use for importing * from their package.  For
example, the file <tt class="docutils literal"><span class="pre">sounds/effects/__init__.py</span></tt> could contain the following
code:</p>
<p>为了解决这个问题，只能烦劳包作者提供一个精确的包的索引了。导入语句遵循如下规则：如果包定义文件
<tt class="docutils literal"><span class="pre">__init__.py</span></tt> 存在一个叫做 <tt class="docutils literal"><span class="pre">__all__</span></tt> 的列表变量，那么在使用 <tt class="docutils literal"><span class="pre">from</span> <span class="pre">package</span>
<span class="pre">import</span> <span class="pre">*</span></tt> 的时候就把这个列表中的所有名字作为包内容导入。作为包的作者，可别忘了在更新包之后
保证 <tt class="docutils literal"><span class="pre">__all__</span></tt> 也更新了啊。你说我就不这么做，我就不使用导入*这种用法，好吧，没问题，谁让
你是老板呢。这里有一个例子，在:file:<a href="#id35"><span class="problematic" id="id36">`</span></a>sounds/effects/__init__.py`中包含如下代码:</p>
<pre>__all__ = ["echo", "surround", "reverse"]</pre>
<p>This would mean that <tt class="docutils literal"><span class="pre">from</span> <span class="pre">sound.effects</span> <span class="pre">import</span> <span class="pre">*</span></tt> would import the three
named submodules of the <tt class="xref docutils literal"><span class="pre">sound</span></tt> package.</p>
<p>这表示当你使用``from sound.effects import <a href="#id37"><span class="problematic" id="id38">*</span></a><a href="#id39"><span class="problematic" id="id40">``</span></a>这种用法时，你只会导入包里面这三个子模块。</p>
<p>If <tt class="docutils literal"><span class="pre">__all__</span></tt> is not defined, the statement <tt class="docutils literal"><span class="pre">from</span> <span class="pre">sound.effects</span> <span class="pre">import</span> <span class="pre">*</span></tt>
does <em>not</em> import all submodules from the package <tt class="xref docutils literal"><span class="pre">sound.effects</span></tt> into the
current namespace; it only ensures that the package <tt class="xref docutils literal"><span class="pre">sound.effects</span></tt> has
been imported (possibly running any initialization code in <tt class="docutils literal"><span class="pre">__init__.py</span></tt>)
and then imports whatever names are defined in the package.  This includes any
names defined (and submodules explicitly loaded) by <tt class="docutils literal"><span class="pre">__init__.py</span></tt>.  It
also includes any submodules of the package that were explicitly loaded by
previous import statements.  Consider this code:</p>
<p>如果``__all__``真的而没有定义，那么使用``from sound.effects import <a href="#id41"><span class="problematic" id="id42">*</span></a><a href="#id43"><span class="problematic" id="id44">``</span></a>这种语法的时候，
就*不会*导入包:mod:<a href="#id45"><span class="problematic" id="id46">`</span></a>sound.effects`里的任何子模块。他只是把包:mod:<a href="#id47"><span class="problematic" id="id48">`</span></a>sound.effects`和它
里面定义的所有内容导入进来（可能运行:file:<a href="#id49"><span class="problematic" id="id50">`</span></a>__init__.py`里定义的初始化代码）。这会把
:file:<a href="#id51"><span class="problematic" id="id52">`</span></a>__init__.py`里面定义的所有名字导入进来。并且他不会破坏掉我们在这句话之前导入的所有
明确指定的模块。看下这部分代码:</p>
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">sound.effects.echo</span>
<span class="kn">import</span> <span class="nn">sound.effects.surround</span>
<span class="kn">from</span> <span class="nn">sound.effects</span> <span class="k">import</span> <span class="o">*</span>
</pre></div>
<p>In this example, the echo and surround modules are imported in the current
namespace because they are defined in the <tt class="xref docutils literal"><span class="pre">sound.effects</span></tt> package when the
<tt class="docutils literal"><span class="pre">from...import</span></tt> statement is executed.  (This also works when <tt class="docutils literal"><span class="pre">__all__</span></tt> is
defined.)</p>
<p>这个例子中，在执行``from...import``前，包:mod:<a href="#id53"><span class="problematic" id="id54">`</span></a>sound.effects`中的echo和surround模
块都被导入到当前的命名空间中了。（当然如果定义了``__all__``就更没问题了。）</p>
<p>Note that in general the practice of importing <tt class="docutils literal"><span class="pre">*</span></tt> from a module or package is
frowned upon, since it often causes poorly readable code. However, it is okay to
use it to save typing in interactive sessions, and certain modules are designed
to export only names that follow certain patterns.</p>
<p>通常我们并不主张使用``*``这种方法来导入模块，因为这种方法经常会导致代码的可读性降低。不过
这样倒的确是可以省去不少敲键的功夫，而且一些模块都设计成了只能通过特定的方法导入。</p>
<p>Remember, there is nothing wrong with using <tt class="docutils literal"><span class="pre">from</span> <span class="pre">Package</span> <span class="pre">import</span>
<span class="pre">specific_submodule</span></tt>!  In fact, this is the recommended notation unless the
importing module needs to use submodules with the same name from different
packages.</p>
<p>记住，使用``from Package import specific_submodule``这种方法永远不会有错。事实上，
这也是推荐的方法。除非是你要导入的子模块有可能和其他包的子模块重名。</p>
</div>
<div class="section" id="intra-package-references">
<h3>Intra-package References    包内引用<a class="headerlink" href="#intra-package-references" title="Permalink to this headline">¶</a></h3>
<p>The submodules often need to refer to each other.  For example, the
<tt class="xref docutils literal"><span class="pre">surround</span></tt> module might use the <tt class="xref docutils literal"><span class="pre">echo</span></tt> module.  In fact, such
references are so common that the <a class="reference external" href="../reference/simple_stmts.html#import"><tt class="xref docutils literal"><span class="pre">import</span></tt></a> statement first looks in the
containing package before looking in the standard module search path. Thus, the
<tt class="xref docutils literal"><span class="pre">surround</span></tt> module can simply use <tt class="docutils literal"><span class="pre">import</span> <span class="pre">echo</span></tt> or <tt class="docutils literal"><span class="pre">from</span> <span class="pre">echo</span> <span class="pre">import</span>
<span class="pre">echofilter</span></tt>.  If the imported module is not found in the current package (the
package of which the current module is a submodule), the <a class="reference external" href="../reference/simple_stmts.html#import"><tt class="xref docutils literal"><span class="pre">import</span></tt></a>
statement looks for a top-level module with the given name.</p>
<p>子模块经常会相互引用，比如:mod:<a href="#id55"><span class="problematic" id="id56">`</span></a>surround`模块可能会用到:mod:<a href="#id57"><span class="problematic" id="id58">`</span></a>echo`模块。实际上，这
种引用是最常见的，而:keyword:<a href="#id59"><span class="problematic" id="id60">`</span></a>module`语句会首先查找同目录下是否有期望的模块，如果没
有再按照标准的模块搜索方式进行。所以在:mod:<a href="#id61"><span class="problematic" id="id62">`</span></a>surround`模块内部可以简单的使用``import
echo``或者``from echo import echofilter``。如果在当前包（就是把本模块当成子模块
的那个包）中没有找到期望的模块，那么:keyword:<a href="#id63"><span class="problematic" id="id64">`</span></a>import`会从最顶端开始寻找。</p>
<p>When packages are structured into subpackages (as with the <tt class="xref docutils literal"><span class="pre">sound</span></tt> package
in the example), you can use absolute imports to refer to submodules of siblings
packages.  For example, if the module <tt class="xref docutils literal"><span class="pre">sound.filters.vocoder</span></tt> needs to use
the <tt class="xref docutils literal"><span class="pre">echo</span></tt> module in the <tt class="xref docutils literal"><span class="pre">sound.effects</span></tt> package, it can use <tt class="docutils literal"><span class="pre">from</span>
<span class="pre">sound.effects</span> <span class="pre">import</span> <span class="pre">echo</span></tt>.</p>
<p>如果在结构中包是一个子包（比如这个例子中对于包:mod:<cite>sound`来说），而你又想导入兄弟包
（同级别的包）你就得使用导入绝对的路径来导入。比如，如果模块:mod:`sound.filters.vocoder</cite>
要使用包:mod:<a href="#id65"><span class="problematic" id="id66">`</span></a>sound.effects`中的模块:mod:<a href="#id67"><span class="problematic" id="id68">`</span></a>echo`，你就要写成
<a href="#id69"><span class="problematic" id="id70">``</span></a>from sound.effects import echo``。</p>
<p>Starting with Python 2.5, in addition to the implicit relative imports described
above, you can write explicit relative imports with the <tt class="docutils literal"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span>
<span class="pre">name</span></tt> form of import statement. These explicit relative imports use leading
dots to indicate the current and parent packages involved in the relative
import. From the <tt class="xref docutils literal"><span class="pre">surround</span></tt> module for example, you might use:</p>
<p>从 Python2.5 开始，上述的那种隐含的相对路径中的导入，可以被显式的相对路径来导入，
使用``from module import name``的方法。这种显式的相对路径导入使用一个点来表示
当前模块所属的包。我们以:mod:<a href="#id71"><span class="problematic" id="id72">`</span></a>surround`模块的位置为例，你可以使用:</p>
<div class="highlight"><pre><span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">echo</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="k">import</span> <span class="n">formats</span>
<span class="kn">from</span> <span class="nn">..filters</span> <span class="k">import</span> <span class="n">equalizer</span>
</pre></div>
<p>Note that both explicit and implicit relative imports are based on the name of
the current module. Since the name of the main module is always <tt class="docutils literal"><span class="pre">&quot;__main__&quot;</span></tt>,
modules intended for use as the main module of a Python application should
always use absolute imports.</p>
<p>无论是隐式的还是显式的相对导入都是从当前模块开始的。主模块的名字永远是``&#8221;__main__&#8221;<a href="#id73"><span class="problematic" id="id74">``</span></a>，
一个Python应用程序的主模块，应当总是使用绝对路径引用。</p>
</div>
<div class="section" id="packages-in-multiple-directories">
<h3>Packages in Multiple Directories    跨目录的包<a class="headerlink" href="#packages-in-multiple-directories" title="Permalink to this headline">¶</a></h3>
<p>Packages support one more special attribute, <tt class="xref docutils literal"><span class="pre">__path__</span></tt>.  This is
initialized to be a list containing the name of the directory holding the
package&#8217;s <tt class="docutils literal"><span class="pre">__init__.py</span></tt> before the code in that file is executed.  This
variable can be modified; doing so affects future searches for modules and
subpackages contained in the package.</p>
<p>包还提供一个额外的属性，:attr:<a href="#id75"><span class="problematic" id="id76">`</span></a>__path__`。这是一个目录列表，里面每一个包含的目录
都有为这个包服务的:file:<a href="#id77"><span class="problematic" id="id78">`</span></a>__init__.py`，你得在其他:file:<a href="#id79"><span class="problematic" id="id80">`</span></a>__init__.py`被执行
前定义哦。可以修改这个变量，用来影响包含在包里面的模块和子包。</p>
<p>While this feature is not often needed, it can be used to extend the set of
modules found in a package.</p>
<p>这个功能并不常用，一般用来扩展包里面的模块。</p>
<p class="rubric">Footnotes</p>
<table class="docutils footnote" frame="void" id="id81" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>In fact function definitions are also &#8216;statements&#8217; that are &#8216;executed&#8217;; the
execution enters the function name in the module&#8217;s global symbol table.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id82" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>事实上函数的定义也是一种“可执行的声明”，执行时候从模块的全局符号表来寻找函数的名称。</td></tr>
</tbody>
</table>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <h3><a href="../contents.html">Table Of Contents</a></h3>
            <ul>
<li><a class="reference external" href="">Modules 模块</a><ul>
<li><a class="reference external" href="#more-on-modules">More on Modules 深入模块</a><ul>
<li><a class="reference external" href="#executing-modules-as-scripts">Executing modules as scripts 像脚本一样运行模块</a></li>
<li><a class="reference external" href="#the-module-search-path">The Module Search Path 模块的搜索路径</a></li>
<li><a class="reference external" href="#compiled-python-files-python">&#8220;Compiled&#8221; Python files “编译的”Python文件</a></li>
</ul>
</li>
<li><a class="reference external" href="#standard-modules">Standard Modules    标准组件</a></li>
<li><a class="reference external" href="#the-dir-function-dir">The <tt class="docutils literal"><span class="pre">dir</span></tt> Function    <tt class="docutils literal"><span class="pre">dir</span></tt> 函数</a></li>
<li><a class="reference external" href="#packages">Packages    包</a><ul>
<li><a class="reference external" href="#importing-from-a-package">Importing * From a Package    导入一个包中的*</a></li>
<li><a class="reference external" href="#intra-package-references">Intra-package References    包内引用</a></li>
<li><a class="reference external" href="#packages-in-multiple-directories">Packages in Multiple Directories    跨目录的包</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            <h4>Previous topic</h4>
            <p class="topless"><a href="datastructures.html" title="previous chapter">Data Structures 数据结构</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="inputoutput.html" title="next chapter">Input and Output 输出和输出</a></p>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="../_sources/tutorial/modules.txt">Show Source</a></li>
            </ul>
          <h3>Quick search</h3>
            <form class="search" action="../search.html" method="get">
              <input type="text" name="q" size="18" /> <input type="submit" value="Go" />
              <input type="hidden" name="check_keywords" value="yes" />
              <input type="hidden" name="area" value="default" />
            </form>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../modindex.html" title="Global Module Index"
             accesskey="M">modules</a> |</li>
        <li class="right" >
          <a href="inputoutput.html" title="Input and Output 输出和输出"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="datastructures.html" title="Data Structures 数据结构"
             accesskey="P">previous</a> |</li>
<li><img src="../_static/py.png" alt="" style="vertical-align: middle; margin-top: -1px"/></li>

        <li><a href="../contents.html">Python v3.0c1 documentation</a> &raquo;</li>

          <li><a href="index.html" accesskey="U">The Python tutorial Python 入门指南</a> &raquo;</li>
      </ul>
    </div>
    <div class="footer">
      &copy; <a href="../copyright.html">Copyright</a> 1990-2008, Python Software Foundation.
      Last updated on Oct 31, 2008.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 0.5.
    </div>
  </body>
</html>