<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Floating Point Arithmetic: Issues and Limitations 浮点运算: 问题和限制 &mdash; Python v3.0c1 documentation</title>
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
          URL_ROOT:    '../',
          VERSION:     '3.0c1',
          COLLAPSE_MODINDEX: false,
          FILE_SUFFIX: '.html'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Python v3.0c1 documentation"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="Python v3.0c1 documentation" href="../index.html" />
    <link rel="up" title="The Python tutorial Python 入门指南" href="index.html" />
    <link rel="next" title="Using Python" href="../using/index.html" />
    <link rel="prev" title="Interactive Input Editing and History Substitution" href="interactive.html" />
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../modindex.html" title="Global Module Index"
             accesskey="M">modules</a> |</li>
        <li class="right" >
          <a href="../using/index.html" title="Using Python"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="interactive.html" title="Interactive Input Editing and History Substitution"
             accesskey="P">previous</a> |</li>
<li><img src="../_static/py.png" alt="" style="vertical-align: middle; margin-top: -1px"/></li>

        <li><a href="../contents.html">Python v3.0c1 documentation</a> &raquo;</li>

          <li><a href="index.html" accesskey="U">The Python tutorial Python 入门指南</a> &raquo;</li>
      </ul>
    </div>
    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  
  <div class="section" id="floating-point-arithmetic-issues-and-limitations">
<span id="tut-fp-issues"></span><h1>Floating Point Arithmetic:  Issues and Limitations 浮点运算: 问题和限制<a class="headerlink" href="#floating-point-arithmetic-issues-and-limitations" title="Permalink to this headline">¶</a></h1>
<p>Floating-point numbers are represented in computer hardware as base 2 (binary)
fractions. For example, the decimal fraction</p>
<p>浮点数在计算机硬件中以二进制的小数来表示. 比如, 十进制的小数</p>
<div class="highlight"><pre><span class="mf">0.125</span>
</pre></div>
<p>has value 1/10 + 2/100 + 5/1000, and in the same way the binary fraction</p>
<p>它的值为 1/10 + 2/100 + 5/1000, 同样在二进制小数中</p>
<div class="highlight"><pre><span class="mf">0.001</span>
</pre></div>
<p>has value 0/2 + 0/4 + 1/8.  These two fractions have identical values, the only
real difference being that the first is written in base 10 fractional notation,
and the second in base 2.</p>
<p>它的值是 0/2 + 0/4 + 1/8.  这两个小数的值相等, 唯一的差别是前一个是10进制的, 后一个是二进制的.</p>
<p>Unfortunately, most decimal fractions cannot be represented exactly as binary
fractions.  A consequence is that, in general, the decimal floating-point
numbers you enter are only approximated by the binary floating-point numbers
actually stored in the machine.</p>
<p>不幸的是, 多数的十进制小数不能被精确的表示为二进制小数. 导致的结果是, 计算机中存储的浮点数只是我们输入的十进制浮点数的近似值.</p>
<p>The problem is easier to understand at first in base 10.  Consider the fraction
1/3.  You can approximate that as a base 10 fraction</p>
<p>为了便于的理解, 我们举个十进制的例子. 考虑一下分数 1/3. 你可以把它写成十进制小数形式</p>
<div class="highlight"><pre><span class="mf">0.3</span>
</pre></div>
<p>or, better,</p>
<p>再精确一点</p>
<div class="highlight"><pre><span class="mf">0.33</span>
</pre></div>
<p>or, better,</p>
<p>更加精确</p>
<div class="highlight"><pre><span class="mf">0.333</span>
</pre></div>
<p>and so on.  No matter how many digits you&#8217;re willing to write down, the result
will never be exactly 1/3, but will be an increasingly better approximation of
1/3.</p>
<p>有可能变得更精确. 但是无论写多少个数字, 结果永远不会正好等于分数 1/3, 我们只能得到更近似于 1/3 的值.</p>
<p>In the same way, no matter how many base 2 digits you&#8217;re willing to use, the
decimal value 0.1 cannot be represented exactly as a base 2 fraction.  In base
2, 1/10 is the infinitely repeating fraction</p>
<p>同样, 不管使用多少个二进制数字, 十进制的值 0.1 无法精确的用二进制小数来表示. 在二进制中, 1/10 是一个无限循环小数</p>
<div class="highlight"><pre><span class="mf">0.0001100110011001100110011001100110011001100110011</span><span class="o">...</span>
</pre></div>
<p>Stop at any finite number of bits, and you get an approximation.  This is why
you see things like</p>
<p>取有限的位数, 得到一个近似值. 这就是为什么你会看到下面的结果</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="mf">0.1</span>
<span class="go">0.10000000000000001</span>
</pre></div>
<p>On most machines today, that is what you&#8217;ll see if you enter 0.1 at a Python
prompt.  You may not, though, because the number of bits used by the hardware to
store floating-point values can vary across machines, and Python only prints a
decimal approximation to the true decimal value of the binary approximation
stored by the machine.  On most machines, if Python were to print the true
decimal value of the binary approximation stored for 0.1, it would have to
display</p>
<p>对于大多数的计算机来说, 当你在Python提示符上输入 0.1 你会看到, 你会看到上面的. 如果不是, 那可能是因为在不同机器上硬件用来存储浮点数的内存大小不一样, 另外, Python 只打印机器存储的二进制对应十进制的近似值. 在大多数机器上, 如果Python打印出二进制 0.1 近似值对应的真实十进制的话, 那么会显示</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="mf">0.1</span>
<span class="go">0.1000000000000000055511151231257827021181583404541015625</span>
</pre></div>
<p>instead!  The Python prompt uses the builtin <a title="repr" class="reference external" href="../library/functions.html#repr"><tt class="xref docutils literal"><span class="pre">repr()</span></tt></a> function to obtain a
string version of everything it displays.  For floats, <tt class="docutils literal"><span class="pre">repr(float)</span></tt> rounds
the true decimal value to 17 significant digits, giving</p>
<p>在任何对象需要被当作 string 显示的时候, Python提示符用内置函数 <a title="repr" class="reference external" href="../library/functions.html#repr"><tt class="xref docutils literal"><span class="pre">repr()</span></tt></a> 来把对象转换成字符串. 对于浮点数, <tt class="docutils literal"><span class="pre">repr(float)</span></tt> 将浮点数的真实值取整变成 17 位有效数字, 就如同</p>
<div class="highlight"><pre><span class="mf">0.10000000000000001</span>
</pre></div>
<p><tt class="docutils literal"><span class="pre">repr(float)</span></tt> produces 17 significant digits because it turns out that&#8217;s
enough (on most machines) so that <tt class="docutils literal"><span class="pre">eval(repr(x))</span> <span class="pre">==</span> <span class="pre">x</span></tt> exactly for all finite
floats <em>x</em>, but rounding to 16 digits is not enough to make that true.</p>
<p>之所以 <tt class="docutils literal"><span class="pre">repr(float)</span></tt> 产生17位有效数字，是因为在执行``eval(repr(x)) == x``这样的表达式的时候，对那些有限位的浮点数 <a href="#id1"><span class="problematic" id="id2">*</span></a>x*，取整以后的16位数字足够让表达式值为真。</p>
<p>Note that this is in the very nature of binary floating-point: this is not a bug
in Python, and it is not a bug in your code either.  You&#8217;ll see the same kind of
thing in all languages that support your hardware&#8217;s floating-point arithmetic
(although some languages may not <em>display</em> the difference by default, or in all
output modes).</p>
<p>在处理浮点数的时候，这种情况相当的普遍：这不是Python的bug，也不是你写的代码的bug。在任何支持硬件浮点运算的语言中，都会出现这样的情况。(尽管在某些语言或者输出模式中，默认*显示*不出区别).</p>
<p>Python&#8217;s builtin <a title="str" class="reference external" href="../library/functions.html#str"><tt class="xref docutils literal"><span class="pre">str()</span></tt></a> function produces only 12 significant digits, and
you may wish to use that instead.  It&#8217;s unusual for <tt class="docutils literal"><span class="pre">eval(str(x))</span></tt> to
reproduce <em>x</em>, but the output may be more pleasant to look at</p>
<p>Python的内置函数 <a title="str" class="reference external" href="../library/functions.html#str"><tt class="xref docutils literal"><span class="pre">str()</span></tt></a> 只生成保留12位有效数字的浮点数，有时候你可以用它。使用``eval(str(x))``来处理*x*的方法不怎么常用，但是这个方法使得我们可以得到更加自然的输出值</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="mf">0.1</span><span class="p">))</span>
<span class="go">0.1</span>
</pre></div>
<p>It&#8217;s important to realize that this is, in a real sense, an illusion: the value
in the machine is not exactly 1/10, you&#8217;re simply rounding the <em>display</em> of the
true machine value.</p>
<p>但是我们必须明确的认识到，真实的情况是，在计算机中的值并不精确的等于1/10，我们只是简单的取整以后把它 <em>显示</em> 出来.</p>
<p>Other surprises follow from this one.  For example, after seeing</p>
<p>由此引发出一些其他的问题。比如下面的</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="mf">0.1</span>
<span class="go">0.10000000000000001</span>
</pre></div>
<p>you may be tempted to use the <a title="round" class="reference external" href="../library/functions.html#round"><tt class="xref docutils literal"><span class="pre">round()</span></tt></a> function to chop it back to the
single digit you expect.  But that makes no difference</p>
<p>当我们打算用 :func:<a href="#id3"><span class="problematic" id="id4">`</span></a>round`函数取小数点后面一位的时候，却发现完全没有作用</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">round</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">1</span><span class="p">)</span>
<span class="go">0.10000000000000001</span>
</pre></div>
<p>The problem is that the binary floating-point value stored for &#8220;0.1&#8221; was already
the best possible binary approximation to 1/10, so trying to round it again
can&#8217;t make it better:  it was already as good as it gets.</p>
<p>出现这样的问题的原因是，&#8221;0.1&#8221;的二进制的浮点数值已经是1/10的最近似值了，所以无论怎么近似，结果还是一样。</p>
<p>Another consequence is that since 0.1 is not exactly 1/10, summing ten values of
0.1 may not yield exactly 1.0, either</p>
<p>另外一个后果是，因为0.1不等于1/10，所以十个0.1之和也不会等于1.0</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">sum</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mf">10</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">sum</span> <span class="o">+=</span> <span class="mf">0.1</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sum</span>
<span class="go">0.99999999999999989</span>
</pre></div>
<p>Binary floating-point arithmetic holds many surprises like this.  The problem
with &#8220;0.1&#8221; is explained in precise detail below, in the &#8220;Representation Error&#8221;
section.  See <a class="reference external" href="http://www.lahey.com/float.htm">The Perils of Floating Point</a>
for a more complete account of other common surprises.</p>
<p>二进制浮点运算给我们带来很多这样的“惊喜”。&#8221;0.1&#8221;带来的问题在本文的&#8221;表现错误&#8221;小节中有着详细的解释。另外，`The Perils of Floating Point &lt;<a class="reference external" href="http://www.lahey.com/float.htm">http://www.lahey.com/float.htm</a>&gt;`_ 中也有更加完整的描述。</p>
<p>As that says near the end, &#8220;there are no easy answers.&#8221;  Still, don&#8217;t be unduly
wary of floating-point!  The errors in Python float operations are inherited
from the floating-point hardware, and on most machines are on the order of no
more than 1 part in 2**53 per operation.  That&#8217;s more than adequate for most
tasks, but you do need to keep in mind that it&#8217;s not decimal arithmetic, and
that every float operation can suffer a new rounding error.</p>
<p>最后我们要说，“没有完美的方法”。但是，不要过分的拒绝浮点数！Python浮点操作中的错误是由硬件本身限制的，在大多数的机器上每次运算的误差不会超过2的53次方之一。这样的误差在大多数的任务中是可以被接受的。但是，我们还是要牢记我们做的并不是十进制运算，任何一个浮点预算都有可能产生一个新的错误。</p>
<p>While pathological cases do exist, for most casual use of floating-point
arithmetic you&#8217;ll see the result you expect in the end if you simply round the
display of your final results to the number of decimal digits you expect.
<a title="str" class="reference external" href="../library/functions.html#str"><tt class="xref docutils literal"><span class="pre">str()</span></tt></a> usually suffices, and for finer control see the discussion of
Python&#8217;s <tt class="docutils literal"><span class="pre">%</span></tt> format operator: the <tt class="docutils literal"><span class="pre">%g</span></tt>, <tt class="docutils literal"><span class="pre">%f</span></tt> and <tt class="docutils literal"><span class="pre">%e</span></tt> format codes
supply flexible and easy ways to round float results for display.</p>
<p>当不出意外的时候，通常情况下大多数的浮点运算我们会得到我们期望的结果，你只需要简单的取小数位，最终得到和十进制的一样的显示结果。:func:<cite>str</cite> 函数基本上够用了，为了更好的控制我们还可以看看Python的``%``格式化操作符：``%g``, <a href="#id5"><span class="problematic" id="id6">``</span></a>%f``和``%e``格式化符能让我们灵活而简单的得到我们想要显示的结果。</p>
<p>If you are a heavy user of floating point operations you should take a look
at the Numerical Python package and many other packages for mathematical and
statistical operations supplied by the SciPy project. See &lt;<a class="reference external" href="http://scipy.org">http://scipy.org</a>&gt;.</p>
<p>如果你在工作中频繁的使用浮点数，你应该看一看为数学准备的Numerical Python库和为统计学操作准备的SciPy项目，参见 &lt;<a class="reference external" href="http://scipy.org">http://scipy.org</a>&gt;.</p>
<div class="section" id="representation-error">
<span id="tut-fp-error"></span><h2>Representation Error 表示错误<a class="headerlink" href="#representation-error" title="Permalink to this headline">¶</a></h2>
<p>This section explains the &#8220;0.1&#8221; example in detail, and shows how you can perform
an exact analysis of cases like this yourself.  Basic familiarity with binary
floating-point representation is assumed.</p>
<p>本节详细讨论“0.1”问题，向你展示如何自已进行一个精确的分析。基本掌握二进制浮点数表示理论。</p>
<p><em>Representation error</em> refers to the fact that some (most, actually)
decimal fractions cannot be represented exactly as binary (base 2) fractions.
This is the chief reason why Python (or Perl, C, C++, Java, Fortran, and many
others) often won&#8217;t display the exact decimal number you expect</p>
<pre>:dfn:`表示错误` 源于事实上一些（事实上是大多）十进制分数不能精确表示为二进制分数。这就是Python（</pre>
<p>以及 Perl，C，C++，Java，Fortran 等等）语言通常不会显示出你期望的十进制数值的原因：</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="mf">0.1</span>
<span class="go">0.10000000000000001</span>
</pre></div>
<p>Why is that?  1/10 is not exactly representable as a binary fraction. Almost all
machines today (November 2000) use IEEE-754 floating point arithmetic, and
almost all platforms map Python floats to IEEE-754 &#8220;double precision&#8221;.  754
doubles contain 53 bits of precision, so on input the computer strives to
convert 0.1 to the closest fraction it can of the form <em>J</em>/2***N* where <em>J</em> is
an integer containing exactly 53 bits.  Rewriting</p>
<p>这是为什么？ 1/10 不能被精确表示为二进制分数。今天（2000年十一月）的大多数机器使
用 IEEE-754 浮点算法，大多平台将 Python 浮点数对映为 IEEE-754 “双精度浮点数”。
754 双精度浮点数有 53 比特位精度，所以计算机输入时将 0.1 尽可能的转为最接近的
<em>J</em>/2***N* 形式。 <em>J</em> 是一个包含53比特的整数。如下：</p>
<div class="highlight"><pre><span class="mi">1</span> <span class="o">/</span> <span class="mi">10</span> <span class="o">~=</span> <span class="n">J</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">N</span><span class="p">)</span>
</pre></div>
<p>as</p>
<p>即</p>
<div class="highlight"><pre><span class="n">J</span> <span class="o">~=</span> <span class="mi">2</span><span class="o">**</span><span class="n">N</span> <span class="o">/</span> <span class="mi">10</span>
</pre></div>
<p>and recalling that <em>J</em> has exactly 53 bits (is <tt class="docutils literal"><span class="pre">&gt;=</span> <span class="pre">2**52</span></tt> but <tt class="docutils literal"><span class="pre">&lt;</span> <span class="pre">2**53</span></tt>),
the best value for <em>N</em> is 56</p>
<p>前面提到 <em>J</em> 需要 53 比特位（``大于等于 2**52`` 且 <a href="#id7"><span class="problematic" id="id8">``</span></a>小于53``）， <em>N</em> 的最佳值是
56：</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="mf">2</span><span class="o">**</span><span class="mf">52</span>
<span class="go">4503599627370496L</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mf">2</span><span class="o">**</span><span class="mf">53</span>
<span class="go">9007199254740992L</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mf">2</span><span class="o">**</span><span class="mf">56</span><span class="o">/</span><span class="mf">10</span>
<span class="go">7205759403792793L</span>
</pre></div>
<p>That is, 56 is the only value for <em>N</em> that leaves <em>J</em> with exactly 53 bits.  The
best possible value for <em>J</em> is then that quotient rounded</p>
<p>于是，对于 <em>J</em> 期待的 53 位，56是 <em>N</em> 的唯一可选值。 <em>J</em> 的最佳可用值是下面计算出的范围：</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">q</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="mf">2</span><span class="o">**</span><span class="mf">56</span><span class="p">,</span> <span class="mf">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span>
<span class="go">6L</span>
</pre></div>
<p>Since the remainder is more than half of 10, the best approximation is obtained
by rounding up</p>
<p>因为余数大于10，最好的逼近方法是由上界逼近 ：</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">q</span><span class="o">+</span><span class="mf">1</span>
<span class="go">7205759403792794L</span>
</pre></div>
<p>Therefore the best possible approximation to 1/10 in 754 double precision is
that over 2**56, or</p>
<p>因此 1/10 在 754 双精度下最接近的是它比 2**56 ，即：</p>
<div class="highlight"><pre><span class="mi">7205759403792794</span> <span class="o">/</span> <span class="mi">72057594037927936</span>
</pre></div>
<p>Note that since we rounded up, this is actually a little bit larger than 1/10;
if we had not rounded up, the quotient would have been a little bit smaller than
1/10.  But in no case can it be <em>exactly</em> 1/10!</p>
<p>注意，因为这里我们取上界，所以它实际上比 1/10 大一点点。如果我们取下界，就会比
1/10 小一点。不过它不会 <em>恰好</em> 是 1/10 ！</p>
<p>So the computer never &#8220;sees&#8221; 1/10:  what it sees is the exact fraction given
above, the best 754 double approximation it can get</p>
<p>所以计算机无法“理解” 1/10：它理解收到的分数，给出它所能得到的最佳精度：</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="o">.</span><span class="mf">1</span> <span class="o">*</span> <span class="mf">2</span><span class="o">**</span><span class="mf">56</span>
<span class="go">7205759403792794.0</span>
</pre></div>
<p>If we multiply that fraction by 10**30, we can see the (truncated) value of
its 30 most significant decimal digits</p>
<p>如果我们将这个分数乘 10**30，我们可以看到（被截断）的30位十进制有效数字：</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="mf">7205759403792794</span> <span class="o">*</span> <span class="mf">10</span><span class="o">**</span><span class="mf">30</span> <span class="o">/</span> <span class="mf">2</span><span class="o">**</span><span class="mf">56</span>
<span class="go">100000000000000005551115123125L</span>
</pre></div>
<p>meaning that the exact number stored in the computer is approximately equal to
the decimal value 0.100000000000000005551115123125.  Rounding that to 17
significant digits gives the 0.10000000000000001 that Python displays (well,
will display on any 754-conforming platform that does best-possible input and
output conversions in its C library &#8212; yours may not!).</p>
<p>这意味着保存在计算机中的精确数值约等于十进制值 0.100000000000000005551115123125
。接近于Python显示的17位 0.10000000000000001（哦，在任何符合754的平台上通过其 C
库最可能出现的转入转入结果最有可能就是这样了，你的环境可能不太一样！）。</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <h3><a href="../contents.html">Table Of Contents</a></h3>
            <ul>
<li><a class="reference external" href="">Floating Point Arithmetic:  Issues and Limitations 浮点运算: 问题和限制</a><ul>
<li><a class="reference external" href="#representation-error">Representation Error 表示错误</a></li>
</ul>
</li>
</ul>

            <h4>Previous topic</h4>
            <p class="topless"><a href="interactive.html" title="previous chapter">Interactive Input Editing and History Substitution</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="../using/index.html" title="next chapter">Using Python</a></p>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="../_sources/tutorial/floatingpoint.txt">Show Source</a></li>
            </ul>
          <h3>Quick search</h3>
            <form class="search" action="../search.html" method="get">
              <input type="text" name="q" size="18" /> <input type="submit" value="Go" />
              <input type="hidden" name="check_keywords" value="yes" />
              <input type="hidden" name="area" value="default" />
            </form>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../modindex.html" title="Global Module Index"
             accesskey="M">modules</a> |</li>
        <li class="right" >
          <a href="../using/index.html" title="Using Python"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="interactive.html" title="Interactive Input Editing and History Substitution"
             accesskey="P">previous</a> |</li>
<li><img src="../_static/py.png" alt="" style="vertical-align: middle; margin-top: -1px"/></li>

        <li><a href="../contents.html">Python v3.0c1 documentation</a> &raquo;</li>

          <li><a href="index.html" accesskey="U">The Python tutorial Python 入门指南</a> &raquo;</li>
      </ul>
    </div>
    <div class="footer">
      &copy; <a href="../copyright.html">Copyright</a> 1990-2008, Python Software Foundation.
      Last updated on Oct 31, 2008.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 0.5.
    </div>
  </body>
</html>