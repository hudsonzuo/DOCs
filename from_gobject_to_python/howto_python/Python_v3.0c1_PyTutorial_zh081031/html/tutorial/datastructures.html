<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Data Structures 数据结构 &mdash; Python v3.0c1 documentation</title>
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
          URL_ROOT:    '../',
          VERSION:     '3.0c1',
          COLLAPSE_MODINDEX: false,
          FILE_SUFFIX: '.html'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Python v3.0c1 documentation"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="Python v3.0c1 documentation" href="../index.html" />
    <link rel="up" title="The Python tutorial Python 入门指南" href="index.html" />
    <link rel="next" title="Modules 模块" href="modules.html" />
    <link rel="prev" title="More Control Flow Tools 深入流程控制" href="controlflow.html" />
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../modindex.html" title="Global Module Index"
             accesskey="M">modules</a> |</li>
        <li class="right" >
          <a href="modules.html" title="Modules 模块"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="controlflow.html" title="More Control Flow Tools 深入流程控制"
             accesskey="P">previous</a> |</li>
<li><img src="../_static/py.png" alt="" style="vertical-align: middle; margin-top: -1px"/></li>

        <li><a href="../contents.html">Python v3.0c1 documentation</a> &raquo;</li>

          <li><a href="index.html" accesskey="U">The Python tutorial Python 入门指南</a> &raquo;</li>
      </ul>
    </div>
    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  
  <div class="section" id="data-structures">
<span id="tut-structures"></span><h1>Data Structures 数据结构<a class="headerlink" href="#data-structures" title="Permalink to this headline">¶</a></h1>
<p>This chapter describes some things you&#8217;ve learned about already in more detail,
and adds some new things as well.</p>
<p>本章深入讲述一些你已经学习过的东西，并且还加入了新的内容。</p>
<div class="section" id="tuples-and-sequences">
<span id="tut-tuples"></span><h2>Tuples and Sequences 元组和序列<a class="headerlink" href="#tuples-and-sequences" title="Permalink to this headline">¶</a></h2>
<p>We saw that lists and strings have many common properties, such as indexing and
slicing operations.  They are two examples of <em>sequence</em> data types (see
<a class="reference external" href="../library/stdtypes.html#typesseq"><em>Sequence Types &#8212; str, bytes, bytearray, list, tuple, range</em></a>).  Since Python is an evolving language, other sequence data
types may be added.  There is also another standard sequence data type: the
<em>tuple</em>.</p>
<p>我们知道列表和字符串有很多通用的属性，例如索引和切割操作。它们是序列类型中的两种（参见
<a class="reference external" href="../library/stdtypes.html#typesseq"><em>Sequence Types &#8212; str, bytes, bytearray, list, tuple, range</em></a> ）。困为 Python 是一个在不断进化的语言，也可能会加入其它的序列类型。
这里我们介绍另一个标准序列类型： <em>tuple （元组）</em> 。</p>
<p>A tuple consists of a number of values separated by commas, for instance:</p>
<p>元组由若干逗号分隔的值组成，例如：</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="mf">12345</span><span class="p">,</span> <span class="mf">54321</span><span class="p">,</span> <span class="s">&#39;hello!&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span>
<span class="go">12345</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span>
<span class="go">(12345, 54321, &#39;hello!&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Tuples may be nested:</span>
<span class="gp">... </span><span class="n">u</span> <span class="o">=</span> <span class="n">t</span><span class="p">,</span> <span class="p">(</span><span class="mf">1</span><span class="p">,</span> <span class="mf">2</span><span class="p">,</span> <span class="mf">3</span><span class="p">,</span> <span class="mf">4</span><span class="p">,</span> <span class="mf">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">u</span>
<span class="go">((12345, 54321, &#39;hello!&#39;), (1, 2, 3, 4, 5))</span>
</pre></div>
<p>As you see, on output tuples are always enclosed in parentheses, so that nested
tuples are interpreted correctly; they may be input with or without surrounding
parentheses, although often parentheses are necessary anyway (if the tuple is
part of a larger expression).</p>
<p>如你所见，元组在输出时总是有括号的，以便于正确表达嵌套结构。在输入时可能有或没有括号， 不过括
号通常是必须的（如果元组是更大的表达式的一部分）。</p>
<p>Tuples have many uses.  For example: (x, y) coordinate pairs, employee records
from a database, etc.  Tuples, like strings, are immutable: it is not possible
to assign to the individual items of a tuple (you can simulate much of the same
effect with slicing and concatenation, though).  It is also possible to create
tuples which contain mutable objects, such as lists.</p>
<p>元组有很多用途。例如(x, y)坐标点，数据库中的员工记录等等。元组就像字符串，不可改变：不能给
元组的一个独立的元素赋值（尽管你可以通过联接和切片来模仿）。也可以通过包含可变对象来创建元组，
例如链表。</p>
<p>A special problem is the construction of tuples containing 0 or 1 items: the
syntax has some extra quirks to accommodate these.  Empty tuples are constructed
by an empty pair of parentheses; a tuple with one item is constructed by
following a value with a comma (it is not sufficient to enclose a single value
in parentheses). Ugly, but effective.  For example:</p>
<p>一个特殊的问题是构造包含零个或一个元素的元组：为了适应这种情况，语法上有一些额外的改变。
一对空的括号可以创建空元组；要创建一个单元素元组可以在值后面跟一个逗号（在括号中放入一
个单值是不够的）。丑陋，但是有效。例如：</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">empty</span> <span class="o">=</span> <span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">singleton</span> <span class="o">=</span> <span class="s">&#39;hello&#39;</span><span class="p">,</span>    <span class="c"># &lt;-- note trailing comma</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">empty</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">singleton</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">singleton</span>
<span class="go">(&#39;hello&#39;,)</span>
</pre></div>
<p>The statement <tt class="docutils literal"><span class="pre">t</span> <span class="pre">=</span> <span class="pre">12345,</span> <span class="pre">54321,</span> <span class="pre">'hello!'</span></tt> is an example of <em>tuple packing</em>:
the values <tt class="docutils literal"><span class="pre">12345</span></tt>, <tt class="docutils literal"><span class="pre">54321</span></tt> and <tt class="docutils literal"><span class="pre">'hello!'</span></tt> are packed together in a tuple.
The reverse operation is also possible:</p>
<p>语句 t = 12345, 54321, &#8216;hello!&#8217; 是元组封装（sequence packing）的一个例子：
值 12345， 54321 和 &#8216;hello!&#8217; 被封装进元组。其逆操作可能是这样：</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">t</span>
</pre></div>
<p>This is called, appropriately enough, <em>sequence unpacking</em>. Sequence unpacking
requires the list of variables on the left to have the same number of elements
as the length of the sequence.  Note that multiple assignment is really just a
combination of tuple packing and sequence unpacking!</p>
<p>称其为序列拆封非常合适。序列拆封要求左侧的变量数目与序列的元素个数相同。要注意的是可变参数
（multiple assignment ）其实只是元组封装和序列拆封的一个结合！</p>
<p>There is a small bit of asymmetry here:  packing multiple values always creates
a tuple, and unpacking works for any sequence.</p>
<p>这里有一点不对称：封装多重参数通常会创建一个元组，而拆封操作可以作用于任何序列。</p>
</div>
<div class="section" id="more-on-lists">
<span id="tut-morelists"></span><h2>More on Lists 深入链表<a class="headerlink" href="#more-on-lists" title="Permalink to this headline">¶</a></h2>
<p>The list data type has some more methods.  Here are all of the methods of list
objects:</p>
<p>链表类型有很多方法，这里是链表类型的所有方法：</p>
<dl class="method">
<dt id="list.append">
<!--[list.append]--><tt class="descclassname">list.</tt><tt class="descname">append</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#list.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an item to the end of the list; equivalent to <tt class="docutils literal"><span class="pre">a[len(a):]</span> <span class="pre">=</span> <span class="pre">[x]</span></tt>.</p>
<p>把一个元素添加到链表的结尾，相当于 a[len(a):] = [x]。</p>
</dd></dl>

<dl class="method">
<dt id="list.extend">
<!--[list.extend]--><tt class="descclassname">list.</tt><tt class="descname">extend</tt><big>(</big><em>L</em><big>)</big><a class="headerlink" href="#list.extend" title="Permalink to this definition">¶</a></dt>
<dd><p>Extend the list by appending all the items in the given list; equivalent to
<tt class="docutils literal"><span class="pre">a[len(a):]</span> <span class="pre">=</span> <span class="pre">L</span></tt>.</p>
<p>通过添加指定链表的所有元素来扩充链表，相当于 a[len(a):] = L。</p>
</dd></dl>

<dl class="method">
<dt id="list.insert">
<!--[list.insert]--><tt class="descclassname">list.</tt><tt class="descname">insert</tt><big>(</big><em>i</em>, <em>x</em><big>)</big><a class="headerlink" href="#list.insert" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert an item at a given position.  The first argument is the index of the
element before which to insert, so <tt class="docutils literal"><span class="pre">a.insert(0,</span> <span class="pre">x)</span></tt> inserts at the front of
the list, and <tt class="docutils literal"><span class="pre">a.insert(len(a),</span> <span class="pre">x)</span></tt> is equivalent to <tt class="docutils literal"><span class="pre">a.append(x)</span></tt>.</p>
<p>在指定位置插入一个元素。第一个参数是准备插入到其前面的那个元素的索引，例如</p>
</dd></dl>

<p><tt class="docutils literal"><span class="pre">a.insert(0,</span> <span class="pre">x)</span></tt> 会插入到整个链表之前，而 <tt class="docutils literal"><span class="pre">a.insert(len(a),</span> <span class="pre">x)</span></tt>
相当于 <tt class="docutils literal"><span class="pre">a.append(x)</span></tt> 。</p>
<dl class="method">
<dt id="list.remove">
<!--[list.remove]--><tt class="descclassname">list.</tt><tt class="descname">remove</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#list.remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the first item from the list whose value is <em>x</em>. It is an error if there
is no such item.</p>
<p>删除链表中值为 <em>x</em> 的第一个元素。如果没有这样的元素，就会返回一个错误。</p>
</dd></dl>

<dl class="method">
<dt id="list.pop">
<!--[list.pop]--><tt class="descclassname">list.</tt><tt class="descname">pop</tt><big>(</big><span class="optional">[</span><em>i</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#list.pop" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the item at the given position in the list, and return it.  If no index
is specified, <tt class="docutils literal"><span class="pre">a.pop()</span></tt> removes and returns the last item in the list.  (The
square brackets around the <em>i</em> in the method signature denote that the parameter
is optional, not that you should type square brackets at that position.  You
will see this notation frequently in the Python Library Reference.)</p>
<p>从链表的指定位置删除元素，并将其返回。如果没有指定索引，``a.pop()`` 返回最后一个元素。</p>
</dd></dl>

<p>元素随即从链表中被删除。（方法中 <em>i</em> 两边的方括号表示这个参数是可选的，而不是要求你输入一
对方括号，你会经常在Python 库参考手册中遇到这样的标记。）</p>
<dl class="method">
<dt id="list.index">
<!--[list.index]--><tt class="descclassname">list.</tt><tt class="descname">index</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#list.index" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index in the list of the first item whose value is <em>x</em>. It is an
error if there is no such item.</p>
<p>返回链表中第一个值为 <em>x</em> 的元素的索引。如果没有匹配的元素就会返回一个错误。</p>
</dd></dl>

<dl class="method">
<dt id="list.count">
<!--[list.count]--><tt class="descclassname">list.</tt><tt class="descname">count</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#list.count" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of times <em>x</em> appears in the list.</p>
<p>返回 <em>x</em> 在链表中出现的次数。</p>
</dd></dl>

<dl class="method">
<dt id="list.sort">
<!--[list.sort]--><tt class="descclassname">list.</tt><tt class="descname">sort</tt><big>(</big><big>)</big><a class="headerlink" href="#list.sort" title="Permalink to this definition">¶</a></dt>
<dd><p>Sort the items of the list, in place.</p>
<p>对链表中的元素进行“就地”排序。</p>
</dd></dl>

<dl class="method">
<dt id="list.reverse">
<!--[list.reverse]--><tt class="descclassname">list.</tt><tt class="descname">reverse</tt><big>(</big><big>)</big><a class="headerlink" href="#list.reverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverse the elements of the list, in place.</p>
<p>“就地”倒排链表中的元素。</p>
</dd></dl>

<p>An example that uses most of the list methods:</p>
<p>下面这个示例演示了链表的大部分方法：</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mf">66.25</span><span class="p">,</span> <span class="mf">333</span><span class="p">,</span> <span class="mf">333</span><span class="p">,</span> <span class="mf">1</span><span class="p">,</span> <span class="mf">1234.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="mf">333</span><span class="p">),</span> <span class="n">a</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="mf">66.25</span><span class="p">),</span> <span class="n">a</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">))</span>
<span class="go">2 1 0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mf">2</span><span class="p">,</span> <span class="o">-</span><span class="mf">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">333</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">[66.25, 333, -1, 333, 1, 1234.5, 333]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="mf">333</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="mf">333</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">[66.25, -1, 333, 1, 1234.5, 333]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">[333, 1234.5, 1, 333, -1, 66.25]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">[-1, 1, 66.25, 333, 333, 1234.5]</span>
</pre></div>
<div class="section" id="using-lists-as-stacks">
<span id="tut-lists-as-stacks"></span><h3>Using Lists as Stacks 将列表当做堆栈使用<a class="headerlink" href="#using-lists-as-stacks" title="Permalink to this headline">¶</a></h3>
<p>The list methods make it very easy to use a list as a stack, where the last
element added is the first element retrieved (&#8220;last-in, first-out&#8221;).  To add an
item to the top of the stack, use <tt class="xref docutils literal"><span class="pre">append()</span></tt>.  To retrieve an item from the
top of the stack, use <tt class="xref docutils literal"><span class="pre">pop()</span></tt> without an explicit index.  For example:</p>
<p>链表方法使得链表可以很方便的做为一个堆栈来使用，堆栈作为特定的数据结构，最先进入的元素最后一个被释放（后进先出）。用 <tt class="xref docutils literal"><span class="pre">append()</span></tt> 方法可以把一个元素添加到堆栈顶。用不指定索引的 <tt class="xref docutils literal"><span class="pre">pop()</span></tt> 方法可以把一个元素从堆栈顶释放出来。例如：</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="mf">3</span><span class="p">,</span> <span class="mf">4</span><span class="p">,</span> <span class="mf">5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">7</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stack</span>
<span class="go">[3, 4, 5, 6, 7]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
<span class="go">7</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stack</span>
<span class="go">[3, 4, 5, 6]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
<span class="go">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stack</span>
<span class="go">[3, 4]</span>
</pre></div>
</div>
<div class="section" id="using-lists-as-queues">
<span id="tut-lists-as-queues"></span><h3>Using Lists as Queues 将列表当作队列使用<a class="headerlink" href="#using-lists-as-queues" title="Permalink to this headline">¶</a></h3>
<p>You can also use a list conveniently as a queue, where the first element added
is the first element retrieved (&#8220;first-in, first-out&#8221;).  To add an item to the
back of the queue, use <tt class="xref docutils literal"><span class="pre">append()</span></tt>.  To retrieve an item from the front of
the queue, use <tt class="xref docutils literal"><span class="pre">pop()</span></tt> with <tt class="docutils literal"><span class="pre">0</span></tt> as the index.  For example:</p>
<p>你也可以把链表当做队列使用，队列作为特定的数据结构，最先进入的元素最先释放（先进先出）。
使用 append()方法可以把元素添加到队列最后，以0为参数调用 pop() 方法可以把最先进入的
元素释放出来。例如：</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">queue</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;Eric&quot;</span><span class="p">,</span> <span class="s">&quot;John&quot;</span><span class="p">,</span> <span class="s">&quot;Michael&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot;Terry&quot;</span><span class="p">)</span>           <span class="c"># Terry arrives</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot;Graham&quot;</span><span class="p">)</span>          <span class="c"># Graham arrives</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">queue</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mf">0</span><span class="p">)</span>
<span class="go">&#39;Eric&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">queue</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mf">0</span><span class="p">)</span>
<span class="go">&#39;John&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">queue</span>
<span class="go">[&#39;Michael&#39;, &#39;Terry&#39;, &#39;Graham&#39;]</span>
</pre></div>
</div>
<div class="section" id="list-comprehensions">
<h3>List Comprehensions 列表推导式<a class="headerlink" href="#list-comprehensions" title="Permalink to this headline">¶</a></h3>
<p>List comprehensions provide a concise way to create lists from sequences.
Common applications are to make lists where each element is the result of
some operations applied to each member of the sequence, or to create a
subsequence of those elements that satisfy a certain condition.</p>
<p>列表推导式提供了从序列创建列表的简单途径。通常应用程序将一些操作应用于某个序列的每个元素，
用其获得的结果作为生成新列表的元素，或者根据确定的判定条件创建子序列。</p>
<p>Each list comprehension consists of an expression followed by a <a class="reference external" href="../reference/compound_stmts.html#for"><tt class="xref docutils literal"><span class="pre">for</span></tt></a>
clause, then zero or more <a class="reference external" href="../reference/compound_stmts.html#for"><tt class="xref docutils literal"><span class="pre">for</span></tt></a> or <a class="reference external" href="../reference/compound_stmts.html#if"><tt class="xref docutils literal"><span class="pre">if</span></tt></a> clauses.  The result
will be a list resulting from evaluating the expression in the context of the
<a class="reference external" href="../reference/compound_stmts.html#for"><tt class="xref docutils literal"><span class="pre">for</span></tt></a> and <a class="reference external" href="../reference/compound_stmts.html#if"><tt class="xref docutils literal"><span class="pre">if</span></tt></a> clauses which follow it.  If the expression
would evaluate to a tuple, it must be parenthesized.</p>
<p>每个列表推导式都在 <a class="reference external" href="../reference/compound_stmts.html#for"><tt class="xref docutils literal"><span class="pre">for</span></tt></a> 之后跟一个表达式，然后有零到多个 <a class="reference external" href="../reference/compound_stmts.html#for"><tt class="xref docutils literal"><span class="pre">for</span></tt></a>
或 <a class="reference external" href="../reference/compound_stmts.html#if"><tt class="xref docutils literal"><span class="pre">if</span></tt></a> 子句。返回结果是一个根据表达从其后的 <a class="reference external" href="../reference/compound_stmts.html#for"><tt class="xref docutils literal"><span class="pre">for</span></tt></a> 和 <a class="reference external" href="../reference/compound_stmts.html#if"><tt class="xref docutils literal"><span class="pre">if</span></tt></a>
上下文环境中生成出来的列表。如果希望表达式推导出一个元组，就必须使用括号。</p>
<p>Here we take a list of numbers and return a list of three times each number:</p>
<p>这里我们将列表中每个数值乘三，获得一个新的列表：</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">vec</span> <span class="o">=</span> <span class="p">[</span><span class="mf">2</span><span class="p">,</span> <span class="mf">4</span><span class="p">,</span> <span class="mf">6</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="mf">3</span><span class="o">*</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">vec</span><span class="p">]</span>
<span class="go">[6, 12, 18]</span>
</pre></div>
<p>Now we get a little fancier:</p>
<p>现在我们玩一点小花样：</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="p">[[</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">**</span><span class="mf">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">vec</span><span class="p">]</span>
<span class="go">[[2, 4], [4, 16], [6, 36]]</span>
</pre></div>
<p>Here we apply a method call to each item in a sequence:</p>
<p>这里我们对序列里每一个元素逐个调用某方法：</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">freshfruit</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;  banana&#39;</span><span class="p">,</span> <span class="s">&#39;  loganberry &#39;</span><span class="p">,</span> <span class="s">&#39;passion fruit  &#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">weapon</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">weapon</span> <span class="ow">in</span> <span class="n">freshfruit</span><span class="p">]</span>
<span class="go">[&#39;banana&#39;, &#39;loganberry&#39;, &#39;passion fruit&#39;]</span>
</pre></div>
<p>Using the <a class="reference external" href="../reference/compound_stmts.html#if"><tt class="xref docutils literal"><span class="pre">if</span></tt></a> clause we can filter the stream:</p>
<p>我们可以用 :keyword`if` 子句作为过滤器：</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="mf">3</span><span class="o">*</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">vec</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mf">3</span><span class="p">]</span>
<span class="go">[12, 18]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="mf">3</span><span class="o">*</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">vec</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mf">2</span><span class="p">]</span>
<span class="go">[]</span>
</pre></div>
<p>Tuples can often be created without their parentheses, but not here:</p>
<p>元组经常可以不使用括号就创建出来，不过这里不行：</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">**</span><span class="mf">2</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">vec</span><span class="p">]</span>   <span class="c"># error - parens required for tuples</span>
<span class="go">  File &quot;&lt;stdin&gt;&quot;, line 1, in ?</span>
<span class="go">    [x, x**2 for x in vec]</span>
<span class="go">               ^</span>
<span class="go">SyntaxError: invalid syntax</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">**</span><span class="mf">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">vec</span><span class="p">]</span>
<span class="go">[(2, 4), (4, 16), (6, 36)]</span>
</pre></div>
<p>Here are some nested for loops and other fancy behavior:</p>
<p>这里有一些关于循环和其它技巧的演示：</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">vec1</span> <span class="o">=</span> <span class="p">[</span><span class="mf">2</span><span class="p">,</span> <span class="mf">4</span><span class="p">,</span> <span class="mf">6</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vec2</span> <span class="o">=</span> <span class="p">[</span><span class="mf">4</span><span class="p">,</span> <span class="mf">3</span><span class="p">,</span> <span class="o">-</span><span class="mf">9</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">vec1</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">vec2</span><span class="p">]</span>
<span class="go">[8, 6, -18, 16, 12, -36, 24, 18, -54]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">x</span><span class="o">+</span><span class="n">y</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">vec1</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">vec2</span><span class="p">]</span>
<span class="go">[6, 5, -7, 8, 7, -5, 10, 9, -3]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">vec1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">vec2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vec1</span><span class="p">))]</span>
<span class="go">[8, 12, -54]</span>
</pre></div>
<p>List comprehensions can be applied to complex expressions and nested functions:</p>
<p>链表推导式可以使用复杂表达式或嵌套函数：</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="mf">355</span><span class="o">/</span><span class="mf">113.0</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mf">1</span><span class="p">,</span> <span class="mf">6</span><span class="p">)]</span>
<span class="go">[&#39;3.1&#39;, &#39;3.14&#39;, &#39;3.142&#39;, &#39;3.1416&#39;, &#39;3.14159&#39;]</span>
</pre></div>
</div>
</div>
<div class="section" id="the-del-statement-del">
<span id="tut-del"></span><h2>The <a class="reference external" href="../reference/simple_stmts.html#del"><tt class="xref docutils literal"><span class="pre">del</span></tt></a> statement <a class="reference external" href="../reference/simple_stmts.html#del"><tt class="xref docutils literal"><span class="pre">del</span></tt></a> 语句<a class="headerlink" href="#the-del-statement-del" title="Permalink to this headline">¶</a></h2>
<p>There is a way to remove an item from a list given its index instead of its
value: the <a class="reference external" href="../reference/simple_stmts.html#del"><tt class="xref docutils literal"><span class="pre">del</span></tt></a> statement.  This differs from the <tt class="xref docutils literal"><span class="pre">pop()</span></tt> method
which returns a value.  The <a class="reference external" href="../reference/simple_stmts.html#del"><tt class="xref docutils literal"><span class="pre">del</span></tt></a> statement can also be used to remove
slices from a list or clear the entire list (which we did earlier by assignment
of an empty list to the slice).  For example:</p>
<p>使用 <a class="reference external" href="../reference/simple_stmts.html#del"><tt class="xref docutils literal"><span class="pre">del</span></tt></a> 语句可以从一个列表中依索引而不是值来删除一个元素。这与使用 <tt class="xref docutils literal"><span class="pre">pop()</span></tt>
返回一个值不同。可以用 <a class="reference external" href="../reference/simple_stmts.html#del"><tt class="xref docutils literal"><span class="pre">del</span></tt></a> 语句从列表中删除一个切割，或清空整个列表（我们以前介绍
的方法是给该切割赋一个空列表）。例如：</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">1</span><span class="p">,</span> <span class="mf">1</span><span class="p">,</span> <span class="mf">66.25</span><span class="p">,</span> <span class="mf">333</span><span class="p">,</span> <span class="mf">333</span><span class="p">,</span> <span class="mf">1234.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">a</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">[1, 66.25, 333, 333, 1234.5]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">a</span><span class="p">[</span><span class="mf">2</span><span class="p">:</span><span class="mf">4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">[1, 66.25, 1234.5]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">a</span><span class="p">[:]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">[]</span>
</pre></div>
<p><a class="reference external" href="../reference/simple_stmts.html#del"><tt class="xref docutils literal"><span class="pre">del</span></tt></a> can also be used to delete entire variables:</p>
<p>也可以用 <a class="reference external" href="../reference/simple_stmts.html#del"><tt class="xref docutils literal"><span class="pre">del</span></tt></a> 删除实体变量：</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">a</span>
</pre></div>
<p>Referencing the name <tt class="docutils literal"><span class="pre">a</span></tt> hereafter is an error (at least until another value
is assigned to it).  We&#8217;ll find other uses for <a class="reference external" href="../reference/simple_stmts.html#del"><tt class="xref docutils literal"><span class="pre">del</span></tt></a> later.</p>
<p>此后引用 <tt class="docutils literal"><span class="pre">a</span></tt> 命名就是一个错误（至少在另一个值赋给它之前）。我们会在后面找到 <a class="reference external" href="../reference/simple_stmts.html#del"><tt class="xref docutils literal"><span class="pre">del</span></tt></a>
的其它用途。</p>
</div>
<div class="section" id="sets">
<span id="tut-sets"></span><h2>Sets 集合<a class="headerlink" href="#sets" title="Permalink to this headline">¶</a></h2>
<p>Python also includes a data type for <em>sets</em>.  A set is an unordered collection
with no duplicate elements.  Basic uses include membership testing and
eliminating duplicate entries.  Set objects also support mathematical operations
like union, intersection, difference, and symmetric difference.</p>
<p>Python 还包含了一个数据类型—— set（集合）。集合是一个无序不重复元素的集。基本功能包括关系测
试和消除重复元素。集合对象还支持 union（联合），intersection（交），difference（差）和
sysmmetric difference（对称差集）等数学运算。</p>
<p>Curly braces or the <a title="set" class="reference external" href="../library/stdtypes.html#set"><tt class="xref docutils literal"><span class="pre">set()</span></tt></a> function can be use to create sets. Note:
To create an empty set you have to use set(), not {}; the latter creates
an empty dictionary, a data structure that we discuss in the next section.</p>
<p>大括号可以用于创建集合。注意：如果要创建一个空集合，你必须用 set() 而不是 {} ；后者创建一个
空的字典，下一节我们会介绍这个数据结构。</p>
<p>Here is a brief demonstration:</p>
<p>以下是一个简单的演示：</p>
<blockquote>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">basket</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;apple&#39;</span><span class="p">,</span> <span class="s">&#39;orange&#39;</span><span class="p">,</span> <span class="s">&#39;apple&#39;</span><span class="p">,</span> <span class="s">&#39;pear&#39;</span><span class="p">,</span> <span class="s">&#39;orange&#39;</span><span class="p">,</span> <span class="s">&#39;banana&#39;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">basket</span><span class="p">)</span>
<span class="go">{&#39;orange&#39;, &#39;bananna&#39;, &#39;pear&#39;, &#39;apple&#39;}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fruit</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;apple&#39;</span><span class="p">,</span> <span class="s">&#39;orange&#39;</span><span class="p">,</span> <span class="s">&#39;apple&#39;</span><span class="p">,</span> <span class="s">&#39;pear&#39;</span><span class="p">,</span> <span class="s">&#39;orange&#39;</span><span class="p">,</span> <span class="s">&#39;banana&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fruit</span> <span class="o">=</span> <span class="n">set</span><span class="p">(</span><span class="n">basket</span><span class="p">)</span>               <span class="c"># create a set without duplicates</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fruit</span>
<span class="go">{&#39;orange&#39;, &#39;pear&#39;, &#39;apple&#39;, &#39;banana&#39;}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s">&#39;orange&#39;</span> <span class="ow">in</span> <span class="n">fruit</span>                 <span class="c"># fast membership testing</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s">&#39;crabgrass&#39;</span> <span class="ow">in</span> <span class="n">fruit</span>
<span class="go">False</span>
</pre></div>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># Demonstrate set operations on unique letters from two words</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">set</span><span class="p">(</span><span class="s">&#39;abracadabra&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">set</span><span class="p">(</span><span class="s">&#39;alacazam&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>                                  <span class="c"># unique letters in a</span>
<span class="go">{&#39;a&#39;, &#39;r&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">-</span> <span class="n">b</span>                              <span class="c"># letters in a but not in b</span>
<span class="go">{&#39;r&#39;, &#39;d&#39;, &#39;b&#39;}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">|</span> <span class="n">b</span>                              <span class="c"># letters in either a or b</span>
<span class="go">{&#39;a&#39;, &#39;c&#39;, &#39;r&#39;, &#39;d&#39;, &#39;b&#39;, &#39;m&#39;, &#39;z&#39;, &#39;l&#39;}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">&amp;</span> <span class="n">b</span>                              <span class="c"># letters in both a and b</span>
<span class="go">{&#39;a&#39;, &#39;c&#39;}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">^</span> <span class="n">b</span>                              <span class="c"># letters in a or b but not both</span>
<span class="go">{&#39;r&#39;, &#39;d&#39;, &#39;b&#39;, &#39;m&#39;, &#39;z&#39;, &#39;l&#39;}</span>
</pre></div>
</blockquote>
</div>
<div class="section" id="dictionaries">
<span id="tut-dictionaries"></span><h2>Dictionaries 字典<a class="headerlink" href="#dictionaries" title="Permalink to this headline">¶</a></h2>
<p>Another useful data type built into Python is the <em>dictionary</em> (see
<a class="reference external" href="../library/stdtypes.html#typesmapping"><em>Mapping Types &#8212; dict</em></a>). Dictionaries are sometimes found in other languages as
&#8220;associative memories&#8221; or &#8220;associative arrays&#8221;.  Unlike sequences, which are
indexed by a range of numbers, dictionaries are indexed by <em>keys</em>, which can be
any immutable type; strings and numbers can always be keys.  Tuples can be used
as keys if they contain only strings, numbers, or tuples; if a tuple contains
any mutable object either directly or indirectly, it cannot be used as a key.
You can&#8217;t use lists as keys, since lists can be modified in place using index
assignments, slice assignments, or methods like <tt class="xref docutils literal"><span class="pre">append()</span></tt> and
<tt class="xref docutils literal"><span class="pre">extend()</span></tt>.</p>
<p>另一个非常有用的 Python 内建数据类型是*字典*（参见 :ref:<a href="#id1"><span class="problematic" id="id2">`</span></a>typesmapping`）。字典在某些语言
中可能称为“关联存储”（``associative memories&#8217;&#8216;）或“关联数组”（``associative arrays&#8217;&#8216;）。
序列是以连续的整数为索引，与此不同的是，字典以*关键字*为索引，关键字可以是任意不可变类型，通常用
字符串或数值。如果元组中只包含字符串、数字和元组，它可以做为关键字，如果它直接或间接的包含了可变
对象，就不能当做关键字。不能用链表做关键字，因为链表可以用索引、切割或者 append() 和 extend()
等方法改变。</p>
<p>It is best to think of a dictionary as an unordered set of <em>key: value</em> pairs,
with the requirement that the keys are unique (within one dictionary). A pair of
braces creates an empty dictionary: <tt class="docutils literal"><span class="pre">{}</span></tt>. Placing a comma-separated list of
key:value pairs within the braces adds initial key:value pairs to the
dictionary; this is also the way dictionaries are written on output.</p>
<p>理解字典的最佳方式是把它看做无序的*键：值*对集合，关键字必须是互不相同的（在同一个字典之内）。
一对大括号创建一个空的字典：``{}``。初始化链表时，在大括号内放置一组逗号分隔的关键字：值对，
这也是字典输出的方式。</p>
<p>The main operations on a dictionary are storing a value with some key and
extracting the value given the key.  It is also possible to delete a key:value
pair with <tt class="docutils literal"><span class="pre">del</span></tt>. If you store using a key that is already in use, the old
value associated with that key is forgotten.  It is an error to extract a value
using a non-existent key.</p>
<p>字典的主要操作是依据关键字来存储和析取值。也可以用 <tt class="docutils literal"><span class="pre">del</span></tt> 来删除键：值对。如果你用一个已经存
在的关键字存储值，以前为该关键字分配的值就会被遗忘。试图从一个不存在的关键字中读取值会导致错误。</p>
<p>The <tt class="xref docutils literal"><span class="pre">keys()</span></tt> method of a dictionary object returns a list of all the keys
used in the dictionary, in arbitrary order (if you want it sorted, just apply
the <tt class="xref docutils literal"><span class="pre">sort()</span></tt> method to the list of keys).  To check whether a single key is
in the dictionary, use the <a class="reference external" href="../reference/expressions.html#in"><tt class="xref docutils literal"><span class="pre">in</span></tt></a> keyword.</p>
<p>字典的 <tt class="xref docutils literal"><span class="pre">keys()</span></tt> 方法返回由所有关键字组成的链表，该链表的顺序不定（如果你需要它有序，
只能调用关键字链表的 <tt class="xref docutils literal"><span class="pre">sort()</span></tt> 方法）。使用 <a class="reference external" href="../reference/expressions.html#in"><tt class="xref docutils literal"><span class="pre">in</span></tt></a> 关键字可以检查字典中是
否存在某一关键字。</p>
<p>Here is a small example using a dictionary:</p>
<p>这是一个字典运用的简单例子：</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">tel</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;jack&#39;</span><span class="p">:</span> <span class="mf">4098</span><span class="p">,</span> <span class="s">&#39;sape&#39;</span><span class="p">:</span> <span class="mf">4139</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tel</span><span class="p">[</span><span class="s">&#39;guido&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">4127</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tel</span>
<span class="go">{&#39;sape&#39;: 4139, &#39;guido&#39;: 4127, &#39;jack&#39;: 4098}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tel</span><span class="p">[</span><span class="s">&#39;jack&#39;</span><span class="p">]</span>
<span class="go">4098</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">tel</span><span class="p">[</span><span class="s">&#39;sape&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tel</span><span class="p">[</span><span class="s">&#39;irv&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">4127</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tel</span>
<span class="go">{&#39;guido&#39;: 4127, &#39;irv&#39;: 4127, &#39;jack&#39;: 4098}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">tel</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
<span class="go">[&#39;guido&#39;, &#39;irv&#39;, &#39;jack&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s">&#39;guido&#39;</span> <span class="ow">in</span> <span class="n">tel</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s">&#39;jack&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">tel</span>
<span class="go">False</span>
</pre></div>
<p>The <a title="dict" class="reference external" href="../library/stdtypes.html#dict"><tt class="xref docutils literal"><span class="pre">dict()</span></tt></a> constructor builds dictionaries directly from lists of
key-value pairs stored as tuples.  When the pairs form a pattern, list
comprehensions can compactly specify the key-value list.</p>
<p>构造函数 <a title="dict" class="reference external" href="../library/stdtypes.html#dict"><tt class="xref docutils literal"><span class="pre">dict()</span></tt></a> 直接从键值对元组列表中构建字典。如果有固定的模式，列表推导式指定特定的键值对：</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">dict</span><span class="p">([(</span><span class="s">&#39;sape&#39;</span><span class="p">,</span> <span class="mf">4139</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;guido&#39;</span><span class="p">,</span> <span class="mf">4127</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;jack&#39;</span><span class="p">,</span> <span class="mf">4098</span><span class="p">)])</span>
<span class="go">{&#39;sape&#39;: 4139, &#39;jack&#39;: 4098, &#39;guido&#39;: 4127}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">dict</span><span class="p">([(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">**</span><span class="mf">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">(</span><span class="mf">2</span><span class="p">,</span> <span class="mf">4</span><span class="p">,</span> <span class="mf">6</span><span class="p">)])</span>     <span class="c"># use a list comprehension</span>
<span class="go">{2: 4, 4: 16, 6: 36}</span>
</pre></div>
<p>Later in the tutorial, we will learn about Generator Expressions which are even
better suited for the task of supplying key-values pairs to the <a title="dict" class="reference external" href="../library/stdtypes.html#dict"><tt class="xref docutils literal"><span class="pre">dict()</span></tt></a>
constructor.</p>
<p>在本指南的后面章节，我们会学习到生成器表达式，它更适于为 <a title="dict" class="reference external" href="../library/stdtypes.html#dict"><tt class="xref docutils literal"><span class="pre">dict()</span></tt></a> 构造器生成键值对序列。</p>
<p>When the keys are simple strings, it is sometimes easier to specify pairs using
keyword arguments:</p>
<p>如果关键字只是简单的字符串，使用关键字参数指定键值对有时候更方便：</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">dict</span><span class="p">(</span><span class="n">sape</span><span class="o">=</span><span class="mf">4139</span><span class="p">,</span> <span class="n">guido</span><span class="o">=</span><span class="mf">4127</span><span class="p">,</span> <span class="n">jack</span><span class="o">=</span><span class="mf">4098</span><span class="p">)</span>
<span class="go">{&#39;sape&#39;: 4139, &#39;jack&#39;: 4098, &#39;guido&#39;: 4127}</span>
</pre></div>
<span class="target" id="tut-loopidioms"></span></div>
<div class="section" id="looping-techniques">
<h2>Looping Techniques 遍历技巧<a class="headerlink" href="#looping-techniques" title="Permalink to this headline">¶</a></h2>
<p>When looping through dictionaries, the key and corresponding value can be
retrieved at the same time using the <tt class="xref docutils literal"><span class="pre">items()</span></tt> method.</p>
<p>在字典中遍历时，关键字和对应的值可以使用 <tt class="xref docutils literal"><span class="pre">items()</span></tt> 方法同时解读出来：</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">knights</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;gallahad&#39;</span><span class="p">:</span> <span class="s">&#39;the pure&#39;</span><span class="p">,</span> <span class="s">&#39;robin&#39;</span><span class="p">:</span> <span class="s">&#39;the brave&#39;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">knights</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">gallahad the pure</span>
<span class="go">robin the brave</span>
</pre></div>
<p>When looping through a sequence, the position index and corresponding value can
be retrieved at the same time using the <a title="enumerate" class="reference external" href="../library/functions.html#enumerate"><tt class="xref docutils literal"><span class="pre">enumerate()</span></tt></a> function.</p>
<p>在序列中遍历时，索引位置和对应值可以使用 <a title="enumerate" class="reference external" href="../library/functions.html#enumerate"><tt class="xref docutils literal"><span class="pre">enumerate()</span></tt></a> 函数同时得到：</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="s">&#39;tic&#39;</span><span class="p">,</span> <span class="s">&#39;tac&#39;</span><span class="p">,</span> <span class="s">&#39;toe&#39;</span><span class="p">]):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">0 tic</span>
<span class="go">1 tac</span>
<span class="go">2 toe</span>
</pre></div>
<p>To loop over two or more sequences at the same time, the entries can be paired
with the <a title="zip" class="reference external" href="../library/functions.html#zip"><tt class="xref docutils literal"><span class="pre">zip()</span></tt></a> function.</p>
<p>同时遍历两个或更多的序列，可以使用 <a title="zip" class="reference external" href="../library/functions.html#zip"><tt class="xref docutils literal"><span class="pre">zip()</span></tt></a> 组合：</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">questions</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;name&#39;</span><span class="p">,</span> <span class="s">&#39;quest&#39;</span><span class="p">,</span> <span class="s">&#39;favorite color&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">answers</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;lancelot&#39;</span><span class="p">,</span> <span class="s">&#39;the holy grail&#39;</span><span class="p">,</span> <span class="s">&#39;blue&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">q</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">questions</span><span class="p">,</span> <span class="n">answers</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s">&#39;What is your </span><span class="si">%s</span><span class="s">?  It is </span><span class="si">%s</span><span class="s">.&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">a</span><span class="p">))</span>
<span class="gp">...</span>
<span class="go">What is your name?  It is lancelot.</span>
<span class="go">What is your quest?  It is the holy grail.</span>
<span class="go">What is your favorite color?  It is blue.</span>
</pre></div>
<p>To loop over a sequence in reverse, first specify the sequence in a forward
direction and then call the <a title="reversed" class="reference external" href="../library/functions.html#reversed"><tt class="xref docutils literal"><span class="pre">reversed()</span></tt></a> function.</p>
<p>要反向遍历一个序列，首先指定这个序列，然后调用 <tt class="xref docutils literal"><span class="pre">reversesd()</span></tt> 函数：</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mf">1</span><span class="p">,</span> <span class="mf">10</span><span class="p">,</span> <span class="mf">2</span><span class="p">)):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">9</span>
<span class="go">7</span>
<span class="go">5</span>
<span class="go">3</span>
<span class="go">1</span>
</pre></div>
<p>To loop over a sequence in sorted order, use the <a title="sorted" class="reference external" href="../library/functions.html#sorted"><tt class="xref docutils literal"><span class="pre">sorted()</span></tt></a> function which
returns a new sorted list while leaving the source unaltered.</p>
<p>要按顺序遍历一个序列，使用 <a title="sorted" class="reference external" href="../library/functions.html#sorted"><tt class="xref docutils literal"><span class="pre">sorted()</span></tt></a> 函数返回一个已排序的序列，将原有的放一边：</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">basket</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;apple&#39;</span><span class="p">,</span> <span class="s">&#39;orange&#39;</span><span class="p">,</span> <span class="s">&#39;apple&#39;</span><span class="p">,</span> <span class="s">&#39;pear&#39;</span><span class="p">,</span> <span class="s">&#39;orange&#39;</span><span class="p">,</span> <span class="s">&#39;banana&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">sorted</span><span class="p">(</span><span class="n">set</span><span class="p">(</span><span class="n">basket</span><span class="p">)):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">apple</span>
<span class="go">banana</span>
<span class="go">orange</span>
<span class="go">pear</span>
</pre></div>
</div>
<div class="section" id="more-on-conditions">
<span id="tut-conditions"></span><h2>More on Conditions 深入条件控制<a class="headerlink" href="#more-on-conditions" title="Permalink to this headline">¶</a></h2>
<p>The conditions used in <tt class="docutils literal"><span class="pre">while</span></tt> and <tt class="docutils literal"><span class="pre">if</span></tt> statements can contain any
operators, not just comparisons.</p>
<p>用于 while 和 if 语句的条件包括了比较之外的操作符。</p>
<p>The comparison operators <tt class="docutils literal"><span class="pre">in</span></tt> and <tt class="docutils literal"><span class="pre">not</span> <span class="pre">in</span></tt> check whether a value occurs
(does not occur) in a sequence.  The operators <tt class="docutils literal"><span class="pre">is</span></tt> and <tt class="docutils literal"><span class="pre">is</span> <span class="pre">not</span></tt> compare
whether two objects are really the same object; this only matters for mutable
objects like lists.  All comparison operators have the same priority, which is
lower than that of all numerical operators.</p>
<p>比较操作符 <tt class="docutils literal"><span class="pre">in</span></tt> 和 <tt class="docutils literal"><span class="pre">not</span> <span class="pre">in</span></tt> 审核值是否在一个区间之内。操作符 <tt class="docutils literal"><span class="pre">is</span></tt> 和 <tt class="docutils literal"><span class="pre">is</span> <span class="pre">not</span></tt>
和比较两个对象是否相同；这只和诸如链表这样的可变对象有关。所有的比较操作符具有相同的优先级，低于
所有的数值操作。</p>
<p>Comparisons can be chained.  For example, <tt class="docutils literal"><span class="pre">a</span> <span class="pre">&lt;</span> <span class="pre">b</span> <span class="pre">==</span> <span class="pre">c</span></tt> tests whether <tt class="docutils literal"><span class="pre">a</span></tt> is
less than <tt class="docutils literal"><span class="pre">b</span></tt> and moreover <tt class="docutils literal"><span class="pre">b</span></tt> equals <tt class="docutils literal"><span class="pre">c</span></tt>.</p>
<p>比较操作符可以串联。例如： <tt class="docutils literal"><span class="pre">a</span> <span class="pre">&lt;</span> <span class="pre">b</span> <span class="pre">==</span> <span class="pre">c</span></tt> 测试是否 <tt class="docutils literal"><span class="pre">a</span></tt> 小于 <tt class="docutils literal"><span class="pre">b</span></tt> 并且 <tt class="docutils literal"><span class="pre">b</span></tt> 等于 <a href="#id3"><span class="problematic" id="id4">``</span></a>c``。</p>
<p>Comparisons may be combined using the Boolean operators <tt class="docutils literal"><span class="pre">and</span></tt> and <tt class="docutils literal"><span class="pre">or</span></tt>, and
the outcome of a comparison (or of any other Boolean expression) may be negated
with <tt class="docutils literal"><span class="pre">not</span></tt>.  These have lower priorities than comparison operators; between
them, <tt class="docutils literal"><span class="pre">not</span></tt> has the highest priority and <tt class="docutils literal"><span class="pre">or</span></tt> the lowest, so that <tt class="docutils literal"><span class="pre">A</span> <span class="pre">and</span>
<span class="pre">not</span> <span class="pre">B</span> <span class="pre">or</span> <span class="pre">C</span></tt> is equivalent to <tt class="docutils literal"><span class="pre">(A</span> <span class="pre">and</span> <span class="pre">(not</span> <span class="pre">B))</span> <span class="pre">or</span> <span class="pre">C</span></tt>. As always, parentheses
can be used to express the desired composition.</p>
<p>比较操作（或其它任何逻辑表达式）可以通过逻辑操作符 <tt class="docutils literal"><span class="pre">and</span></tt> 和 <tt class="docutils literal"><span class="pre">or</span></tt> 组合，比较的结果可以用
<tt class="docutils literal"><span class="pre">not</span></tt> 来取反义。这些操作符的优先级又低于比较操作符，在它们之中，``not`` 具有最高的优先级，
<tt class="docutils literal"><span class="pre">or</span></tt> 优先级最低，所以 <tt class="docutils literal"><span class="pre">A</span> <span class="pre">and</span> <span class="pre">not</span> <span class="pre">B</span> <span class="pre">or</span> <span class="pre">C</span></tt> 等于 <tt class="docutils literal"><span class="pre">(A</span> <span class="pre">and</span> <span class="pre">(not</span> <span class="pre">B))</span> <span class="pre">or</span> <span class="pre">C</span></tt> 。当然，
表达式可以用期望的方式表示。</p>
<p>The Boolean operators <tt class="docutils literal"><span class="pre">and</span></tt> and <tt class="docutils literal"><span class="pre">or</span></tt> are so-called <em>short-circuit</em>
operators: their arguments are evaluated from left to right, and evaluation
stops as soon as the outcome is determined.  For example, if <tt class="docutils literal"><span class="pre">A</span></tt> and <tt class="docutils literal"><span class="pre">C</span></tt> are
true but <tt class="docutils literal"><span class="pre">B</span></tt> is false, <tt class="docutils literal"><span class="pre">A</span> <span class="pre">and</span> <span class="pre">B</span> <span class="pre">and</span> <span class="pre">C</span></tt> does not evaluate the expression
<tt class="docutils literal"><span class="pre">C</span></tt>.  When used as a general value and not as a Boolean, the return value of a
short-circuit operator is the last evaluated argument.</p>
<p>逻辑操作符 <tt class="docutils literal"><span class="pre">and</span></tt> 和 <tt class="docutils literal"><span class="pre">or</span></tt> 也称作*短路操作符*：它们的参数从左向右解析，一旦结果可以确定就
停止。例如，如果 <tt class="docutils literal"><span class="pre">A</span></tt> 和 <tt class="docutils literal"><span class="pre">C</span></tt> 为真而 <tt class="docutils literal"><span class="pre">B</span></tt> 为假， <tt class="docutils literal"><span class="pre">A</span> <span class="pre">and</span> <span class="pre">B</span> <span class="pre">and</span> <span class="pre">C</span></tt> 不会解析 <a href="#id5"><span class="problematic" id="id6">``</span></a>C``。
作用于一个普通的非逻辑值时，短路操作符的返回值通常是最后一个变量。</p>
<p>It is possible to assign the result of a comparison or other Boolean expression
to a variable.  For example,</p>
<p>可以把比较或其它逻辑表达式的返回值赋给一个变量，例如：</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">string1</span><span class="p">,</span> <span class="n">string2</span><span class="p">,</span> <span class="n">string3</span> <span class="o">=</span> <span class="s">&#39;&#39;</span><span class="p">,</span> <span class="s">&#39;Trondheim&#39;</span><span class="p">,</span> <span class="s">&#39;Hammer Dance&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">non_null</span> <span class="o">=</span> <span class="n">string1</span> <span class="ow">or</span> <span class="n">string2</span> <span class="ow">or</span> <span class="n">string3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">non_null</span>
<span class="go">&#39;Trondheim&#39;</span>
</pre></div>
<p>Note that in Python, unlike C, assignment cannot occur inside expressions. C
programmers may grumble about this, but it avoids a common class of problems
encountered in C programs: typing <tt class="docutils literal"><span class="pre">=</span></tt> in an expression when <tt class="docutils literal"><span class="pre">==</span></tt> was
intended.</p>
<p>需要注意的是 Python 与 C 不同，在表达式内部不能赋值。 C 程序员经常对此抱怨，不过它避免
了一类在 C 程序中司空见惯的错误：想要在解析式中使 <tt class="docutils literal"><span class="pre">==</span></tt> 时误用了 <tt class="docutils literal"><span class="pre">=</span></tt> 操作符。</p>
</div>
<div class="section" id="comparing-sequences-and-other-types">
<span id="tut-comparing"></span><h2>Comparing Sequences and Other Types 比较序列和其它类型<a class="headerlink" href="#comparing-sequences-and-other-types" title="Permalink to this headline">¶</a></h2>
<p>Sequence objects may be compared to other objects with the same sequence type.
The comparison uses <em>lexicographical</em> ordering: first the first two items are
compared, and if they differ this determines the outcome of the comparison; if
they are equal, the next two items are compared, and so on, until either
sequence is exhausted. If two items to be compared are themselves sequences of
the same type, the lexicographical comparison is carried out recursively.  If
all items of two sequences compare equal, the sequences are considered equal.
If one sequence is an initial sub-sequence of the other, the shorter sequence is
the smaller (lesser) one.  Lexicographical ordering for strings uses the ASCII
ordering for individual characters.  Some examples of comparisons between
sequences of the same type:</p>
<p>序列对象可以与相同类型的其它对象比较。比较操作按*字典*序进行：首先比较前两个元素，如果不同，
就决定了比较的结果；如果相同，就比较后两个元素，依此类推，直到所有序列都完成比较。如果两个
元素本身就是同样类型的序列，就递归字典序比较。如果两个序列的所有子项都相等，就认为序列相等。
如果一个序列是另一个序列的初始子序列，较短的一个序列就小于另一个。字符串的字典序按照单字符的
ASCII 顺序。下面是同类型序列之间比较的一些例子：</p>
<blockquote>
(1, 2, 3)              &lt; (1, 2, 4)
[1, 2, 3]              &lt; [1, 2, 4]
&#8216;ABC&#8217; &lt; &#8216;C&#8217; &lt; &#8216;Pascal&#8217; &lt; &#8216;Python&#8217;
(1, 2, 3, 4)           &lt; (1, 2, 4)
(1, 2)                 &lt; (1, 2, -1)
(1, 2, 3)             == (1.0, 2.0, 3.0)
(1, 2, (&#8216;aa&#8217;, &#8216;ab&#8217;))   &lt; (1, 2, (&#8216;abc&#8217;, &#8216;a&#8217;), 4)</blockquote>
<p>Note that comparing objects of different types with <tt class="docutils literal"><span class="pre">&lt;</span></tt> or <tt class="docutils literal"><span class="pre">&gt;</span></tt> is legal
provided that the objects have appropriate comparison methods.  For example,
mixed numeric types are compared according to their numeric value, so 0 equals
0.0, etc.  Otherwise, rather than providing an arbitrary ordering, the
interpreter will raise a <a title="exceptions.TypeError" class="reference external" href="../library/exceptions.html#exceptions.TypeError"><tt class="xref docutils literal"><span class="pre">TypeError</span></tt></a> exception.</p>
<p>需要注意的是用 <tt class="docutils literal"><span class="pre">&lt;</span></tt> 或 <tt class="docutils literal"><span class="pre">&gt;</span></tt> 比较不同类型的对象是合法的。参与比较的对象要提供适当的
比较方法。例如，不同数值类型比较时会统一它们的值大小，所以0等于0.0，等等。另一方面，如
果没有确定的排序方法，解释器会抛出 <a title="exceptions.TypeError" class="reference external" href="../library/exceptions.html#exceptions.TypeError"><tt class="xref docutils literal"><span class="pre">TypeError</span></tt></a> 异常。</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <h3><a href="../contents.html">Table Of Contents</a></h3>
            <ul>
<li><a class="reference external" href="">Data Structures 数据结构</a><ul>
<li><a class="reference external" href="#tuples-and-sequences">Tuples and Sequences 元组和序列</a></li>
<li><a class="reference external" href="#more-on-lists">More on Lists 深入链表</a><ul>
<li><a class="reference external" href="#using-lists-as-stacks">Using Lists as Stacks 将列表当做堆栈使用</a></li>
<li><a class="reference external" href="#using-lists-as-queues">Using Lists as Queues 将列表当作队列使用</a></li>
<li><a class="reference external" href="#list-comprehensions">List Comprehensions 列表推导式</a></li>
</ul>
</li>
<li><a class="reference external" href="#the-del-statement-del">The <tt class="docutils literal"><span class="pre">del</span></tt> statement <tt class="docutils literal"><span class="pre">del</span></tt> 语句</a></li>
<li><a class="reference external" href="#sets">Sets 集合</a></li>
<li><a class="reference external" href="#dictionaries">Dictionaries 字典</a></li>
<li><a class="reference external" href="#looping-techniques">Looping Techniques 遍历技巧</a></li>
<li><a class="reference external" href="#more-on-conditions">More on Conditions 深入条件控制</a></li>
<li><a class="reference external" href="#comparing-sequences-and-other-types">Comparing Sequences and Other Types 比较序列和其它类型</a></li>
</ul>
</li>
</ul>

            <h4>Previous topic</h4>
            <p class="topless"><a href="controlflow.html" title="previous chapter">More Control Flow Tools 深入流程控制</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="modules.html" title="next chapter">Modules 模块</a></p>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="../_sources/tutorial/datastructures.txt">Show Source</a></li>
            </ul>
          <h3>Quick search</h3>
            <form class="search" action="../search.html" method="get">
              <input type="text" name="q" size="18" /> <input type="submit" value="Go" />
              <input type="hidden" name="check_keywords" value="yes" />
              <input type="hidden" name="area" value="default" />
            </form>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../modindex.html" title="Global Module Index"
             accesskey="M">modules</a> |</li>
        <li class="right" >
          <a href="modules.html" title="Modules 模块"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="controlflow.html" title="More Control Flow Tools 深入流程控制"
             accesskey="P">previous</a> |</li>
<li><img src="../_static/py.png" alt="" style="vertical-align: middle; margin-top: -1px"/></li>

        <li><a href="../contents.html">Python v3.0c1 documentation</a> &raquo;</li>

          <li><a href="index.html" accesskey="U">The Python tutorial Python 入门指南</a> &raquo;</li>
      </ul>
    </div>
    <div class="footer">
      &copy; <a href="../copyright.html">Copyright</a> 1990-2008, Python Software Foundation.
      Last updated on Oct 31, 2008.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 0.5.
    </div>
  </body>
</html>