<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Errors and Exceptions 错误和异常 &mdash; Python v3.0c1 documentation</title>
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
          URL_ROOT:    '../',
          VERSION:     '3.0c1',
          COLLAPSE_MODINDEX: false,
          FILE_SUFFIX: '.html'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Python v3.0c1 documentation"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="Python v3.0c1 documentation" href="../index.html" />
    <link rel="up" title="The Python tutorial Python 入门指南" href="index.html" />
    <link rel="next" title="Classes 类" href="classes.html" />
    <link rel="prev" title="Input and Output 输出和输出" href="inputoutput.html" />
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../modindex.html" title="Global Module Index"
             accesskey="M">modules</a> |</li>
        <li class="right" >
          <a href="classes.html" title="Classes 类"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="inputoutput.html" title="Input and Output 输出和输出"
             accesskey="P">previous</a> |</li>
<li><img src="../_static/py.png" alt="" style="vertical-align: middle; margin-top: -1px"/></li>

        <li><a href="../contents.html">Python v3.0c1 documentation</a> &raquo;</li>

          <li><a href="index.html" accesskey="U">The Python tutorial Python 入门指南</a> &raquo;</li>
      </ul>
    </div>
    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  
  <p>. _tut-errors:</p>
<div class="section" id="errors-and-exceptions">
<h1>Errors and Exceptions    错误和异常<a class="headerlink" href="#errors-and-exceptions" title="Permalink to this headline">¶</a></h1>
<p>Until now error messages haven&#8217;t been more than mentioned, but if you have tried
out the examples you have probably seen some.  There are (at least) two
distinguishable kinds of errors: <em>syntax errors</em> and <em>exceptions</em>.</p>
<p>直到现在，我们还没有更多的提及错误信息，但是如果你真的尝试了前面的例子，也许你会见到一些。这里（至少）
有两种错误很容易辨认：*语法错误*和*异常*。</p>
<div class="section" id="syntax-errors">
<span id="tut-syntaxerrors"></span><h2>Syntax Errors    语法错误<a class="headerlink" href="#syntax-errors" title="Permalink to this headline">¶</a></h2>
<p>Syntax errors, also known as parsing errors, are perhaps the most common kind of
complaint you get while you are still learning Python:</p>
<p>语法错误，或者称之为解析错，是你在学习 Python 的过程中最无孔不入的一种了:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">while</span> <span class="bp">True</span> <span class="k">print</span><span class="p">(</span><span class="s">&#39;Hello world&#39;</span><span class="p">)</span>
<span class="go">  File &quot;&lt;stdin&gt;&quot;, line 1, in ?</span>
<span class="go">    while True print(&#39;Hello world&#39;)</span>
<span class="go">                   ^</span>
<span class="go">SyntaxError: invalid syntax</span>
</pre></div>
<p>The parser repeats the offending line and displays a little &#8216;arrow&#8217; pointing at
the earliest point in the line where the error was detected.  The error is
caused by (or at least detected at) the token <em>preceding</em> the arrow: in the
example, the error is detected at the function <a title="print" class="reference external" href="../library/functions.html#print"><tt class="xref docutils literal"><span class="pre">print()</span></tt></a>, since a colon
(<tt class="docutils literal"><span class="pre">':'</span></tt>) is missing before it.  File name and line number are printed so you
know where to look in case the input came from a script.</p>
<p>语法分析器指出了出错的一行，并且在最先找到的错误的位置标记了一个小小的&#8217;箭头&#8217;。箭头靠前的位置，
就是错误发生（或者至少是被发现）的位置。这个例子中，函数 <a title="print" class="reference external" href="../library/functions.html#print"><tt class="xref docutils literal"><span class="pre">print()</span></tt></a> 被检查到有错误，
是它前面缺少了一个冒号（``&#8217;:&#8217;<a href="#id1"><span class="problematic" id="id2">``</span></a>）。文件名和行号一并给出，这样就方便的获知是哪一个脚本的问题了。</p>
</div>
<div class="section" id="exceptions">
<span id="tut-exceptions"></span><h2>Exceptions    异常<a class="headerlink" href="#exceptions" title="Permalink to this headline">¶</a></h2>
<p>Even if a statement or expression is syntactically correct, it may cause an
error when an attempt is made to execute it. Errors detected during execution
are called <em>exceptions</em> and are not unconditionally fatal: you will soon learn
how to handle them in Python programs.  Most exceptions are not handled by
programs, however, and result in error messages as shown here:</p>
<p>就算一个语句或表达式在语法上是正确的，在运行它的时候，也有可能发生错误。运行期检测到的错误被称
为*异常*，程序并不会无条件的崩掉，你很快就可以了解到在Python中如何处理它们了。大多数的异常
都不会被程序处理，都以错误信息的形式展现在这里:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="mf">10</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1</span><span class="o">/</span><span class="mf">0</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n-Identifier">?</span>
<span class="nc">ZeroDivisionError</span>: <span class="n-Identifier">int division or modulo by zero</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mf">4</span> <span class="o">+</span> <span class="n">spam</span><span class="o">*</span><span class="mf">3</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n-Identifier">?</span>
<span class="nc">NameError</span>: <span class="n-Identifier">name &#39;spam&#39; is not defined</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s">&#39;2&#39;</span> <span class="o">+</span> <span class="mf">2</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n-Identifier">?</span>
<span class="nc">TypeError: coercing to Unicode</span>: <span class="n-Identifier">need string or buffer, int found</span>
</pre></div>
<p>The last line of the error message indicates what happened. Exceptions come in
different types, and the type is printed as part of the message: the types in
the example are <a title="exceptions.ZeroDivisionError" class="reference external" href="../library/exceptions.html#exceptions.ZeroDivisionError"><tt class="xref docutils literal"><span class="pre">ZeroDivisionError</span></tt></a>, <a title="exceptions.NameError" class="reference external" href="../library/exceptions.html#exceptions.NameError"><tt class="xref docutils literal"><span class="pre">NameError</span></tt></a> and <a title="exceptions.TypeError" class="reference external" href="../library/exceptions.html#exceptions.TypeError"><tt class="xref docutils literal"><span class="pre">TypeError</span></tt></a>.
The string printed as the exception type is the name of the built-in exception
that occurred.  This is true for all built-in exceptions, but need not be true
for user-defined exceptions (although it is a useful convention). Standard
exception names are built-in identifiers (not reserved keywords).</p>
<p>错误信息的最后一行告诉你到底发生了什么。异常以不同的类型出现，这些类型都作为信息的一部分打印出
来: 例子中的类型有 <tt class="xref docutils literal"><span class="pre">ZeroDivisionError`，:exc:`NameError</span></tt> 和 :exc:<a href="#id3"><span class="problematic" id="id4">`</span></a>TypeError`。
被打印出的异常类型的字符串就是内置的异常的名称。这条规则适用于所有的内置异常，但对用户定义的异
常并不强制（虽然这是非常有用的方法）。标准的异常名称是内置的标识符（没有保留关键字）。</p>
<p>The rest of the line provides detail based on the type of exception and what
caused it.</p>
<p>这一行最后一部分描述了异常的详细内容和发生的原因。</p>
<p>The preceding part of the error message shows the context where the exception
happened, in the form of a stack traceback. In general it contains a stack
traceback listing source lines; however, it will not display lines read from
standard input.</p>
<p>错误信息的前面部分显示了异常发生的上下文，并以调用栈的形式显示具体信息。通常它包含调用栈
里的每一个源代码行，然而，来自标准输入的源码不会显示出来。</p>
<p><a class="reference external" href="../library/exceptions.html#bltin-exceptions"><em>Built-in Exceptions</em></a> lists the built-in exceptions and their meanings.</p>
</div>
<div class="section" id="handling-exceptions">
<span id="tut-handling"></span><h2>Handling Exceptions    异常处理<a class="headerlink" href="#handling-exceptions" title="Permalink to this headline">¶</a></h2>
<p>It is possible to write programs that handle selected exceptions. Look at the
following example, which asks the user for input until a valid integer has been
entered, but allows the user to interrupt the program (using <tt class="docutils literal"><span class="pre">Control-C</span></tt> or
whatever the operating system supports); note that a user-generated interruption
is signalled by raising the <a title="exceptions.KeyboardInterrupt" class="reference external" href="../library/exceptions.html#exceptions.KeyboardInterrupt"><tt class="xref docutils literal"><span class="pre">KeyboardInterrupt</span></tt></a> exception.</p>
<p>可以通过编程来处理选中的异常。下面的例子让用户输入一个合法的整数，但是允许用户中断这个程序（使
用 <tt class="docutils literal"><span class="pre">Control-C</span></tt> 或者操作系统提供的方法）。用户中断的信息会引发一个 <a title="exceptions.KeyboardInterrupt" class="reference external" href="../library/exceptions.html#exceptions.KeyboardInterrupt"><tt class="xref docutils literal"><span class="pre">KeyboardInterrupt</span></tt></a>
异常。</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>        <span class="n">x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">(</span><span class="s">&quot;Please enter a number: &quot;</span><span class="p">))</span>
<span class="gp">... </span>        <span class="k">break</span>
<span class="gp">... </span>    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">print</span><span class="p">(</span><span class="s">&quot;Oops!  That was no valid number.  Try again...&quot;</span><span class="p">)</span>
<span class="gp">...</span>
</pre></div>
<p>The <a class="reference external" href="../reference/compound_stmts.html#try"><tt class="xref docutils literal"><span class="pre">try</span></tt></a> statement works as follows.</p>
<p>:keyword:<a href="#id5"><span class="problematic" id="id6">`</span></a>try`语句按照如下方式工作。</p>
<ul class="simple">
<li>First, the <em>try clause</em> (the statement(s) between the <a class="reference external" href="../reference/compound_stmts.html#try"><tt class="xref docutils literal"><span class="pre">try</span></tt></a> and
<a class="reference external" href="../reference/compound_stmts.html#except"><tt class="xref docutils literal"><span class="pre">except</span></tt></a> keywords) is executed.</li>
<li>首先，执行*try子句*（在关键字:keyword:<a href="#id7"><span class="problematic" id="id8">`</span></a>try`和关键字:keyword:<a href="#id9"><span class="problematic" id="id10">`</span></a>except`之间的语句）</li>
<li>If no exception occurs, the <em>except clause</em> is skipped and execution of the
<a class="reference external" href="../reference/compound_stmts.html#try"><tt class="xref docutils literal"><span class="pre">try</span></tt></a> statement is finished.</li>
<li>如果没有异常发生，忽略*except子句*，*try子句*执行完毕。</li>
<li>If an exception occurs during execution of the try clause, the rest of the
clause is skipped.  Then if its type matches the exception named after the
<a class="reference external" href="../reference/compound_stmts.html#except"><tt class="xref docutils literal"><span class="pre">except</span></tt></a> keyword, the except clause is executed, and then execution
continues after the <a class="reference external" href="../reference/compound_stmts.html#try"><tt class="xref docutils literal"><span class="pre">try</span></tt></a> statement.</li>
<li>如果在执行try子句的过程中发生了异常，那么try子句余下的部分将被忽略。如果异常的类型</li>
</ul>
<p>和 <a class="reference external" href="../reference/compound_stmts.html#except"><tt class="xref docutils literal"><span class="pre">except</span></tt></a> 之后的名称相符，那么对应的except子句将被执行。最后执
行 <a class="reference external" href="../reference/compound_stmts.html#try"><tt class="xref docutils literal"><span class="pre">try</span></tt></a> 语句之后的代码。</p>
<ul class="simple">
<li>If an exception occurs which does not match the exception named in the except
clause, it is passed on to outer <a class="reference external" href="../reference/compound_stmts.html#try"><tt class="xref docutils literal"><span class="pre">try</span></tt></a> statements; if no handler is
found, it is an <em>unhandled exception</em> and execution stops with a message as
shown above.</li>
<li>如果一个异常没有与任何的except匹配，那么这个异常将会传递给上层的:keyword:<a href="#id11"><span class="problematic" id="id12">`</span></a>try`中。</li>
</ul>
<p>如果最终仍然没有找到能够处理这个异常的代码，那么他就成了一个*未处理异常*，执行被中断，显
示提示信息。</p>
<p>A <a class="reference external" href="../reference/compound_stmts.html#try"><tt class="xref docutils literal"><span class="pre">try</span></tt></a> statement may have more than one except clause, to specify
handlers for different exceptions.  At most one handler will be executed.
Handlers only handle exceptions that occur in the corresponding try clause, not
in other handlers of the same <a class="reference external" href="../reference/compound_stmts.html#try"><tt class="xref docutils literal"><span class="pre">try</span></tt></a> statement.  An except clause may
name multiple exceptions as a parenthesized tuple, for example:</p>
<p>一个 <a class="reference external" href="../reference/compound_stmts.html#try"><tt class="xref docutils literal"><span class="pre">try</span></tt></a> 语句可能包含多个except子句，分别来处理不同的特定的异常。最多只有一个
分支会被执行。处理程序将只针对对应的try子句中的异常进行处理，而不是其他的 <a href="#id13"><span class="problematic" id="id14">:keyrowd:`try`</span></a>
的处理程序中的异常。一个except子句可以同时处理多个异常，这些异常将被放在一个括号里成为一个
元组，例如:</p>
<div class="highlight"><pre><span class="o">...</span> <span class="k">except</span> <span class="p">(</span><span class="ne">RuntimeError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">,</span> <span class="ne">NameError</span><span class="p">):</span>
<span class="o">...</span>     <span class="k">pass</span>
</pre></div>
<p>The last except clause may omit the exception name(s), to serve as a wildcard.
Use this with extreme caution, since it is easy to mask a real programming error
in this way!  It can also be used to print an error message and then re-raise
the exception (allowing a caller to handle the exception as well):</p>
<p>最后一个except子句可以忽略异常的名称，它将被当作通配符使用。这种方法要慎用！搞不好你会把程序中真
正的错误隐藏的无影无踪。你可以使用这种方法打印一个错误信息，然后再次把异常抛出
（就让调用者去处理这个烫手的山芋吧）:</p>
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">sys</span>

<span class="k">try</span><span class="p">:</span>
    <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">&#39;myfile.txt&#39;</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
    <span class="n">i</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>
<span class="k">except</span> <span class="ne">IOError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s">&quot;I/O error(%s): %s&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">errno</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">strerror</span><span class="p">))</span>
<span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s">&quot;Could not convert data to an integer.&quot;</span><span class="p">)</span>
<span class="k">except</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s">&quot;Unexpected error:&quot;</span><span class="p">,</span> <span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">raise</span>
</pre></div>
<p>The <a class="reference external" href="../reference/compound_stmts.html#try"><tt class="xref docutils literal"><span class="pre">try</span></tt></a> ... <a class="reference external" href="../reference/compound_stmts.html#except"><tt class="xref docutils literal"><span class="pre">except</span></tt></a> statement has an optional <em>else
clause</em>, which, when present, must follow all except clauses.  It is useful for
code that must be executed if the try clause does not raise an exception.  For
example:</p>
<pre>:keyword:`try` ... :keyword:`except`语句还有一个可选的*else子句*，如果使用这个子句，</pre>
<p>那么必须放在所有的except子句之后。这个子句将在try子句没有发生任何异常的时候执行。例如:</p>
<div class="highlight"><pre><span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="s">&#39;r&#39;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s">&#39;cannot open&#39;</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="s">&#39;has&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">readlines</span><span class="p">()),</span> <span class="s">&#39;lines&#39;</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
<p>The use of the <a class="reference external" href="../reference/compound_stmts.html#else"><tt class="xref docutils literal"><span class="pre">else</span></tt></a> clause is better than adding additional code to
the <a class="reference external" href="../reference/compound_stmts.html#try"><tt class="xref docutils literal"><span class="pre">try</span></tt></a> clause because it avoids accidentally catching an exception
that wasn&#8217;t raised by the code being protected by the <a class="reference external" href="../reference/compound_stmts.html#try"><tt class="xref docutils literal"><span class="pre">try</span></tt></a> ...
<a class="reference external" href="../reference/compound_stmts.html#except"><tt class="xref docutils literal"><span class="pre">except</span></tt></a> statement.</p>
<p>使用 <a class="reference external" href="../reference/compound_stmts.html#else"><tt class="xref docutils literal"><span class="pre">else</span></tt></a> 子句比把所有的语句都放在 <a class="reference external" href="../reference/compound_stmts.html#try"><tt class="xref docutils literal"><span class="pre">try</span></tt></a> 子句里面要好，这样可以避免
一些意想不到的、而except又没有捕获的异常。</p>
<p>When an exception occurs, it may have an associated value, also known as the
exception&#8217;s <em>argument</em>. The presence and type of the argument depend on the
exception type.</p>
<p>当发生了一个异常，可能伴随着会有相关数据，也就是所谓的异常的*参数*。是否有这个参数，以及它
的类型取决于异常的类型。</p>
<p>The except clause may specify a variable after the exception name (or tuple).
The variable is bound to an exception instance with the arguments stored in
<tt class="docutils literal"><span class="pre">instance.args</span></tt>.  For convenience, the exception instance defines
<a title="object.__getitem__" class="reference external" href="../reference/datamodel.html#object.__getitem__"><tt class="xref docutils literal"><span class="pre">__getitem__()</span></tt></a> and <a title="object.__str__" class="reference external" href="../reference/datamodel.html#object.__str__"><tt class="xref docutils literal"><span class="pre">__str__()</span></tt></a> so the arguments can be accessed or
printed directly without having to reference <tt class="docutils literal"><span class="pre">.args</span></tt>.</p>
<p>except语句可以在异常名字（或元组）之后指定一个变量。这个变量绑定异常实例，异常的参数存放
在 <tt class="docutils literal"><span class="pre">instance.args</span></tt> 里面。为了方便使用，这个实例定义了方法 <a title="object.__getitem__" class="reference external" href="../reference/datamodel.html#object.__getitem__"><tt class="xref docutils literal"><span class="pre">__getitem__()</span></tt></a>
和 <tt class="xref docutils literal"><span class="pre">__str__`，所以这个参数可以直接用于赋值或打印，而不必麻烦的使用</span> <span class="pre">`()</span></tt>.args``。</p>
<p>But use of <tt class="docutils literal"><span class="pre">.args</span></tt> is discouraged.  Instead, the preferred use is to pass a
single argument to an exception (which can be a tuple if multiple arguments are
needed) and have it bound to the <tt class="docutils literal"><span class="pre">message</span></tt> attribute.  One may also
instantiate an exception first before raising it and add any attributes to it as
desired.</p>
<p>但是并不推荐使用 <tt class="docutils literal"><span class="pre">.args``。取而代之的是，这里欢迎给异常传递一个单独的参数（如果多个参数，</span>
<span class="pre">使用元组也可以），把它绑定到</span> <span class="pre">``message</span></tt> 属性上。一旦发生异常，它将在抛出前绑定所有指定的属性:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>   <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;spam&#39;</span><span class="p">,</span> <span class="s">&#39;eggs&#39;</span><span class="p">)</span>
<span class="gp">... </span><span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">inst</span><span class="p">:</span>
<span class="gp">... </span>   <span class="k">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">inst</span><span class="p">))</span>    <span class="c"># the exception instance</span>
<span class="gp">... </span>   <span class="k">print</span><span class="p">(</span><span class="n">inst</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>     <span class="c"># arguments stored in .args</span>
<span class="gp">... </span>   <span class="k">print</span><span class="p">(</span><span class="n">inst</span><span class="p">)</span>          <span class="c"># __str__ allows args to be printed directly</span>
<span class="gp">... </span>   <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">inst</span>          <span class="c"># __getitem__ allows args to be unpacked directly</span>
<span class="gp">... </span>   <span class="k">print</span><span class="p">(</span><span class="s">&#39;x =&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="gp">... </span>   <span class="k">print</span><span class="p">(</span><span class="s">&#39;y =&#39;</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">&lt;type &#39;Exception&#39;&gt;</span>
<span class="go">(&#39;spam&#39;, &#39;eggs&#39;)</span>
<span class="go">(&#39;spam&#39;, &#39;eggs&#39;)</span>
<span class="go">x = spam</span>
<span class="go">y = eggs</span>
</pre></div>
<p>If an exception has an argument, it is printed as the last part (&#8216;detail&#8217;) of
the message for unhandled exceptions.</p>
<p>对于未处理的异常，如果他含有参数，那么他就会被当作详细信息打印出来。</p>
<p>Exception handlers don&#8217;t just handle exceptions if they occur immediately in the
try clause, but also if they occur inside functions that are called (even
indirectly) in the try clause. For example:</p>
<p>异常处理并不仅仅处理那些直接发生在try子句中的异常，而且还能处理子句中调用的函
数（甚至间接调用的函数）里抛出的异常。例如:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">this_fails</span><span class="p">():</span>
<span class="gp">... </span>    <span class="n">x</span> <span class="o">=</span> <span class="mf">1</span><span class="o">/</span><span class="mf">0</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">this_fails</span><span class="p">()</span>
<span class="gp">... </span><span class="k">except</span> <span class="ne">ZeroDivisionError</span> <span class="k">as</span> <span class="n">detail</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s">&#39;Handling run-time error:&#39;</span><span class="p">,</span> <span class="n">detail</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">Handling run-time error: integer division or modulo by zero</span>
</pre></div>
</div>
<div class="section" id="raising-exceptions">
<span id="tut-raising"></span><h2>Raising Exceptions    抛出异常<a class="headerlink" href="#raising-exceptions" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference external" href="../reference/simple_stmts.html#raise"><tt class="xref docutils literal"><span class="pre">raise</span></tt></a> statement allows the programmer to force a specified
exception to occur. For example:</p>
<pre>:keyword:`raise` 语句允许程序员强制抛出一个指定的异常。例如::</pre>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s">&#39;HiThere&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n-Identifier">?</span>
<span class="nc">NameError</span>: <span class="n-Identifier">HiThere</span>
</pre></div>
<p>The sole argument to <a class="reference external" href="../reference/simple_stmts.html#raise"><tt class="xref docutils literal"><span class="pre">raise</span></tt></a> indicates the exception to be raised.
This must be either an exception instance or an exception class (a class that
derives from <tt class="xref docutils literal"><span class="pre">Exception</span></tt>).</p>
<p><a class="reference external" href="../reference/simple_stmts.html#raise"><tt class="xref docutils literal"><span class="pre">raise</span></tt></a> 唯一的一个参数指定了要被抛出的异常。它必须是一个异常的实例或者是异常的类（也就是 <tt class="xref docutils literal"><span class="pre">Exception</span></tt> 的子类）</p>
<p>If you need to determine whether an exception was raised but don&#8217;t intend to
handle it, a simpler form of the <a class="reference external" href="../reference/simple_stmts.html#raise"><tt class="xref docutils literal"><span class="pre">raise</span></tt></a> statement allows you to
re-raise the exception:</p>
<p>如果你只想知道这是否抛出了一个异常，并不想去处理它，那么一个简单的 <a class="reference external" href="../reference/simple_stmts.html#raise"><tt class="xref docutils literal"><span class="pre">raise</span></tt></a> 语句就可以再次把它抛出。</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s">&#39;HiThere&#39;</span><span class="p">)</span>
<span class="gp">... </span><span class="k">except</span> <span class="ne">NameError</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s">&#39;An exception flew by!&#39;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">raise</span>
<span class="gp">...</span>
<span class="go">An exception flew by!</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">2</span>, in <span class="n-Identifier">?</span>
<span class="nc">NameError</span>: <span class="n-Identifier">HiThere</span>
</pre></div>
</div>
<div class="section" id="user-defined-exceptions">
<span id="tut-userexceptions"></span><h2>User-defined Exceptions    用户定义异常<a class="headerlink" href="#user-defined-exceptions" title="Permalink to this headline">¶</a></h2>
<p>Programs may name their own exceptions by creating a new exception class.
Exceptions should typically be derived from the <a title="exceptions.Exception" class="reference external" href="../library/exceptions.html#exceptions.Exception"><tt class="xref docutils literal"><span class="pre">Exception</span></tt></a> class, either
directly or indirectly.  For example:</p>
<p>创建一个新的exception类，你就拥有了一个自己的异常。异常应该继承自 <a title="exceptions.Exception" class="reference external" href="../library/exceptions.html#exceptions.Exception"><tt class="xref docutils literal"><span class="pre">Exception</span></tt></a> 类，或者直接继承，或者间接继承。例如:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">MyError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">raise</span> <span class="n">MyError</span><span class="p">(</span><span class="mf">2</span><span class="o">*</span><span class="mf">2</span><span class="p">)</span>
<span class="gp">... </span><span class="k">except</span> <span class="n">MyError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s">&#39;My exception occurred, value:&#39;</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">My exception occurred, value: 4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">raise</span> <span class="n">MyError</span><span class="p">(</span><span class="s">&#39;oops!&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n-Identifier">?</span>
<span class="nc">__main__.MyError</span>: <span class="n-Identifier">&#39;oops!&#39;</span>
</pre></div>
<p>In this example, the default <a title="object.__init__" class="reference external" href="../reference/datamodel.html#object.__init__"><tt class="xref docutils literal"><span class="pre">__init__()</span></tt></a> of <tt class="xref docutils literal"><span class="pre">Exception</span></tt> has been
overridden.  The new behavior simply creates the <em>value</em> attribute.  This
replaces the default behavior of creating the <em>args</em> attribute.</p>
<p>在这个例子中，类 <tt class="xref docutils literal"><span class="pre">Exception</span></tt> 默认的 <a title="object.__init__" class="reference external" href="../reference/datamodel.html#object.__init__"><tt class="xref docutils literal"><span class="pre">__init__()</span></tt></a> 被覆盖，
被替换为只是简单的创建一个*value*属性。替换了原先的需要创建*args*属性的行为。</p>
<p>Exception classes can be defined which do anything any other class can do, but
are usually kept simple, often only offering a number of attributes that allow
information about the error to be extracted by handlers for the exception.  When
creating a module that can raise several distinct errors, a common practice is
to create a base class for exceptions defined by that module, and subclass that
to create specific exception classes for different error conditions:</p>
<p>异常的类可以像其他的类一样做任何事情，但是通常都会比较简单，只提供一些错误相关的属性，并且允许处
理异常的代码方便的获取这些信息。当创建一个模块有可能抛出多种不同的异常时，一种通常的做法是为这个
包建立一个基础异常类，然后基于这个基础类为不同的错误情况创建不同的子类。</p>
<blockquote>
<dl class="docutils">
<dt>class Error(Exception):</dt>
<dd>&#8220;&#8221;&#8220;Base class for exceptions in this module.&#8221;&#8220;&#8221;
pass</dd>
<dt>class InputError(Error):</dt>
<dd><p class="first">&#8220;&#8221;&#8220;Exception raised for errors in the input.</p>
<dl class="docutils">
<dt>Attributes:</dt>
<dd>expression &#8211; input expression in which the error occurred
message &#8211; explanation of the error</dd>
</dl>
<p>&#8220;&#8221;&#8220;</p>
<dl class="last docutils">
<dt>def __init__(self, expression, message):</dt>
<dd>self.expression = expression
self.message = message</dd>
</dl>
</dd>
<dt>class TransitionError(Error):</dt>
<dd><p class="first">&#8220;&#8221;&#8220;Raised when an operation attempts a state transition that&#8217;s not
allowed.</p>
<dl class="docutils">
<dt>Attributes:</dt>
<dd>previous &#8211; state at beginning of transition
next &#8211; attempted new state
message &#8211; explanation of why the specific transition is not allowed</dd>
</dl>
<p>&#8220;&#8221;&#8220;</p>
<dl class="last docutils">
<dt>def __init__(self, previous, next, message):</dt>
<dd>self.previous = previous
self.next = next
self.message = message</dd>
</dl>
</dd>
</dl>
</blockquote>
<p>Most exceptions are defined with names that end in &#8220;Error,&#8221; similar to the
naming of the standard exceptions.</p>
<p>大多数的异常的名字都以“Error”结尾，就跟标准的异常命名一样。</p>
<p>Many standard modules define their own exceptions to report errors that may
occur in functions they define.  More information on classes is presented in
chapter <a class="reference external" href="classes.html#tut-classes"><em>Classes 类</em></a>.</p>
<p>大多数的标准包为了描述自己的错误，都为自己的方法定义了自己的异常。更多的关于类的描述请参
阅:ref:<a href="#id15"><span class="problematic" id="id16">`</span></a>tut-classes`章节。</p>
</div>
<div class="section" id="defining-clean-up-actions">
<span id="tut-cleanup"></span><h2>Defining Clean-up Actions    定义清理行为<a class="headerlink" href="#defining-clean-up-actions" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference external" href="../reference/compound_stmts.html#try"><tt class="xref docutils literal"><span class="pre">try</span></tt></a> statement has another optional clause which is intended to
define clean-up actions that must be executed under all circumstances.  For
example:</p>
<pre>:keyword:`try` 语句还有另外一个可选的子句，它定义了无论在任何情况下都会执行的清理行为。 例如::</pre>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">raise</span> <span class="ne">KeyboardInterrupt</span>
<span class="gp">... </span><span class="k">finally</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s">&#39;Goodbye, world!&#39;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">Goodbye, world!</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">2</span>, in <span class="n-Identifier">?</span>
<span class="nc">KeyboardInterrupt</span>
</pre></div>
<p>A <em>finally clause</em> is always executed before leaving the <a class="reference external" href="../reference/compound_stmts.html#try"><tt class="xref docutils literal"><span class="pre">try</span></tt></a>
statement, whether an exception has occurred or not. When an exception has
occurred in the <a class="reference external" href="../reference/compound_stmts.html#try"><tt class="xref docutils literal"><span class="pre">try</span></tt></a> clause and has not been handled by an
<a class="reference external" href="../reference/compound_stmts.html#except"><tt class="xref docutils literal"><span class="pre">except</span></tt></a> clause (or it has occurred in a <a class="reference external" href="../reference/compound_stmts.html#except"><tt class="xref docutils literal"><span class="pre">except</span></tt></a> or
<a class="reference external" href="../reference/compound_stmts.html#else"><tt class="xref docutils literal"><span class="pre">else</span></tt></a> clause), it is re-raised after the <a class="reference external" href="../reference/compound_stmts.html#finally"><tt class="xref docutils literal"><span class="pre">finally</span></tt></a> clause has
been executed.  The <a class="reference external" href="../reference/compound_stmts.html#finally"><tt class="xref docutils literal"><span class="pre">finally</span></tt></a> clause is also executed &#8220;on the way out&#8221;
when any other clause of the <a class="reference external" href="../reference/compound_stmts.html#try"><tt class="xref docutils literal"><span class="pre">try</span></tt></a> statement is left via a
<a class="reference external" href="../reference/simple_stmts.html#break"><tt class="xref docutils literal"><span class="pre">break</span></tt></a>, <a class="reference external" href="../reference/simple_stmts.html#continue"><tt class="xref docutils literal"><span class="pre">continue</span></tt></a> or <a class="reference external" href="../reference/simple_stmts.html#return"><tt class="xref docutils literal"><span class="pre">return</span></tt></a> statement.  A more
complicated example (having <a class="reference external" href="../reference/compound_stmts.html#except"><tt class="xref docutils literal"><span class="pre">except</span></tt></a> and <a class="reference external" href="../reference/compound_stmts.html#finally"><tt class="xref docutils literal"><span class="pre">finally</span></tt></a> clauses in
the same <a class="reference external" href="../reference/compound_stmts.html#try"><tt class="xref docutils literal"><span class="pre">try</span></tt></a> statement works as of Python 2.5):</p>
<p>无论怎样离开的 <a class="reference external" href="../reference/compound_stmts.html#try"><tt class="xref docutils literal"><span class="pre">try</span></tt></a> ，*finally子句*都会执行，而不管*try子句*里面有没有发生异常。
如果一个异常在 <a class="reference external" href="../reference/compound_stmts.html#try"><tt class="xref docutils literal"><span class="pre">try</span></tt></a> 子句里（或者在 <a class="reference external" href="../reference/compound_stmts.html#except"><tt class="xref docutils literal"><span class="pre">except</span></tt></a> 和 <a class="reference external" href="../reference/compound_stmts.html#else"><tt class="xref docutils literal"><span class="pre">else</span></tt></a> 子
句里）被抛出，而又没有任何的 <a class="reference external" href="../reference/compound_stmts.html#except"><tt class="xref docutils literal"><span class="pre">except</span></tt></a> 把它截住，那么这个异常会在 <a class="reference external" href="../reference/compound_stmts.html#finally"><tt class="xref docutils literal"><span class="pre">finally</span></tt></a>
子句执行后再次被抛出。:keyword:<cite>finally</cite> 子句总是挡在程序要跑路的路中间，因为离开
<a class="reference external" href="../reference/compound_stmts.html#try"><tt class="xref docutils literal"><span class="pre">try</span></tt></a> 语句的时候一定会执行，甚至 <tt class="xref docutils literal"><span class="pre">break`，</span> <span class="pre">:keyword:`continue</span></tt>
和 <a class="reference external" href="../reference/simple_stmts.html#return"><tt class="xref docutils literal"><span class="pre">return</span></tt></a> 也逃不出他的手掌心。下面是一个更加复杂的例子（在同一个 <a class="reference external" href="../reference/compound_stmts.html#try"><tt class="xref docutils literal"><span class="pre">try</span></tt></a>
语句里包含 <a class="reference external" href="../reference/compound_stmts.html#except"><tt class="xref docutils literal"><span class="pre">except</span></tt></a> 和 <a class="reference external" href="../reference/compound_stmts.html#finally"><tt class="xref docutils literal"><span class="pre">finally</span></tt></a> 子句，就像在Python2.5里）:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">divide</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>        <span class="n">result</span> <span class="o">=</span> <span class="n">x</span> <span class="o">/</span> <span class="n">y</span>
<span class="gp">... </span>    <span class="k">except</span> <span class="ne">ZeroDivisionError</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">print</span><span class="p">(</span><span class="s">&quot;division by zero!&quot;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">else</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">print</span><span class="p">(</span><span class="s">&quot;result is&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">finally</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">print</span><span class="p">(</span><span class="s">&quot;executing finally clause&quot;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">divide</span><span class="p">(</span><span class="mf">2</span><span class="p">,</span> <span class="mf">1</span><span class="p">)</span>
<span class="go">result is 2</span>
<span class="go">executing finally clause</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">divide</span><span class="p">(</span><span class="mf">2</span><span class="p">,</span> <span class="mf">0</span><span class="p">)</span>
<span class="go">division by zero!</span>
<span class="go">executing finally clause</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">divide</span><span class="p">(</span><span class="s">&quot;2&quot;</span><span class="p">,</span> <span class="s">&quot;1&quot;</span><span class="p">)</span>
<span class="go">executing finally clause</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n-Identifier">?</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">3</span>, in <span class="n-Identifier">divide</span>
<span class="nc">TypeError: unsupported operand type(s) for /</span>: <span class="n-Identifier">&#39;str&#39; and &#39;str&#39;</span>
</pre></div>
<p>As you can see, the <a class="reference external" href="../reference/compound_stmts.html#finally"><tt class="xref docutils literal"><span class="pre">finally</span></tt></a> clause is executed in any event.  The
<a title="exceptions.TypeError" class="reference external" href="../library/exceptions.html#exceptions.TypeError"><tt class="xref docutils literal"><span class="pre">TypeError</span></tt></a> raised by dividing two strings is not handled by the
<a class="reference external" href="../reference/compound_stmts.html#except"><tt class="xref docutils literal"><span class="pre">except</span></tt></a> clause and therefore re-raised after the <a class="reference external" href="../reference/compound_stmts.html#finally"><tt class="xref docutils literal"><span class="pre">finally</span></tt></a>
clauses has been executed.</p>
<p>正如你所见，:keyword:<cite>finally</cite> 子句在任何情况下都运行。异常 <a title="exceptions.TypeError" class="reference external" href="../library/exceptions.html#exceptions.TypeError"><tt class="xref docutils literal"><span class="pre">TypeError</span></tt></a> 在做两个
字符创除法的时候并没有被任何的 <a class="reference external" href="../reference/compound_stmts.html#except"><tt class="xref docutils literal"><span class="pre">except</span></tt></a> 截获，但是它也是在 <a class="reference external" href="../reference/compound_stmts.html#finally"><tt class="xref docutils literal"><span class="pre">finally</span></tt></a>
子句执行后才再次被抛出的。</p>
<p>In real world applications, the <a class="reference external" href="../reference/compound_stmts.html#finally"><tt class="xref docutils literal"><span class="pre">finally</span></tt></a> clause is useful for
releasing external resources (such as files or network connections), regardless
of whether the use of the resource was successful.</p>
<p>在真实的应用中，:keyword:<cite>finally</cite> 子句通常用来释放外部资源（比如文件或者网络连接），
无论这些资源是否被成功的使用。</p>
</div>
<div class="section" id="predefined-clean-up-actions">
<span id="tut-cleanup-with"></span><h2>Predefined Clean-up Actions    预定义的清理行为<a class="headerlink" href="#predefined-clean-up-actions" title="Permalink to this headline">¶</a></h2>
<p>Some objects define standard clean-up actions to be undertaken when the object
is no longer needed, regardless of whether or not the operation using the object
succeeded or failed. Look at the following example, which tries to open a file
and print its contents to the screen.</p>
<p>一些对象定义了标准的清理行为，无论系统是否成功的使用了它，一旦不需要它了，那么这个标准的清理行为
就会执行。这面这个例子展示了尝试打开一个文件，然后把内容打印到屏幕上。</p>
<div class="highlight"><pre><span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">open</span><span class="p">(</span><span class="s">&quot;myfile.txt&quot;</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
</pre></div>
<p>The problem with this code is that it leaves the file open for an indeterminate
amount of time after this part of the code has finished executing.
This is not an issue in simple scripts, but can be a problem for larger
applications. The <a class="reference external" href="../reference/compound_stmts.html#with"><tt class="xref docutils literal"><span class="pre">with</span></tt></a> statement allows objects like files to be
used in a way that ensures they are always cleaned up promptly and correctly.</p>
<p>这段代码的问题是，当执行完毕后，文件会保持打开状态，并没有被关闭。在一些简单的脚本里面这不是问
题，但是在大型的应用中问题可就大了。:keyword:<cite>with</cite> 语句就可以保证诸如文件之类的对象在使用
完之后一定会正确的执行他的清理方法。</p>
<div class="highlight"><pre><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">&quot;myfile.txt&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
</pre></div>
<p>After the statement is executed, the file <em>f</em> is always closed, even if a
problem was encountered while processing the lines. Objects which, like files,
provide predefined clean-up actions will indicate this in their documentation.</p>
<p>这段代码执行完毕后，文件*f*总是会关闭，就算在处理过程中出问题了，它也保证会管理。凡是像文件这样
的对象，它都会在自己的文档中注明是否提供了预定义的清理对象。</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <h3><a href="../contents.html">Table Of Contents</a></h3>
            <ul>
<li><a class="reference external" href="">Errors and Exceptions    错误和异常</a><ul>
<li><a class="reference external" href="#syntax-errors">Syntax Errors    语法错误</a></li>
<li><a class="reference external" href="#exceptions">Exceptions    异常</a></li>
<li><a class="reference external" href="#handling-exceptions">Handling Exceptions    异常处理</a></li>
<li><a class="reference external" href="#raising-exceptions">Raising Exceptions    抛出异常</a></li>
<li><a class="reference external" href="#user-defined-exceptions">User-defined Exceptions    用户定义异常</a></li>
<li><a class="reference external" href="#defining-clean-up-actions">Defining Clean-up Actions    定义清理行为</a></li>
<li><a class="reference external" href="#predefined-clean-up-actions">Predefined Clean-up Actions    预定义的清理行为</a></li>
</ul>
</li>
</ul>

            <h4>Previous topic</h4>
            <p class="topless"><a href="inputoutput.html" title="previous chapter">Input and Output 输出和输出</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="classes.html" title="next chapter">Classes 类</a></p>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="../_sources/tutorial/errors.txt">Show Source</a></li>
            </ul>
          <h3>Quick search</h3>
            <form class="search" action="../search.html" method="get">
              <input type="text" name="q" size="18" /> <input type="submit" value="Go" />
              <input type="hidden" name="check_keywords" value="yes" />
              <input type="hidden" name="area" value="default" />
            </form>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../modindex.html" title="Global Module Index"
             accesskey="M">modules</a> |</li>
        <li class="right" >
          <a href="classes.html" title="Classes 类"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="inputoutput.html" title="Input and Output 输出和输出"
             accesskey="P">previous</a> |</li>
<li><img src="../_static/py.png" alt="" style="vertical-align: middle; margin-top: -1px"/></li>

        <li><a href="../contents.html">Python v3.0c1 documentation</a> &raquo;</li>

          <li><a href="index.html" accesskey="U">The Python tutorial Python 入门指南</a> &raquo;</li>
      </ul>
    </div>
    <div class="footer">
      &copy; <a href="../copyright.html">Copyright</a> 1990-2008, Python Software Foundation.
      Last updated on Oct 31, 2008.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 0.5.
    </div>
  </body>
</html>