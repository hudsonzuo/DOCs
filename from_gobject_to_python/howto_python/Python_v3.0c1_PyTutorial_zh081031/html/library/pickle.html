<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>pickle &#8212; Python object serialization &mdash; Python v3.0c1 documentation</title>
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
          URL_ROOT:    '../',
          VERSION:     '3.0c1',
          COLLAPSE_MODINDEX: false,
          FILE_SUFFIX: '.html'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Python v3.0c1 documentation"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="Python v3.0c1 documentation" href="../index.html" />
    <link rel="up" title="Data Persistence" href="persistence.html" />
    <link rel="next" title="copyreg &#8212; Register pickle support functions" href="copyreg.html" />
    <link rel="prev" title="Data Persistence" href="persistence.html" />
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../modindex.html" title="Global Module Index"
             accesskey="M">modules</a> |</li>
        <li class="right" >
          <a href="copyreg.html" title="copyreg &#8212; Register pickle support functions"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="persistence.html" title="Data Persistence"
             accesskey="P">previous</a> |</li>
<li><img src="../_static/py.png" alt="" style="vertical-align: middle; margin-top: -1px"/></li>

        <li><a href="../contents.html">Python v3.0c1 documentation</a> &raquo;</li>

          <li><a href="index.html" accesskey="U">The Python Standard Library</a> &raquo;</li>
          <li><a href="persistence.html" accesskey="U">Data Persistence</a> &raquo;</li>
      </ul>
    </div>
    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  
  <div class="section" id="module-pickle">
<h1><tt class="xref docutils literal"><span class="pre">pickle</span></tt> &#8212; Python object serialization<a class="headerlink" href="#module-pickle" title="Permalink to this headline">¶</a></h1>
<span class="target" id="index-415"></span><p>The <tt class="xref docutils literal"><span class="pre">pickle</span></tt> module implements a fundamental, but powerful algorithm for
serializing and de-serializing a Python object structure.  &#8220;Pickling&#8221; is the
process whereby a Python object hierarchy is converted into a byte stream, and
&#8220;unpickling&#8221; is the inverse operation, whereby a byte stream is converted back
into an object hierarchy.  Pickling (and unpickling) is alternatively known as
&#8220;serialization&#8221;, &#8220;marshalling,&#8221; <a class="footnote-reference" href="#id6" id="id1">[1]</a> or &#8220;flattening&#8221;, however, to avoid
confusion, the terms used here are &#8220;pickling&#8221; and &#8220;unpickling&#8221;..</p>
<div class="section" id="relationship-to-other-python-modules">
<h2>Relationship to other Python modules<a class="headerlink" href="#relationship-to-other-python-modules" title="Permalink to this headline">¶</a></h2>
<p>The <tt class="xref docutils literal"><span class="pre">pickle</span></tt> module has an transparent optimizer (<tt class="xref docutils literal"><span class="pre">_pickle</span></tt>) written
in C. It is used whenever available. Otherwise the pure Python implementation is
used.</p>
<p>Python has a more primitive serialization module called <a title="Convert Python objects to streams of bytes and back (with different constraints)." class="reference external" href="marshal.html"><tt class="xref docutils literal"><span class="pre">marshal</span></tt></a>, but in
general <tt class="xref docutils literal"><span class="pre">pickle</span></tt> should always be the preferred way to serialize Python
objects.  <a title="Convert Python objects to streams of bytes and back (with different constraints)." class="reference external" href="marshal.html"><tt class="xref docutils literal"><span class="pre">marshal</span></tt></a> exists primarily to support Python&#8217;s <tt class="docutils literal"><span class="pre">.pyc</span></tt>
files.</p>
<p>The <tt class="xref docutils literal"><span class="pre">pickle</span></tt> module differs from <a title="Convert Python objects to streams of bytes and back (with different constraints)." class="reference external" href="marshal.html"><tt class="xref docutils literal"><span class="pre">marshal</span></tt></a> several significant ways:</p>
<ul>
<li><p class="first">The <tt class="xref docutils literal"><span class="pre">pickle</span></tt> module keeps track of the objects it has already serialized,
so that later references to the same object won&#8217;t be serialized again.
<a title="Convert Python objects to streams of bytes and back (with different constraints)." class="reference external" href="marshal.html"><tt class="xref docutils literal"><span class="pre">marshal</span></tt></a> doesn&#8217;t do this.</p>
<p>This has implications both for recursive objects and object sharing.  Recursive
objects are objects that contain references to themselves.  These are not
handled by marshal, and in fact, attempting to marshal recursive objects will
crash your Python interpreter.  Object sharing happens when there are multiple
references to the same object in different places in the object hierarchy being
serialized.  <tt class="xref docutils literal"><span class="pre">pickle</span></tt> stores such objects only once, and ensures that all
other references point to the master copy.  Shared objects remain shared, which
can be very important for mutable objects.</p>
</li>
<li><p class="first"><a title="Convert Python objects to streams of bytes and back (with different constraints)." class="reference external" href="marshal.html"><tt class="xref docutils literal"><span class="pre">marshal</span></tt></a> cannot be used to serialize user-defined classes and their
instances.  <tt class="xref docutils literal"><span class="pre">pickle</span></tt> can save and restore class instances transparently,
however the class definition must be importable and live in the same module as
when the object was stored.</p>
</li>
<li><p class="first">The <a title="Convert Python objects to streams of bytes and back (with different constraints)." class="reference external" href="marshal.html"><tt class="xref docutils literal"><span class="pre">marshal</span></tt></a> serialization format is not guaranteed to be portable
across Python versions.  Because its primary job in life is to support
<tt class="docutils literal"><span class="pre">.pyc</span></tt> files, the Python implementers reserve the right to change the
serialization format in non-backwards compatible ways should the need arise.
The <tt class="xref docutils literal"><span class="pre">pickle</span></tt> serialization format is guaranteed to be backwards compatible
across Python releases.</p>
</li>
</ul>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The <tt class="xref docutils literal"><span class="pre">pickle</span></tt> module is not intended to be secure against erroneous or
maliciously constructed data.  Never unpickle data received from an untrusted or
unauthenticated source.</p>
</div>
<p>Note that serialization is a more primitive notion than persistence; although
<tt class="xref docutils literal"><span class="pre">pickle</span></tt> reads and writes file objects, it does not handle the issue of
naming persistent objects, nor the (even more complicated) issue of concurrent
access to persistent objects.  The <tt class="xref docutils literal"><span class="pre">pickle</span></tt> module can transform a complex
object into a byte stream and it can transform the byte stream into an object
with the same internal structure.  Perhaps the most obvious thing to do with
these byte streams is to write them onto a file, but it is also conceivable to
send them across a network or store them in a database.  The module
<a title="Python object persistence." class="reference external" href="shelve.html"><tt class="xref docutils literal"><span class="pre">shelve</span></tt></a> provides a simple interface to pickle and unpickle objects on
DBM-style database files.</p>
</div>
<div class="section" id="data-stream-format">
<h2>Data stream format<a class="headerlink" href="#data-stream-format" title="Permalink to this headline">¶</a></h2>
<p id="index-416">The data format used by <tt class="xref docutils literal"><span class="pre">pickle</span></tt> is Python-specific.  This has the
advantage that there are no restrictions imposed by external standards such as
XDR (which can&#8217;t represent pointer sharing); however it means that non-Python
programs may not be able to reconstruct pickled Python objects.</p>
<p>By default, the <tt class="xref docutils literal"><span class="pre">pickle</span></tt> data format uses a printable ASCII representation.
This is slightly more voluminous than a binary representation.  The big
advantage of using printable ASCII (and of some other characteristics of
<tt class="xref docutils literal"><span class="pre">pickle</span></tt>&#8216;s representation) is that for debugging or recovery purposes it is
possible for a human to read the pickled file with a standard text editor.</p>
<p>There are currently 4 different protocols which can be used for pickling.</p>
<ul class="simple">
<li>Protocol version 0 is the original ASCII protocol and is backwards compatible
with earlier versions of Python.</li>
<li>Protocol version 1 is the old binary format which is also compatible with
earlier versions of Python.</li>
<li>Protocol version 2 was introduced in Python 2.3.  It provides much more
efficient pickling of <a class="reference external" href="../glossary.html#term-new-style-class"><em class="xref">new-style class</em></a>es.</li>
<li>Protocol version 3 was added in Python 3.0.  It has explicit support for
bytes and cannot be unpickled by Python 2.x pickle modules.</li>
</ul>
<p>Refer to <span class="target" id="index-417"></span><a class="reference external" href="http://www.python.org/dev/peps/pep-0307"><strong>PEP 307</strong></a> for more information.</p>
<p>If a <em>protocol</em> is not specified, protocol 3 is used.  If <em>protocol</em> is
specified as a negative value or <a title="pickle.HIGHEST_PROTOCOL" class="reference internal" href="#pickle.HIGHEST_PROTOCOL"><tt class="xref docutils literal"><span class="pre">HIGHEST_PROTOCOL</span></tt></a>, the highest
protocol version available will be used.</p>
<p>A binary format, which is slightly more efficient, can be chosen by specifying a
<em>protocol</em> version &gt;= 1.</p>
</div>
<div class="section" id="usage">
<h2>Usage<a class="headerlink" href="#usage" title="Permalink to this headline">¶</a></h2>
<p>To serialize an object hierarchy, you first create a pickler, then you call the
pickler&#8217;s <a title="pickle.dump" class="reference internal" href="#pickle.dump"><tt class="xref docutils literal"><span class="pre">dump()</span></tt></a> method.  To de-serialize a data stream, you first create
an unpickler, then you call the unpickler&#8217;s <a title="pickle.load" class="reference internal" href="#pickle.load"><tt class="xref docutils literal"><span class="pre">load()</span></tt></a> method.  The
<tt class="xref docutils literal"><span class="pre">pickle</span></tt> module provides the following constant:</p>
<dl class="data">
<dt id="pickle.HIGHEST_PROTOCOL">
<!--[pickle.HIGHEST_PROTOCOL]--><tt class="descclassname">pickle.</tt><tt class="descname">HIGHEST_PROTOCOL</tt><a class="headerlink" href="#pickle.HIGHEST_PROTOCOL" title="Permalink to this definition">¶</a></dt>
<dd>The highest protocol version available.  This value can be passed as a
<em>protocol</em> value.</dd></dl>

<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Be sure to always open pickle files created with protocols &gt;= 1 in binary mode.
For the old ASCII-based pickle protocol 0 you can use either text mode or binary
mode as long as you stay consistent.</p>
<p class="last">A pickle file written with protocol 0 in binary mode will contain lone linefeeds
as line terminators and therefore will look &#8220;funny&#8221; when viewed in Notepad or
other editors which do not support this format.</p>
</div>
<p>The <tt class="xref docutils literal"><span class="pre">pickle</span></tt> module provides the following functions to make the pickling
process more convenient:</p>
<dl class="function">
<dt id="pickle.dump">
<!--[pickle.dump]--><tt class="descclassname">pickle.</tt><tt class="descname">dump</tt><big>(</big><em>obj</em>, <em>file</em><span class="optional">[</span>, <em>protocol</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#pickle.dump" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a pickled representation of <em>obj</em> to the open file object <em>file</em>.  This is
equivalent to <tt class="docutils literal"><span class="pre">Pickler(file,</span> <span class="pre">protocol).dump(obj)</span></tt>.</p>
<p>If the <em>protocol</em> parameter is omitted, protocol 3 is used.  If <em>protocol</em> is
specified as a negative value or <a title="pickle.HIGHEST_PROTOCOL" class="reference internal" href="#pickle.HIGHEST_PROTOCOL"><tt class="xref docutils literal"><span class="pre">HIGHEST_PROTOCOL</span></tt></a>, the highest
protocol version will be used.</p>
<p><em>file</em> must have a <tt class="xref docutils literal"><span class="pre">write()</span></tt> method that accepts a single string argument.
It can thus be a file object opened for writing, a <tt class="xref docutils literal"><span class="pre">StringIO</span></tt> object, or
any other custom object that meets this interface.</p>
</dd></dl>

<dl class="function">
<dt id="pickle.load">
<!--[pickle.load]--><tt class="descclassname">pickle.</tt><tt class="descname">load</tt><big>(</big><em>file</em><big>)</big><a class="headerlink" href="#pickle.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a string from the open file object <em>file</em> and interpret it as a pickle data
stream, reconstructing and returning the original object hierarchy.  This is
equivalent to <tt class="docutils literal"><span class="pre">Unpickler(file).load()</span></tt>.</p>
<p><em>file</em> must have two methods, a <tt class="xref docutils literal"><span class="pre">read()</span></tt> method that takes an integer
argument, and a <tt class="xref docutils literal"><span class="pre">readline()</span></tt> method that requires no arguments.  Both
methods should return a string.  Thus <em>file</em> can be a file object opened for
reading, a <tt class="xref docutils literal"><span class="pre">StringIO</span></tt> object, or any other custom object that meets this
interface.</p>
<p>This function automatically determines whether the data stream was written in
binary mode or not.</p>
</dd></dl>

<dl class="function">
<dt id="pickle.dumps">
<!--[pickle.dumps]--><tt class="descclassname">pickle.</tt><tt class="descname">dumps</tt><big>(</big><em>obj</em><span class="optional">[</span>, <em>protocol</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#pickle.dumps" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the pickled representation of the object as a <a title="bytes" class="reference external" href="functions.html#bytes"><tt class="xref docutils literal"><span class="pre">bytes</span></tt></a>
object, instead of writing it to a file.</p>
<p>If the <em>protocol</em> parameter is omitted, protocol 3 is used.  If <em>protocol</em>
is specified as a negative value or <a title="pickle.HIGHEST_PROTOCOL" class="reference internal" href="#pickle.HIGHEST_PROTOCOL"><tt class="xref docutils literal"><span class="pre">HIGHEST_PROTOCOL</span></tt></a>, the highest
protocol version will be used.</p>
</dd></dl>

<dl class="function">
<dt id="pickle.loads">
<!--[pickle.loads]--><tt class="descclassname">pickle.</tt><tt class="descname">loads</tt><big>(</big><em>bytes_object</em><big>)</big><a class="headerlink" href="#pickle.loads" title="Permalink to this definition">¶</a></dt>
<dd>Read a pickled object hierarchy from a <a title="bytes" class="reference external" href="functions.html#bytes"><tt class="xref docutils literal"><span class="pre">bytes</span></tt></a> object.
Bytes past the pickled object&#8217;s representation are ignored.</dd></dl>

<p>The <tt class="xref docutils literal"><span class="pre">pickle</span></tt> module also defines three exceptions:</p>
<dl class="exception">
<dt id="pickle.PickleError">
<!--[pickle.PickleError]-->exception <tt class="descclassname">pickle.</tt><tt class="descname">PickleError</tt><a class="headerlink" href="#pickle.PickleError" title="Permalink to this definition">¶</a></dt>
<dd>A common base class for the other exceptions defined below.  This inherits from
<a title="exceptions.Exception" class="reference external" href="exceptions.html#exceptions.Exception"><tt class="xref docutils literal"><span class="pre">Exception</span></tt></a>.</dd></dl>

<dl class="exception">
<dt id="pickle.PicklingError">
<!--[pickle.PicklingError]-->exception <tt class="descclassname">pickle.</tt><tt class="descname">PicklingError</tt><a class="headerlink" href="#pickle.PicklingError" title="Permalink to this definition">¶</a></dt>
<dd>This exception is raised when an unpicklable object is passed to the
<a title="pickle.dump" class="reference internal" href="#pickle.dump"><tt class="xref docutils literal"><span class="pre">dump()</span></tt></a> method.</dd></dl>

<dl class="exception">
<dt id="pickle.UnpicklingError">
<!--[pickle.UnpicklingError]-->exception <tt class="descclassname">pickle.</tt><tt class="descname">UnpicklingError</tt><a class="headerlink" href="#pickle.UnpicklingError" title="Permalink to this definition">¶</a></dt>
<dd>This exception is raised when there is a problem unpickling an object. Note that
other exceptions may also be raised during unpickling, including (but not
necessarily limited to) <a title="exceptions.AttributeError" class="reference external" href="exceptions.html#exceptions.AttributeError"><tt class="xref docutils literal"><span class="pre">AttributeError</span></tt></a>, <a title="exceptions.EOFError" class="reference external" href="exceptions.html#exceptions.EOFError"><tt class="xref docutils literal"><span class="pre">EOFError</span></tt></a>,
<a title="exceptions.ImportError" class="reference external" href="exceptions.html#exceptions.ImportError"><tt class="xref docutils literal"><span class="pre">ImportError</span></tt></a>, and <a title="exceptions.IndexError" class="reference external" href="exceptions.html#exceptions.IndexError"><tt class="xref docutils literal"><span class="pre">IndexError</span></tt></a>.</dd></dl>

<p>The <tt class="xref docutils literal"><span class="pre">pickle</span></tt> module also exports two callables, <a title="pickle.Pickler" class="reference internal" href="#pickle.Pickler"><tt class="xref docutils literal"><span class="pre">Pickler</span></tt></a> and
<a title="pickle.Unpickler" class="reference internal" href="#pickle.Unpickler"><tt class="xref docutils literal"><span class="pre">Unpickler</span></tt></a>:</p>
<dl class="class">
<dt id="pickle.Pickler">
<!--[pickle.Pickler]-->class <tt class="descclassname">pickle.</tt><tt class="descname">Pickler</tt><big>(</big><em>file</em><span class="optional">[</span>, <em>protocol</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#pickle.Pickler" title="Permalink to this definition">¶</a></dt>
<dd><p>This takes a file-like object to which it will write a pickle data stream.</p>
<p>If the <em>protocol</em> parameter is omitted, protocol 3 is used.  If <em>protocol</em> is
specified as a negative value or <a title="pickle.HIGHEST_PROTOCOL" class="reference internal" href="#pickle.HIGHEST_PROTOCOL"><tt class="xref docutils literal"><span class="pre">HIGHEST_PROTOCOL</span></tt></a>, the highest
protocol version will be used.</p>
<p><em>file</em> must have a <tt class="xref docutils literal"><span class="pre">write()</span></tt> method that accepts a single string argument.
It can thus be an open file object, a <tt class="xref docutils literal"><span class="pre">StringIO</span></tt> object, or any other
custom object that meets this interface.</p>
<p><a title="pickle.Pickler" class="reference internal" href="#pickle.Pickler"><tt class="xref docutils literal"><span class="pre">Pickler</span></tt></a> objects define one (or two) public methods:</p>
<dl class="method">
<dt id="pickle.Pickler.dump">
<!--[pickle.Pickler.dump]--><tt class="descname">dump</tt><big>(</big><em>obj</em><big>)</big><a class="headerlink" href="#pickle.Pickler.dump" title="Permalink to this definition">¶</a></dt>
<dd>Write a pickled representation of <em>obj</em> to the open file object given in the
constructor.  Either the binary or ASCII format will be used, depending on the
value of the <em>protocol</em> argument passed to the constructor.</dd></dl>

<dl class="method">
<dt id="pickle.Pickler.clear_memo">
<!--[pickle.Pickler.clear_memo]--><tt class="descname">clear_memo</tt><big>(</big><big>)</big><a class="headerlink" href="#pickle.Pickler.clear_memo" title="Permalink to this definition">¶</a></dt>
<dd>Clears the pickler&#8217;s &#8220;memo&#8221;.  The memo is the data structure that remembers
which objects the pickler has already seen, so that shared or recursive objects
pickled by reference and not by value.  This method is useful when re-using
picklers.</dd></dl>

</dd></dl>

<p>It is possible to make multiple calls to the <a title="pickle.dump" class="reference internal" href="#pickle.dump"><tt class="xref docutils literal"><span class="pre">dump()</span></tt></a> method of the same
<a title="pickle.Pickler" class="reference internal" href="#pickle.Pickler"><tt class="xref docutils literal"><span class="pre">Pickler</span></tt></a> instance.  These must then be matched to the same number of
calls to the <a title="pickle.load" class="reference internal" href="#pickle.load"><tt class="xref docutils literal"><span class="pre">load()</span></tt></a> method of the corresponding <a title="pickle.Unpickler" class="reference internal" href="#pickle.Unpickler"><tt class="xref docutils literal"><span class="pre">Unpickler</span></tt></a>
instance.  If the same object is pickled by multiple <a title="pickle.dump" class="reference internal" href="#pickle.dump"><tt class="xref docutils literal"><span class="pre">dump()</span></tt></a> calls, the
<a title="pickle.load" class="reference internal" href="#pickle.load"><tt class="xref docutils literal"><span class="pre">load()</span></tt></a> will all yield references to the same object. <a class="footnote-reference" href="#id7" id="id2">[2]</a></p>
<p><a title="pickle.Unpickler" class="reference internal" href="#pickle.Unpickler"><tt class="xref docutils literal"><span class="pre">Unpickler</span></tt></a> objects are defined as:</p>
<dl class="class">
<dt id="pickle.Unpickler">
<!--[pickle.Unpickler]-->class <tt class="descclassname">pickle.</tt><tt class="descname">Unpickler</tt><big>(</big><em>file</em><big>)</big><a class="headerlink" href="#pickle.Unpickler" title="Permalink to this definition">¶</a></dt>
<dd><p>This takes a file-like object from which it will read a pickle data stream.
This class automatically determines whether the data stream was written in
binary mode or not, so it does not need a flag as in the <a title="pickle.Pickler" class="reference internal" href="#pickle.Pickler"><tt class="xref docutils literal"><span class="pre">Pickler</span></tt></a>
factory.</p>
<p><em>file</em> must have two methods, a <tt class="xref docutils literal"><span class="pre">read()</span></tt> method that takes an integer
argument, and a <tt class="xref docutils literal"><span class="pre">readline()</span></tt> method that requires no arguments.  Both
methods should return a string.  Thus <em>file</em> can be a file object opened for
reading, a <tt class="xref docutils literal"><span class="pre">StringIO</span></tt> object, or any other custom object that meets this
interface.</p>
<p><a title="pickle.Unpickler" class="reference internal" href="#pickle.Unpickler"><tt class="xref docutils literal"><span class="pre">Unpickler</span></tt></a> objects have one (or two) public methods:</p>
<dl class="method">
<dt id="pickle.Unpickler.load">
<!--[pickle.Unpickler.load]--><tt class="descname">load</tt><big>(</big><big>)</big><a class="headerlink" href="#pickle.Unpickler.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a pickled object representation from the open file object given in
the constructor, and return the reconstituted object hierarchy specified
therein.</p>
<p>This method automatically determines whether the data stream was written
in binary mode or not.</p>
</dd></dl>

<dl class="method">
<dt id="pickle.Unpickler.noload">
<!--[pickle.Unpickler.noload]--><tt class="descname">noload</tt><big>(</big><big>)</big><a class="headerlink" href="#pickle.Unpickler.noload" title="Permalink to this definition">¶</a></dt>
<dd>This is just like <a title="pickle.load" class="reference internal" href="#pickle.load"><tt class="xref docutils literal"><span class="pre">load()</span></tt></a> except that it doesn&#8217;t actually create any
objects.  This is useful primarily for finding what&#8217;s called &#8220;persistent
ids&#8221; that may be referenced in a pickle data stream.  See section
<a class="reference internal" href="#pickle-protocol"><em>The pickle protocol</em></a> below for more details.</dd></dl>

</dd></dl>

</div>
<div class="section" id="what-can-be-pickled-and-unpickled">
<h2>What can be pickled and unpickled?<a class="headerlink" href="#what-can-be-pickled-and-unpickled" title="Permalink to this headline">¶</a></h2>
<p>The following types can be pickled:</p>
<ul class="simple">
<li><tt class="xref docutils literal"><span class="pre">None</span></tt>, <tt class="xref docutils literal"><span class="pre">True</span></tt>, and <tt class="xref docutils literal"><span class="pre">False</span></tt></li>
<li>integers, floating point numbers, complex numbers</li>
<li>strings, bytes, bytearrays</li>
<li>tuples, lists, sets, and dictionaries containing only picklable objects</li>
<li>functions defined at the top level of a module</li>
<li>built-in functions defined at the top level of a module</li>
<li>classes that are defined at the top level of a module</li>
<li>instances of such classes whose <tt class="xref docutils literal"><span class="pre">__dict__</span></tt> or <tt class="xref docutils literal"><span class="pre">__setstate__()</span></tt> is
picklable  (see section <a class="reference internal" href="#pickle-protocol"><em>The pickle protocol</em></a> for details)</li>
</ul>
<p>Attempts to pickle unpicklable objects will raise the <a title="pickle.PicklingError" class="reference internal" href="#pickle.PicklingError"><tt class="xref docutils literal"><span class="pre">PicklingError</span></tt></a>
exception; when this happens, an unspecified number of bytes may have already
been written to the underlying file. Trying to pickle a highly recursive data
structure may exceed the maximum recursion depth, a <a title="exceptions.RuntimeError" class="reference external" href="exceptions.html#exceptions.RuntimeError"><tt class="xref docutils literal"><span class="pre">RuntimeError</span></tt></a> will be
raised in this case. You can carefully raise this limit with
<a title="sys.setrecursionlimit" class="reference external" href="sys.html#sys.setrecursionlimit"><tt class="xref docutils literal"><span class="pre">sys.setrecursionlimit()</span></tt></a>.</p>
<p>Note that functions (built-in and user-defined) are pickled by &#8220;fully qualified&#8221;
name reference, not by value.  This means that only the function name is
pickled, along with the name of module the function is defined in.  Neither the
function&#8217;s code, nor any of its function attributes are pickled.  Thus the
defining module must be importable in the unpickling environment, and the module
must contain the named object, otherwise an exception will be raised. <a class="footnote-reference" href="#id8" id="id3">[3]</a></p>
<p>Similarly, classes are pickled by named reference, so the same restrictions in
the unpickling environment apply.  Note that none of the class&#8217;s code or data is
pickled, so in the following example the class attribute <tt class="docutils literal"><span class="pre">attr</span></tt> is not
restored in the unpickling environment:</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Foo</span><span class="p">:</span>
    <span class="n">attr</span> <span class="o">=</span> <span class="s">&#39;a class attr&#39;</span>

<span class="n">picklestring</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">Foo</span><span class="p">)</span>
</pre></div>
<p>These restrictions are why picklable functions and classes must be defined in
the top level of a module.</p>
<p>Similarly, when class instances are pickled, their class&#8217;s code and data are not
pickled along with them.  Only the instance data are pickled.  This is done on
purpose, so you can fix bugs in a class or add methods to the class and still
load objects that were created with an earlier version of the class.  If you
plan to have long-lived objects that will see many versions of a class, it may
be worthwhile to put a version number in the objects so that suitable
conversions can be made by the class&#8217;s <tt class="xref docutils literal"><span class="pre">__setstate__()</span></tt> method.</p>
</div>
<div class="section" id="the-pickle-protocol">
<span id="pickle-protocol"></span><h2>The pickle protocol<a class="headerlink" href="#the-pickle-protocol" title="Permalink to this headline">¶</a></h2>
<p>This section describes the &#8220;pickling protocol&#8221; that defines the interface
between the pickler/unpickler and the objects that are being serialized.  This
protocol provides a standard way for you to define, customize, and control how
your objects are serialized and de-serialized.  The description in this section
doesn&#8217;t cover specific customizations that you can employ to make the unpickling
environment slightly safer from untrusted pickle data streams; see section
<a class="reference internal" href="#pickle-sub"><em>Subclassing Unpicklers</em></a> for more details.</p>
<div class="section" id="pickling-and-unpickling-normal-class-instances">
<span id="pickle-inst"></span><h3>Pickling and unpickling normal class instances<a class="headerlink" href="#pickling-and-unpickling-normal-class-instances" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-418"></span><p>When a pickled class instance is unpickled, its <a title="object.__init__" class="reference external" href="../reference/datamodel.html#object.__init__"><tt class="xref docutils literal"><span class="pre">__init__()</span></tt></a> method is
normally <em>not</em> invoked.  If it is desirable that the <a title="object.__init__" class="reference external" href="../reference/datamodel.html#object.__init__"><tt class="xref docutils literal"><span class="pre">__init__()</span></tt></a> method be
called on unpickling, an old-style class can define a method
<tt class="xref docutils literal"><span class="pre">__getinitargs__()</span></tt>, which should return a <em>tuple</em> containing the arguments
to be passed to the class constructor (<a title="object.__init__" class="reference external" href="../reference/datamodel.html#object.__init__"><tt class="xref docutils literal"><span class="pre">__init__()</span></tt></a> for example).  The
<tt class="xref docutils literal"><span class="pre">__getinitargs__()</span></tt> method is called at pickle time; the tuple it returns is
incorporated in the pickle for the instance.</p>
<p id="index-419">New-style types can provide a <tt class="xref docutils literal"><span class="pre">__getnewargs__()</span></tt> method that is used for
protocol 2.  Implementing this method is needed if the type establishes some
internal invariants when the instance is created, or if the memory allocation is
affected by the values passed to the <a title="object.__new__" class="reference external" href="../reference/datamodel.html#object.__new__"><tt class="xref docutils literal"><span class="pre">__new__()</span></tt></a> method for the type (as it
is for tuples and strings).  Instances of a <a class="reference external" href="../glossary.html#term-new-style-class"><em class="xref">new-style class</em></a> <tt class="xref docutils literal"><span class="pre">C</span></tt>
are created using</p>
<pre>obj = C.__new__(C, *args)</pre>
<p>where <em>args</em> is the result of calling <tt class="xref docutils literal"><span class="pre">__getnewargs__()</span></tt> on the original
object; if there is no <tt class="xref docutils literal"><span class="pre">__getnewargs__()</span></tt>, an empty tuple is assumed.</p>
<p id="index-420">Classes can further influence how their instances are pickled; if the class
defines the method <tt class="xref docutils literal"><span class="pre">__getstate__()</span></tt>, it is called and the return state is
pickled as the contents for the instance, instead of the contents of the
instance&#8217;s dictionary.  If there is no <tt class="xref docutils literal"><span class="pre">__getstate__()</span></tt> method, the
instance&#8217;s <tt class="xref docutils literal"><span class="pre">__dict__</span></tt> is pickled.</p>
<p>Upon unpickling, if the class also defines the method <tt class="xref docutils literal"><span class="pre">__setstate__()</span></tt>, it
is called with the unpickled state. <a class="footnote-reference" href="#id9" id="id4">[4]</a>  If there is no <tt class="xref docutils literal"><span class="pre">__setstate__()</span></tt>
method, the pickled state must be a dictionary and its items are assigned to the
new instance&#8217;s dictionary.  If a class defines both <tt class="xref docutils literal"><span class="pre">__getstate__()</span></tt> and
<tt class="xref docutils literal"><span class="pre">__setstate__()</span></tt>, the state object needn&#8217;t be a dictionary and these methods
can do what they want. <a class="footnote-reference" href="#id10" id="id5">[5]</a></p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">If <tt class="xref docutils literal"><span class="pre">__getstate__()</span></tt> returns a false value, the <tt class="xref docutils literal"><span class="pre">__setstate__()</span></tt>
method will not be called.</p>
</div>
</div>
<div class="section" id="pickling-and-unpickling-extension-types">
<h3>Pickling and unpickling extension types<a class="headerlink" href="#pickling-and-unpickling-extension-types" title="Permalink to this headline">¶</a></h3>
<p id="index-421">When the <a title="pickle.Pickler" class="reference internal" href="#pickle.Pickler"><tt class="xref docutils literal"><span class="pre">Pickler</span></tt></a> encounters an object of a type it knows nothing about
&#8212; such as an extension type &#8212; it looks in two places for a hint of how to
pickle it.  One alternative is for the object to implement a <tt class="xref docutils literal"><span class="pre">__reduce__()</span></tt>
method.  If provided, at pickling time <tt class="xref docutils literal"><span class="pre">__reduce__()</span></tt> will be called with no
arguments, and it must return either a string or a tuple.</p>
<p>If a string is returned, it names a global variable whose contents are pickled
as normal.  The string returned by <tt class="xref docutils literal"><span class="pre">__reduce__()</span></tt> should be the object&#8217;s
local name relative to its module; the pickle module searches the module
namespace to determine the object&#8217;s module.</p>
<p>When a tuple is returned, it must be between two and five elements long.
Optional elements can either be omitted, or <tt class="xref docutils literal"><span class="pre">None</span></tt> can be provided as their
value.  The contents of this tuple are pickled as normal and used to
reconstruct the object at unpickling time.  The semantics of each element are:</p>
<ul>
<li><p class="first">A callable object that will be called to create the initial version of the
object.  The next element of the tuple will provide arguments for this callable,
and later elements provide additional state information that will subsequently
be used to fully reconstruct the pickled data.</p>
<p>In the unpickling environment this object must be either a class, a callable
registered as a &#8220;safe constructor&#8221; (see below), or it must have an attribute
<tt class="xref docutils literal"><span class="pre">__safe_for_unpickling__</span></tt> with a true value. Otherwise, an
<a title="pickle.UnpicklingError" class="reference internal" href="#pickle.UnpicklingError"><tt class="xref docutils literal"><span class="pre">UnpicklingError</span></tt></a> will be raised in the unpickling environment.  Note that
as usual, the callable itself is pickled by name.</p>
</li>
<li><p class="first">A tuple of arguments for the callable object, not <tt class="xref docutils literal"><span class="pre">None</span></tt>.</p>
</li>
<li><p class="first">Optionally, the object&#8217;s state, which will be passed to the object&#8217;s
<tt class="xref docutils literal"><span class="pre">__setstate__()</span></tt> method as described in section <a class="reference internal" href="#pickle-inst"><em>Pickling and unpickling normal class instances</em></a>.  If the
object has no <tt class="xref docutils literal"><span class="pre">__setstate__()</span></tt> method, then, as above, the value must be a
dictionary and it will be added to the object&#8217;s <tt class="xref docutils literal"><span class="pre">__dict__</span></tt>.</p>
</li>
<li><p class="first">Optionally, an iterator (and not a sequence) yielding successive list items.
These list items will be pickled, and appended to the object using either
<tt class="docutils literal"><span class="pre">obj.append(item)</span></tt> or <tt class="docutils literal"><span class="pre">obj.extend(list_of_items)</span></tt>.  This is primarily used
for list subclasses, but may be used by other classes as long as they have
<tt class="xref docutils literal"><span class="pre">append()</span></tt> and <tt class="xref docutils literal"><span class="pre">extend()</span></tt> methods with the appropriate signature.
(Whether <tt class="xref docutils literal"><span class="pre">append()</span></tt> or <tt class="xref docutils literal"><span class="pre">extend()</span></tt> is used depends on which pickle
protocol version is used as well as the number of items to append, so both must
be supported.)</p>
</li>
<li><p class="first">Optionally, an iterator (not a sequence) yielding successive dictionary items,
which should be tuples of the form <tt class="docutils literal"><span class="pre">(key,</span> <span class="pre">value)</span></tt>.  These items will be
pickled and stored to the object using <tt class="docutils literal"><span class="pre">obj[key]</span> <span class="pre">=</span> <span class="pre">value</span></tt>. This is primarily
used for dictionary subclasses, but may be used by other classes as long as they
implement <a title="object.__setitem__" class="reference external" href="../reference/datamodel.html#object.__setitem__"><tt class="xref docutils literal"><span class="pre">__setitem__()</span></tt></a>.</p>
</li>
</ul>
<p>It is sometimes useful to know the protocol version when implementing
<tt class="xref docutils literal"><span class="pre">__reduce__()</span></tt>.  This can be done by implementing a method named
<tt class="xref docutils literal"><span class="pre">__reduce_ex__()</span></tt> instead of <tt class="xref docutils literal"><span class="pre">__reduce__()</span></tt>. <tt class="xref docutils literal"><span class="pre">__reduce_ex__()</span></tt>, when
it exists, is called in preference over <tt class="xref docutils literal"><span class="pre">__reduce__()</span></tt> (you may still
provide <tt class="xref docutils literal"><span class="pre">__reduce__()</span></tt> for backwards compatibility).  The
<tt class="xref docutils literal"><span class="pre">__reduce_ex__()</span></tt> method will be called with a single integer argument, the
protocol version.</p>
<p>The <a title="object" class="reference external" href="functions.html#object"><tt class="xref docutils literal"><span class="pre">object</span></tt></a> class implements both <tt class="xref docutils literal"><span class="pre">__reduce__()</span></tt> and
<tt class="xref docutils literal"><span class="pre">__reduce_ex__()</span></tt>; however, if a subclass overrides <tt class="xref docutils literal"><span class="pre">__reduce__()</span></tt> but
not <tt class="xref docutils literal"><span class="pre">__reduce_ex__()</span></tt>, the <tt class="xref docutils literal"><span class="pre">__reduce_ex__()</span></tt> implementation detects this
and calls <tt class="xref docutils literal"><span class="pre">__reduce__()</span></tt>.</p>
<p>An alternative to implementing a <tt class="xref docutils literal"><span class="pre">__reduce__()</span></tt> method on the object to be
pickled, is to register the callable with the <a title="Register pickle support functions." class="reference external" href="copyreg.html"><tt class="xref docutils literal"><span class="pre">copyreg</span></tt></a> module.  This
module provides a way for programs to register &#8220;reduction functions&#8221; and
constructors for user-defined types.   Reduction functions have the same
semantics and interface as the <tt class="xref docutils literal"><span class="pre">__reduce__()</span></tt> method described above, except
that they are called with a single argument, the object to be pickled.</p>
<p>The registered constructor is deemed a &#8220;safe constructor&#8221; for purposes of
unpickling as described above.</p>
</div>
<div class="section" id="pickling-and-unpickling-external-objects">
<h3>Pickling and unpickling external objects<a class="headerlink" href="#pickling-and-unpickling-external-objects" title="Permalink to this headline">¶</a></h3>
<p id="index-422">For the benefit of object persistence, the <tt class="xref docutils literal"><span class="pre">pickle</span></tt> module supports the
notion of a reference to an object outside the pickled data stream.  Such
objects are referenced by a &#8220;persistent id&#8221;, which is just an arbitrary string
of printable ASCII characters. The resolution of such names is not defined by
the <tt class="xref docutils literal"><span class="pre">pickle</span></tt> module; it will delegate this resolution to user defined
functions on the pickler and unpickler.</p>
<p>To define external persistent id resolution, you need to set the
<tt class="xref docutils literal"><span class="pre">persistent_id</span></tt> attribute of the pickler object and the
<tt class="xref docutils literal"><span class="pre">persistent_load</span></tt> attribute of the unpickler object.</p>
<p>To pickle objects that have an external persistent id, the pickler must have a
custom <tt class="xref docutils literal"><span class="pre">persistent_id()</span></tt> method that takes an object as an argument and
returns either <tt class="xref docutils literal"><span class="pre">None</span></tt> or the persistent id for that object.  When <tt class="xref docutils literal"><span class="pre">None</span></tt> is
returned, the pickler simply pickles the object as normal.  When a persistent id
string is returned, the pickler will pickle that string, along with a marker so
that the unpickler will recognize the string as a persistent id.</p>
<p>To unpickle external objects, the unpickler must have a custom
<tt class="xref docutils literal"><span class="pre">persistent_load()</span></tt> function that takes a persistent id string and returns
the referenced object.</p>
<p>Here&#8217;s a silly example that <em>might</em> shed more light:</p>
<pre>import pickle
from io import StringIO

src = StringIO()
p = pickle.Pickler(src)

def persistent_id(obj):
    if hasattr(obj, 'x'):
        return 'the value %d' % obj.x
    else:
        return None

p.persistent_id = persistent_id

class Integer:
    def __init__(self, x):
        self.x = x
    def __str__(self):
        return 'My name is integer %d' % self.x

i = Integer(7)
print(i)
p.dump(i)

datastream = src.getvalue()
print(repr(datastream))
dst = StringIO(datastream)

up = pickle.Unpickler(dst)

class FancyInteger(Integer):
    def __str__(self):
        return 'I am the integer %d' % self.x

def persistent_load(persid):
    if persid.startswith('the value '):
        value = int(persid.split()[2])
        return FancyInteger(value)
    else:
        raise pickle.UnpicklingError('Invalid persistent id')

up.persistent_load = persistent_load

j = up.load()
print(j)</pre>
</div>
</div>
<div class="section" id="subclassing-unpicklers">
<span id="pickle-sub"></span><h2>Subclassing Unpicklers<a class="headerlink" href="#subclassing-unpicklers" title="Permalink to this headline">¶</a></h2>
<p id="index-423">By default, unpickling will import any class that it finds in the pickle data.
You can control exactly what gets unpickled and what gets called by customizing
your unpickler.</p>
<p>You need to derive a subclass from <a title="pickle.Unpickler" class="reference internal" href="#pickle.Unpickler"><tt class="xref docutils literal"><span class="pre">Unpickler</span></tt></a>, overriding the
<tt class="xref docutils literal"><span class="pre">load_global()</span></tt> method.  <tt class="xref docutils literal"><span class="pre">load_global()</span></tt> should read two lines from the
pickle data stream where the first line will the name of the module containing
the class and the second line will be the name of the instance&#8217;s class.  It then
looks up the class, possibly importing the module and digging out the attribute,
then it appends what it finds to the unpickler&#8217;s stack.  Later on, this class
will be assigned to the <tt class="xref docutils literal"><span class="pre">__class__</span></tt> attribute of an empty class, as a way
of magically creating an instance without calling its class&#8217;s
<a title="object.__init__" class="reference external" href="../reference/datamodel.html#object.__init__"><tt class="xref docutils literal"><span class="pre">__init__()</span></tt></a>. Your job (should you choose to accept it), would be to have
<tt class="xref docutils literal"><span class="pre">load_global()</span></tt> push onto the unpickler&#8217;s stack, a known safe version of any
class you deem safe to unpickle.  It is up to you to produce such a class.  Or
you could raise an error if you want to disallow all unpickling of instances.
If this sounds like a hack, you&#8217;re right.  Refer to the source code to make this
work.</p>
<p>The moral of the story is that you should be really careful about the source of
the strings your application unpickles.</p>
</div>
<div class="section" id="example">
<span id="pickle-example"></span><h2>Example<a class="headerlink" href="#example" title="Permalink to this headline">¶</a></h2>
<p>For the simplest code, use the <a title="pickle.dump" class="reference internal" href="#pickle.dump"><tt class="xref docutils literal"><span class="pre">dump()</span></tt></a> and <a title="pickle.load" class="reference internal" href="#pickle.load"><tt class="xref docutils literal"><span class="pre">load()</span></tt></a> functions.  Note
that a self-referencing list is pickled and restored correctly.</p>
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">pickle</span>

<span class="n">data1</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;a&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="o">+</span><span class="mi">6</span><span class="n">j</span><span class="p">],</span>
         <span class="s">&#39;b&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s">&quot;string&quot;</span><span class="p">,</span> <span class="s">&quot;string using Unicode features </span><span class="se">\u0394</span><span class="s">&quot;</span><span class="p">),</span>
         <span class="s">&#39;c&#39;</span><span class="p">:</span> <span class="k">None</span><span class="p">}</span>

<span class="n">selfref_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="n">selfref_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">selfref_list</span><span class="p">)</span>

<span class="n">output</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">&#39;data.pkl&#39;</span><span class="p">,</span> <span class="s">&#39;wb&#39;</span><span class="p">)</span>

<span class="c"># Pickle dictionary using protocol 2.</span>
<span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">data1</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

<span class="c"># Pickle the list using the highest protocol available.</span>
<span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">selfref_list</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

<span class="n">output</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
<p>The following example reads the resulting pickled data.  When reading a
pickle-containing file, you should open the file in binary mode because you
can&#8217;t be sure if the ASCII or binary format was used.</p>
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">pprint</span><span class="o">,</span> <span class="nn">pickle</span>

<span class="n">pkl_file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">&#39;data.pkl&#39;</span><span class="p">,</span> <span class="s">&#39;rb&#39;</span><span class="p">)</span>

<span class="n">data1</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">pkl_file</span><span class="p">)</span>
<span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="n">data1</span><span class="p">)</span>

<span class="n">data2</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">pkl_file</span><span class="p">)</span>
<span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="n">data2</span><span class="p">)</span>

<span class="n">pkl_file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
<p>Here&#8217;s a larger example that shows how to modify pickling behavior for a class.
The <tt class="xref docutils literal"><span class="pre">TextReader</span></tt> class opens a text file, and returns the line number and
line contents each time its <tt class="xref docutils literal"><span class="pre">readline()</span></tt> method is called. If a
<tt class="xref docutils literal"><span class="pre">TextReader</span></tt> instance is pickled, all attributes <em>except</em> the file object
member are saved. When the instance is unpickled, the file is reopened, and
reading resumes from the last location. The <tt class="xref docutils literal"><span class="pre">__setstate__()</span></tt> and
<tt class="xref docutils literal"><span class="pre">__getstate__()</span></tt> methods are used to implement this behavior.</p>
<pre>#!/usr/local/bin/python

class TextReader:
    """Print and number lines in a text file."""
    def __init__(self, file):
        self.file = file
        self.fh = open(file)
        self.lineno = 0

    def readline(self):
        self.lineno = self.lineno + 1
        line = self.fh.readline()
        if not line:
            return None
        if line.endswith("\n"):
            line = line[:-1]
        return "%d: %s" % (self.lineno, line)

    def __getstate__(self):
        odict = self.__dict__.copy() # copy the dict since we change it
        del odict['fh']              # remove filehandle entry
        return odict

    def __setstate__(self, dict):
        fh = open(dict['file'])      # reopen file
        count = dict['lineno']       # read from file...
        while count:                 # until line count is restored
            fh.readline()
            count = count - 1
        self.__dict__.update(dict)   # update attributes
        self.fh = fh                 # save the file object</pre>
<p>A sample usage might be something like this:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">TextReader</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span> <span class="o">=</span> <span class="n">TextReader</span><span class="o">.</span><span class="n">TextReader</span><span class="p">(</span><span class="s">&quot;TextReader.py&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
<span class="go">&#39;1: #!/usr/local/bin/python&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
<span class="go">&#39;2: &#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
<span class="go">&#39;3: class TextReader:&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pickle</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">open</span><span class="p">(</span><span class="s">&#39;save.p&#39;</span><span class="p">,</span> <span class="s">&#39;wb&#39;</span><span class="p">))</span>
</pre></div>
<p>If you want to see that <tt class="xref docutils literal"><span class="pre">pickle</span></tt> works across Python processes, start
another Python session, before continuing.  What follows can happen from either
the same process or a new process.</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pickle</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reader</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="s">&#39;save.p&#39;</span><span class="p">,</span> <span class="s">&#39;rb&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reader</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
<span class="go">&#39;4:     &quot;&quot;&quot;Print and number lines in a text file.&quot;&quot;&quot;&#39;</span>
</pre></div>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt>Module <a title="Register pickle support functions." class="reference external" href="copyreg.html"><tt class="xref docutils literal"><span class="pre">copyreg</span></tt></a></dt>
<dd>Pickle interface constructor registration for extension types.</dd>
<dt>Module <a title="Python object persistence." class="reference external" href="shelve.html"><tt class="xref docutils literal"><span class="pre">shelve</span></tt></a></dt>
<dd>Indexed databases of objects; uses <tt class="xref docutils literal"><span class="pre">pickle</span></tt>.</dd>
<dt>Module <a title="Shallow and deep copy operations." class="reference external" href="copy.html"><tt class="xref docutils literal"><span class="pre">copy</span></tt></a></dt>
<dd>Shallow and deep object copying.</dd>
<dt>Module <a title="Convert Python objects to streams of bytes and back (with different constraints)." class="reference external" href="marshal.html"><tt class="xref docutils literal"><span class="pre">marshal</span></tt></a></dt>
<dd>High-performance serialization of built-in types.</dd>
</dl>
</div>
<p class="rubric">Footnotes</p>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Don&#8217;t confuse this with the <a title="Convert Python objects to streams of bytes and back (with different constraints)." class="reference external" href="marshal.html"><tt class="xref docutils literal"><span class="pre">marshal</span></tt></a> module</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td><em>Warning</em>: this is intended for pickling multiple objects without intervening
modifications to the objects or their parts.  If you modify an object and then
pickle it again using the same <a title="pickle.Pickler" class="reference internal" href="#pickle.Pickler"><tt class="xref docutils literal"><span class="pre">Pickler</span></tt></a> instance, the object is not
pickled again &#8212; a reference to it is pickled and the <a title="pickle.Unpickler" class="reference internal" href="#pickle.Unpickler"><tt class="xref docutils literal"><span class="pre">Unpickler</span></tt></a> will
return the old value, not the modified one. There are two problems here: (1)
detecting changes, and (2) marshalling a minimal set of changes.  Garbage
Collection may also become a problem here.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td>The exception raised will likely be an <a title="exceptions.ImportError" class="reference external" href="exceptions.html#exceptions.ImportError"><tt class="xref docutils literal"><span class="pre">ImportError</span></tt></a> or an
<a title="exceptions.AttributeError" class="reference external" href="exceptions.html#exceptions.AttributeError"><tt class="xref docutils literal"><span class="pre">AttributeError</span></tt></a> but it could be something else.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id9" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[4]</a></td><td>These methods can also be used to implement copying class instances.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[5]</a></td><td>This protocol is also used by the shallow and deep copying operations defined in
the <a title="Shallow and deep copy operations." class="reference external" href="copy.html"><tt class="xref docutils literal"><span class="pre">copy</span></tt></a> module.</td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <h3><a href="../contents.html">Table Of Contents</a></h3>
            <ul>
<li><a class="reference external" href=""><tt class="docutils literal"><span class="pre">pickle</span></tt> &#8212; Python object serialization</a><ul>
<li><a class="reference external" href="#relationship-to-other-python-modules">Relationship to other Python modules</a></li>
<li><a class="reference external" href="#data-stream-format">Data stream format</a></li>
<li><a class="reference external" href="#usage">Usage</a></li>
<li><a class="reference external" href="#what-can-be-pickled-and-unpickled">What can be pickled and unpickled?</a></li>
<li><a class="reference external" href="#the-pickle-protocol">The pickle protocol</a><ul>
<li><a class="reference external" href="#pickling-and-unpickling-normal-class-instances">Pickling and unpickling normal class instances</a></li>
<li><a class="reference external" href="#pickling-and-unpickling-extension-types">Pickling and unpickling extension types</a></li>
<li><a class="reference external" href="#pickling-and-unpickling-external-objects">Pickling and unpickling external objects</a></li>
</ul>
</li>
<li><a class="reference external" href="#subclassing-unpicklers">Subclassing Unpicklers</a></li>
<li><a class="reference external" href="#example">Example</a></li>
</ul>
</li>
</ul>

            <h4>Previous topic</h4>
            <p class="topless"><a href="persistence.html" title="previous chapter">Data Persistence</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="copyreg.html" title="next chapter"><tt class="docutils literal docutils literal"><span class="pre">copyreg</span></tt> &#8212; Register <tt class="docutils literal docutils literal"><span class="pre">pickle</span></tt> support functions</a></p>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="../_sources/library/pickle.txt">Show Source</a></li>
            </ul>
          <h3>Quick search</h3>
            <form class="search" action="../search.html" method="get">
              <input type="text" name="q" size="18" /> <input type="submit" value="Go" />
              <input type="hidden" name="check_keywords" value="yes" />
              <input type="hidden" name="area" value="default" />
            </form>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../modindex.html" title="Global Module Index"
             accesskey="M">modules</a> |</li>
        <li class="right" >
          <a href="copyreg.html" title="copyreg &#8212; Register pickle support functions"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="persistence.html" title="Data Persistence"
             accesskey="P">previous</a> |</li>
<li><img src="../_static/py.png" alt="" style="vertical-align: middle; margin-top: -1px"/></li>

        <li><a href="../contents.html">Python v3.0c1 documentation</a> &raquo;</li>

          <li><a href="index.html" accesskey="U">The Python Standard Library</a> &raquo;</li>
          <li><a href="persistence.html" accesskey="U">Data Persistence</a> &raquo;</li>
      </ul>
    </div>
    <div class="footer">
      &copy; <a href="../copyright.html">Copyright</a> 1990-2008, Python Software Foundation.
      Last updated on Oct 31, 2008.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 0.5.
    </div>
  </body>
</html>