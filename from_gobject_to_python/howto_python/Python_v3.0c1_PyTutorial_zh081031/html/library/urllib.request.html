<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>urllib.request &#8212; extensible library for opening URLs &mdash; Python v3.0c1 documentation</title>
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
          URL_ROOT:    '../',
          VERSION:     '3.0c1',
          COLLAPSE_MODINDEX: false,
          FILE_SUFFIX: '.html'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Python v3.0c1 documentation"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="Python v3.0c1 documentation" href="../index.html" />
    <link rel="up" title="Internet Protocols and Support" href="internet.html" />
    <link rel="next" title="urllib.parse &#8212; Parse URLs into components" href="urllib.parse.html" />
    <link rel="prev" title="wsgiref &#8212; WSGI Utilities and Reference Implementation" href="wsgiref.html" />
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../modindex.html" title="Global Module Index"
             accesskey="M">modules</a> |</li>
        <li class="right" >
          <a href="urllib.parse.html" title="urllib.parse &#8212; Parse URLs into components"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="wsgiref.html" title="wsgiref &#8212; WSGI Utilities and Reference Implementation"
             accesskey="P">previous</a> |</li>
<li><img src="../_static/py.png" alt="" style="vertical-align: middle; margin-top: -1px"/></li>

        <li><a href="../contents.html">Python v3.0c1 documentation</a> &raquo;</li>

          <li><a href="index.html" accesskey="U">The Python Standard Library</a> &raquo;</li>
          <li><a href="internet.html" accesskey="U">Internet Protocols and Support</a> &raquo;</li>
      </ul>
    </div>
    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  
  <div class="section" id="module-urllib.request">
<h1><tt class="xref docutils literal"><span class="pre">urllib.request</span></tt> &#8212; extensible library for opening URLs<a class="headerlink" href="#module-urllib.request" title="Permalink to this headline">¶</a></h1>
<p>The <tt class="xref docutils literal"><span class="pre">urllib.request</span></tt> module defines functions and classes which help in
opening URLs (mostly HTTP) in a complex world &#8212; basic and digest
authentication, redirections, cookies and more.</p>
<p>The <tt class="xref docutils literal"><span class="pre">urllib.request</span></tt> module defines the following functions:</p>
<dl class="function">
<dt id="urllib.request.urlopen">
<!--[urllib.request.urlopen]--><tt class="descclassname">urllib.request.</tt><tt class="descname">urlopen</tt><big>(</big><em>url</em><span class="optional">[</span>, <em>data</em><span class="optional">]</span><span class="optional">[</span>, <em>timeout</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#urllib.request.urlopen" title="Permalink to this definition">¶</a></dt>
<dd><p>Open the URL <em>url</em>, which can be either a string or a <a title="urllib.request.Request" class="reference internal" href="#urllib.request.Request"><tt class="xref docutils literal"><span class="pre">Request</span></tt></a> object.</p>
<p><em>data</em> may be a string specifying additional data to send to the server, or
<tt class="xref docutils literal"><span class="pre">None</span></tt> if no such data is needed.  Currently HTTP requests are the only ones
that use <em>data</em>; the HTTP request will be a POST instead of a GET when the
<em>data</em> parameter is provided.  <em>data</em> should be a buffer in the standard
<em>application/x-www-form-urlencoded</em> format.  The
<tt class="xref docutils literal"><span class="pre">urllib.urlencode()</span></tt> function takes a mapping or sequence of 2-tuples and
returns a string in this format.</p>
<p>The optional <em>timeout</em> parameter specifies a timeout in seconds for blocking
operations like the connection attempt (if not specified, the global default
timeout setting will be used).  This actually only works for HTTP, HTTPS,
FTP and FTPS connections.</p>
<p>This function returns a file-like object with two additional methods from
the <tt class="xref docutils literal"><span class="pre">urllib.response</span></tt> module</p>
<ul class="simple">
<li><tt class="xref docutils literal"><span class="pre">geturl()</span></tt> &#8212; return the URL of the resource retrieved, commonly used to
determine if a redirect was followed</li>
<li><tt class="xref docutils literal"><span class="pre">info()</span></tt> &#8212; return the meta-information of the page, such as headers, in
the form of an <tt class="docutils literal"><span class="pre">http.client.HTTPMessage</span></tt> instance
(see <a class="reference external" href="http://www.cs.tut.fi/~jkorpela/http.html">Quick Reference to HTTP Headers</a>)</li>
</ul>
<p>Raises <tt class="xref docutils literal"><span class="pre">URLError</span></tt> on errors.</p>
<p>Note that <tt class="xref docutils literal"><span class="pre">None</span></tt> may be returned if no handler handles the request (though the
default installed global <a title="urllib.request.OpenerDirector" class="reference internal" href="#urllib.request.OpenerDirector"><tt class="xref docutils literal"><span class="pre">OpenerDirector</span></tt></a> uses <a title="urllib.request.UnknownHandler" class="reference internal" href="#urllib.request.UnknownHandler"><tt class="xref docutils literal"><span class="pre">UnknownHandler</span></tt></a> to
ensure this never happens).
The urlopen function from the previous version, Python 2.6 and earlier,  of
the module  urllib has been discontinued as urlopen can return the
file-object as the previous. The proxy handling, which in earlier was passed
as a dict parameter to urlopen can be availed by the use of <cite>ProxyHandler</cite>
objects.</p>
</dd></dl>

<dl class="function">
<dt id="urllib.request.install_opener">
<!--[urllib.request.install_opener]--><tt class="descclassname">urllib.request.</tt><tt class="descname">install_opener</tt><big>(</big><em>opener</em><big>)</big><a class="headerlink" href="#urllib.request.install_opener" title="Permalink to this definition">¶</a></dt>
<dd>Install an <a title="urllib.request.OpenerDirector" class="reference internal" href="#urllib.request.OpenerDirector"><tt class="xref docutils literal"><span class="pre">OpenerDirector</span></tt></a> instance as the default global opener.
Installing an opener is only necessary if you want urlopen to use that opener;
otherwise, simply call <a title="urllib.request.OpenerDirector.open" class="reference internal" href="#urllib.request.OpenerDirector.open"><tt class="xref docutils literal"><span class="pre">OpenerDirector.open()</span></tt></a> instead of <a title="urllib.request.urlopen" class="reference internal" href="#urllib.request.urlopen"><tt class="xref docutils literal"><span class="pre">urlopen()</span></tt></a>.
The code does not check for a real <a title="urllib.request.OpenerDirector" class="reference internal" href="#urllib.request.OpenerDirector"><tt class="xref docutils literal"><span class="pre">OpenerDirector</span></tt></a>, and any class with
the appropriate interface will work.</dd></dl>

<dl class="function">
<dt id="urllib.request.build_opener">
<!--[urllib.request.build_opener]--><tt class="descclassname">urllib.request.</tt><tt class="descname">build_opener</tt><big>(</big><span class="optional">[</span><em>handler</em>, <em>...</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#urllib.request.build_opener" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an <a title="urllib.request.OpenerDirector" class="reference internal" href="#urllib.request.OpenerDirector"><tt class="xref docutils literal"><span class="pre">OpenerDirector</span></tt></a> instance, which chains the handlers in the
order given. <em>handler</em>s can be either instances of <a title="urllib.request.BaseHandler" class="reference internal" href="#urllib.request.BaseHandler"><tt class="xref docutils literal"><span class="pre">BaseHandler</span></tt></a>, or
subclasses of <a title="urllib.request.BaseHandler" class="reference internal" href="#urllib.request.BaseHandler"><tt class="xref docutils literal"><span class="pre">BaseHandler</span></tt></a> (in which case it must be possible to call
the constructor without any parameters).  Instances of the following classes
will be in front of the <em>handler</em>s, unless the <em>handler</em>s contain them,
instances of them or subclasses of them: <a title="urllib.request.ProxyHandler" class="reference internal" href="#urllib.request.ProxyHandler"><tt class="xref docutils literal"><span class="pre">ProxyHandler</span></tt></a>,
<a title="urllib.request.UnknownHandler" class="reference internal" href="#urllib.request.UnknownHandler"><tt class="xref docutils literal"><span class="pre">UnknownHandler</span></tt></a>, <a title="urllib.request.HTTPHandler" class="reference internal" href="#urllib.request.HTTPHandler"><tt class="xref docutils literal"><span class="pre">HTTPHandler</span></tt></a>, <a title="urllib.request.HTTPDefaultErrorHandler" class="reference internal" href="#urllib.request.HTTPDefaultErrorHandler"><tt class="xref docutils literal"><span class="pre">HTTPDefaultErrorHandler</span></tt></a>,
<a title="urllib.request.HTTPRedirectHandler" class="reference internal" href="#urllib.request.HTTPRedirectHandler"><tt class="xref docutils literal"><span class="pre">HTTPRedirectHandler</span></tt></a>, <a title="urllib.request.FTPHandler" class="reference internal" href="#urllib.request.FTPHandler"><tt class="xref docutils literal"><span class="pre">FTPHandler</span></tt></a>, <a title="urllib.request.FileHandler" class="reference internal" href="#urllib.request.FileHandler"><tt class="xref docutils literal"><span class="pre">FileHandler</span></tt></a>,
<tt class="xref docutils literal"><span class="pre">HTTPErrorProcessor</span></tt>.</p>
<p>If the Python installation has SSL support (i.e., if the <a title="SSL wrapper for socket objects" class="reference external" href="ssl.html"><tt class="xref docutils literal"><span class="pre">ssl</span></tt></a> module can be imported),
<a title="urllib.request.HTTPSHandler" class="reference internal" href="#urllib.request.HTTPSHandler"><tt class="xref docutils literal"><span class="pre">HTTPSHandler</span></tt></a> will also be added.</p>
<p>A <a title="urllib.request.BaseHandler" class="reference internal" href="#urllib.request.BaseHandler"><tt class="xref docutils literal"><span class="pre">BaseHandler</span></tt></a> subclass may also change its <tt class="xref docutils literal"><span class="pre">handler_order</span></tt>
member variable to modify its position in the handlers list.</p>
</dd></dl>

<dl class="function">
<dt id="urllib.request.urlretrieve">
<!--[urllib.request.urlretrieve]--><tt class="descclassname">urllib.request.</tt><tt class="descname">urlretrieve</tt><big>(</big><em>url</em><span class="optional">[</span>, <em>filename</em><span class="optional">[</span>, <em>reporthook</em><span class="optional">[</span>, <em>data</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#urllib.request.urlretrieve" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy a network object denoted by a URL to a local file, if necessary. If the URL
points to a local file, or a valid cached copy of the object exists, the object
is not copied.  Return a tuple <tt class="docutils literal"><span class="pre">(filename,</span> <span class="pre">headers)</span></tt> where <em>filename</em> is the
local file name under which the object can be found, and <em>headers</em> is whatever
the <tt class="xref docutils literal"><span class="pre">info()</span></tt> method of the object returned by <a title="urllib.request.urlopen" class="reference internal" href="#urllib.request.urlopen"><tt class="xref docutils literal"><span class="pre">urlopen()</span></tt></a> returned (for
a remote object, possibly cached). Exceptions are the same as for
<a title="urllib.request.urlopen" class="reference internal" href="#urllib.request.urlopen"><tt class="xref docutils literal"><span class="pre">urlopen()</span></tt></a>.</p>
<p>The second argument, if present, specifies the file location to copy to (if
absent, the location will be a tempfile with a generated name). The third
argument, if present, is a hook function that will be called once on
establishment of the network connection and once after each block read
thereafter.  The hook will be passed three arguments; a count of blocks
transferred so far, a block size in bytes, and the total size of the file.  The
third argument may be <tt class="docutils literal"><span class="pre">-1</span></tt> on older FTP servers which do not return a file
size in response to a retrieval request.</p>
<p>If the <em>url</em> uses the <tt class="docutils literal"><span class="pre">http:</span></tt> scheme identifier, the optional <em>data</em>
argument may be given to specify a <tt class="docutils literal"><span class="pre">POST</span></tt> request (normally the request type
is <tt class="docutils literal"><span class="pre">GET</span></tt>).  The <em>data</em> argument must in standard
<em>application/x-www-form-urlencoded</em> format; see the <tt class="xref docutils literal"><span class="pre">urlencode()</span></tt>
function below.</p>
<p><a title="urllib.request.urlretrieve" class="reference internal" href="#urllib.request.urlretrieve"><tt class="xref docutils literal"><span class="pre">urlretrieve()</span></tt></a> will raise <tt class="xref docutils literal"><span class="pre">ContentTooShortError</span></tt> when it detects that
the amount of data available  was less than the expected amount (which is the
size reported by a  <em>Content-Length</em> header). This can occur, for example, when
the  download is interrupted.</p>
<p>The <em>Content-Length</em> is treated as a lower bound: if there&#8217;s more data  to read,
urlretrieve reads more data, but if less data is available,  it raises the
exception.</p>
<p>You can still retrieve the downloaded data in this case, it is stored  in the
<tt class="xref docutils literal"><span class="pre">content</span></tt> attribute of the exception instance.</p>
<p>If no <em>Content-Length</em> header was supplied, urlretrieve can not check the size
of the data it has downloaded, and just returns it.  In this case you just have
to assume that the download was successful.</p>
</dd></dl>

<dl class="data">
<dt id="urllib.request._urlopener">
<!--[urllib.request._urlopener]--><tt class="descclassname">urllib.request.</tt><tt class="descname">_urlopener</tt><a class="headerlink" href="#urllib.request._urlopener" title="Permalink to this definition">¶</a></dt>
<dd><p>The public functions <a title="urllib.request.urlopen" class="reference internal" href="#urllib.request.urlopen"><tt class="xref docutils literal"><span class="pre">urlopen()</span></tt></a> and <a title="urllib.request.urlretrieve" class="reference internal" href="#urllib.request.urlretrieve"><tt class="xref docutils literal"><span class="pre">urlretrieve()</span></tt></a> create an instance
of the <a title="urllib.request.FancyURLopener" class="reference internal" href="#urllib.request.FancyURLopener"><tt class="xref docutils literal"><span class="pre">FancyURLopener</span></tt></a> class and use it to perform their requested
actions.  To override this functionality, programmers can create a subclass of
<a title="urllib.request.URLopener" class="reference internal" href="#urllib.request.URLopener"><tt class="xref docutils literal"><span class="pre">URLopener</span></tt></a> or <a title="urllib.request.FancyURLopener" class="reference internal" href="#urllib.request.FancyURLopener"><tt class="xref docutils literal"><span class="pre">FancyURLopener</span></tt></a>, then assign an instance of that
class to the <tt class="docutils literal"><span class="pre">urllib._urlopener</span></tt> variable before calling the desired function.
For example, applications may want to specify a different
<em>User-Agent</em> header than <a title="urllib.request.URLopener" class="reference internal" href="#urllib.request.URLopener"><tt class="xref docutils literal"><span class="pre">URLopener</span></tt></a> defines.  This can be
accomplished with the following code:</p>
<pre>import urllib.request

class AppURLopener(urllib.request.FancyURLopener):
    version = "App/1.7"

urllib._urlopener = AppURLopener()</pre>
</dd></dl>

<dl class="function">
<dt id="urllib.request.urlcleanup">
<!--[urllib.request.urlcleanup]--><tt class="descclassname">urllib.request.</tt><tt class="descname">urlcleanup</tt><big>(</big><big>)</big><a class="headerlink" href="#urllib.request.urlcleanup" title="Permalink to this definition">¶</a></dt>
<dd>Clear the cache that may have been built up by previous calls to
<a title="urllib.request.urlretrieve" class="reference internal" href="#urllib.request.urlretrieve"><tt class="xref docutils literal"><span class="pre">urlretrieve()</span></tt></a>.</dd></dl>

<dl class="function">
<dt id="urllib.request.pathname2url">
<!--[urllib.request.pathname2url]--><tt class="descclassname">urllib.request.</tt><tt class="descname">pathname2url</tt><big>(</big><em>path</em><big>)</big><a class="headerlink" href="#urllib.request.pathname2url" title="Permalink to this definition">¶</a></dt>
<dd>Convert the pathname <em>path</em> from the local syntax for a path to the form used in
the path component of a URL.  This does not produce a complete URL.  The return
value will already be quoted using the <tt class="xref docutils literal"><span class="pre">quote()</span></tt> function.</dd></dl>

<dl class="function">
<dt id="urllib.request.url2pathname">
<!--[urllib.request.url2pathname]--><tt class="descclassname">urllib.request.</tt><tt class="descname">url2pathname</tt><big>(</big><em>path</em><big>)</big><a class="headerlink" href="#urllib.request.url2pathname" title="Permalink to this definition">¶</a></dt>
<dd>Convert the path component <em>path</em> from an encoded URL to the local syntax for a
path.  This does not accept a complete URL.  This function uses <tt class="xref docutils literal"><span class="pre">unquote()</span></tt>
to decode <em>path</em>.</dd></dl>

<p>The following classes are provided:</p>
<dl class="class">
<dt id="urllib.request.Request">
<!--[urllib.request.Request]-->class <tt class="descclassname">urllib.request.</tt><tt class="descname">Request</tt><big>(</big><em>url</em><span class="optional">[</span>, <em>data</em><span class="optional">]</span><span class="optional">[</span>, <em>headers</em><span class="optional">]</span><span class="optional">[</span>, <em>origin_req_host</em><span class="optional">]</span><span class="optional">[</span>, <em>unverifiable</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#urllib.request.Request" title="Permalink to this definition">¶</a></dt>
<dd><p>This class is an abstraction of a URL request.</p>
<p><em>url</em> should be a string containing a valid URL.</p>
<p><em>data</em> may be a string specifying additional data to send to the server, or
<tt class="xref docutils literal"><span class="pre">None</span></tt> if no such data is needed.  Currently HTTP requests are the only ones
that use <em>data</em>; the HTTP request will be a POST instead of a GET when the
<em>data</em> parameter is provided.  <em>data</em> should be a buffer in the standard
<em>application/x-www-form-urlencoded</em> format.  The
<tt class="xref docutils literal"><span class="pre">urllib.urlencode()</span></tt> function takes a mapping or sequence of 2-tuples and
returns a string in this format.</p>
<p><em>headers</em> should be a dictionary, and will be treated as if <a title="urllib.request.Request.add_header" class="reference internal" href="#urllib.request.Request.add_header"><tt class="xref docutils literal"><span class="pre">add_header()</span></tt></a>
was called with each key and value as arguments.  This is often used to &#8220;spoof&#8221;
the <tt class="docutils literal"><span class="pre">User-Agent</span></tt> header, which is used by a browser to identify itself &#8211;
some HTTP servers only allow requests coming from common browsers as opposed
to scripts.  For example, Mozilla Firefox may identify itself as <tt class="docutils literal"><span class="pre">&quot;Mozilla/5.0</span>
<span class="pre">(X11;</span> <span class="pre">U;</span> <span class="pre">Linux</span> <span class="pre">i686)</span> <span class="pre">Gecko/20071127</span> <span class="pre">Firefox/2.0.0.11&quot;</span></tt>, while <tt class="xref docutils literal"><span class="pre">urllib</span></tt>&#8216;s
default user agent string is <tt class="docutils literal"><span class="pre">&quot;Python-urllib/2.6&quot;</span></tt> (on Python 2.6).</p>
<p>The final two arguments are only of interest for correct handling of third-party
HTTP cookies:</p>
<p><em>origin_req_host</em> should be the request-host of the origin transaction, as
defined by <span class="target" id="index-589"></span><a class="reference external" href="http://rfc.net/rfc2965.html"><strong>RFC 2965</strong></a>.  It defaults to <tt class="docutils literal"><span class="pre">http.cookiejar.request_host(self)</span></tt>.
This is the host name or IP address of the original request that was
initiated by the user.  For example, if the request is for an image in an
HTML document, this should be the request-host of the request for the page
containing the image.</p>
<p><em>unverifiable</em> should indicate whether the request is unverifiable, as defined
by RFC 2965.  It defaults to False.  An unverifiable request is one whose URL
the user did not have the option to approve.  For example, if the request is for
an image in an HTML document, and the user had no option to approve the
automatic fetching of the image, this should be true.</p>
</dd></dl>

<dl class="class">
<dt id="urllib.request.URLopener">
<!--[urllib.request.URLopener]-->class <tt class="descclassname">urllib.request.</tt><tt class="descname">URLopener</tt><big>(</big><span class="optional">[</span><em>proxies</em><span class="optional">[</span>, <em>**x509</em><span class="optional">]</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#urllib.request.URLopener" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for opening and reading URLs.  Unless you need to support opening
objects using schemes other than <tt class="docutils literal"><span class="pre">http:</span></tt>, <tt class="docutils literal"><span class="pre">ftp:</span></tt>, or <tt class="docutils literal"><span class="pre">file:</span></tt>,
you probably want to use <a title="urllib.request.FancyURLopener" class="reference internal" href="#urllib.request.FancyURLopener"><tt class="xref docutils literal"><span class="pre">FancyURLopener</span></tt></a>.</p>
<p>By default, the <a title="urllib.request.URLopener" class="reference internal" href="#urllib.request.URLopener"><tt class="xref docutils literal"><span class="pre">URLopener</span></tt></a> class sends a <em>User-Agent</em> header
of <tt class="docutils literal"><span class="pre">urllib/VVV</span></tt>, where <em>VVV</em> is the <tt class="xref docutils literal"><span class="pre">urllib</span></tt> version number.
Applications can define their own <em>User-Agent</em> header by subclassing
<a title="urllib.request.URLopener" class="reference internal" href="#urllib.request.URLopener"><tt class="xref docutils literal"><span class="pre">URLopener</span></tt></a> or <a title="urllib.request.FancyURLopener" class="reference internal" href="#urllib.request.FancyURLopener"><tt class="xref docutils literal"><span class="pre">FancyURLopener</span></tt></a> and setting the class attribute
<a title="urllib.request.URLopener.version" class="reference internal" href="#urllib.request.URLopener.version"><tt class="xref docutils literal"><span class="pre">version</span></tt></a> to an appropriate string value in the subclass definition.</p>
<p>The optional <em>proxies</em> parameter should be a dictionary mapping scheme names to
proxy URLs, where an empty dictionary turns proxies off completely.  Its default
value is <tt class="xref docutils literal"><span class="pre">None</span></tt>, in which case environmental proxy settings will be used if
present, as discussed in the definition of <a title="urllib.request.urlopen" class="reference internal" href="#urllib.request.urlopen"><tt class="xref docutils literal"><span class="pre">urlopen()</span></tt></a>, above.</p>
<p>Additional keyword parameters, collected in <em>x509</em>, may be used for
authentication of the client when using the <tt class="docutils literal"><span class="pre">https:</span></tt> scheme.  The keywords
<em>key_file</em> and <em>cert_file</em> are supported to provide an  SSL key and certificate;
both are needed to support client authentication.</p>
<p><a title="urllib.request.URLopener" class="reference internal" href="#urllib.request.URLopener"><tt class="xref docutils literal"><span class="pre">URLopener</span></tt></a> objects will raise an <a title="exceptions.IOError" class="reference external" href="exceptions.html#exceptions.IOError"><tt class="xref docutils literal"><span class="pre">IOError</span></tt></a> exception if the server
returns an error code.</p>
<blockquote>
<dl class="method">
<dt id="urllib.request.URLopener.open">
<!--[urllib.request.URLopener.open]--><tt class="descname">open</tt><big>(</big><em>fullurl</em><span class="optional">[</span>, <em>data</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#urllib.request.URLopener.open" title="Permalink to this definition">¶</a></dt>
<dd>Open <em>fullurl</em> using the appropriate protocol.  This method sets up cache and
proxy information, then calls the appropriate open method with its input
arguments.  If the scheme is not recognized, <a title="urllib.request.URLopener.open_unknown" class="reference internal" href="#urllib.request.URLopener.open_unknown"><tt class="xref docutils literal"><span class="pre">open_unknown()</span></tt></a> is called.
The <em>data</em> argument has the same meaning as the <em>data</em> argument of
<a title="urllib.request.urlopen" class="reference internal" href="#urllib.request.urlopen"><tt class="xref docutils literal"><span class="pre">urlopen()</span></tt></a>.</dd></dl>

<dl class="method">
<dt id="urllib.request.URLopener.open_unknown">
<!--[urllib.request.URLopener.open_unknown]--><tt class="descname">open_unknown</tt><big>(</big><em>fullurl</em><span class="optional">[</span>, <em>data</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#urllib.request.URLopener.open_unknown" title="Permalink to this definition">¶</a></dt>
<dd>Overridable interface to open unknown URL types.</dd></dl>

<dl class="method">
<dt id="urllib.request.URLopener.retrieve">
<!--[urllib.request.URLopener.retrieve]--><tt class="descname">retrieve</tt><big>(</big><em>url</em><span class="optional">[</span>, <em>filename</em><span class="optional">[</span>, <em>reporthook</em><span class="optional">[</span>, <em>data</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#urllib.request.URLopener.retrieve" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves the contents of <em>url</em> and places it in <em>filename</em>.  The return value
is a tuple consisting of a local filename and either a
<a title="email.message.Message" class="reference external" href="email.message.html#email.message.Message"><tt class="xref docutils literal"><span class="pre">email.message.Message</span></tt></a> object containing the response headers (for remote
URLs) or <tt class="xref docutils literal"><span class="pre">None</span></tt> (for local URLs).  The caller must then open and read the
contents of <em>filename</em>.  If <em>filename</em> is not given and the URL refers to a
local file, the input filename is returned.  If the URL is non-local and
<em>filename</em> is not given, the filename is the output of <a title="tempfile.mktemp" class="reference external" href="tempfile.html#tempfile.mktemp"><tt class="xref docutils literal"><span class="pre">tempfile.mktemp()</span></tt></a>
with a suffix that matches the suffix of the last path component of the input
URL.  If <em>reporthook</em> is given, it must be a function accepting three numeric
parameters.  It will be called after each chunk of data is read from the
network.  <em>reporthook</em> is ignored for local URLs.</p>
<p>If the <em>url</em> uses the <tt class="docutils literal"><span class="pre">http:</span></tt> scheme identifier, the optional <em>data</em>
argument may be given to specify a <tt class="docutils literal"><span class="pre">POST</span></tt> request (normally the request type
is <tt class="docutils literal"><span class="pre">GET</span></tt>).  The <em>data</em> argument must in standard
<em>application/x-www-form-urlencoded</em> format; see the <tt class="xref docutils literal"><span class="pre">urlencode()</span></tt>
function below.</p>
</dd></dl>

<dl class="attribute">
<dt id="urllib.request.URLopener.version">
<!--[urllib.request.URLopener.version]--><tt class="descname">version</tt><a class="headerlink" href="#urllib.request.URLopener.version" title="Permalink to this definition">¶</a></dt>
<dd>Variable that specifies the user agent of the opener object.  To get
<tt class="xref docutils literal"><span class="pre">urllib</span></tt> to tell servers that it is a particular user agent, set this in a
subclass as a class variable or in the constructor before calling the base
constructor.</dd></dl>

</blockquote>
</dd></dl>

<dl class="class">
<dt id="urllib.request.FancyURLopener">
<!--[urllib.request.FancyURLopener]-->class <tt class="descclassname">urllib.request.</tt><tt class="descname">FancyURLopener</tt><big>(</big><em>...</em><big>)</big><a class="headerlink" href="#urllib.request.FancyURLopener" title="Permalink to this definition">¶</a></dt>
<dd><p><a title="urllib.request.FancyURLopener" class="reference internal" href="#urllib.request.FancyURLopener"><tt class="xref docutils literal"><span class="pre">FancyURLopener</span></tt></a> subclasses <a title="urllib.request.URLopener" class="reference internal" href="#urllib.request.URLopener"><tt class="xref docutils literal"><span class="pre">URLopener</span></tt></a> providing default handling
for the following HTTP response codes: 301, 302, 303, 307 and 401.  For the 30x
response codes listed above, the <em>Location</em> header is used to fetch
the actual URL.  For 401 response codes (authentication required), basic HTTP
authentication is performed.  For the 30x response codes, recursion is bounded
by the value of the <em>maxtries</em> attribute, which defaults to 10.</p>
<p>For all other response codes, the method <tt class="xref docutils literal"><span class="pre">http_error_default()</span></tt> is called
which you can override in subclasses to handle the error appropriately.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">According to the letter of <span class="target" id="index-590"></span><a class="reference external" href="http://rfc.net/rfc2616.html"><strong>RFC 2616</strong></a>, 301 and 302 responses to POST requests
must not be automatically redirected without confirmation by the user.  In
reality, browsers do allow automatic redirection of these responses, changing
the POST to a GET, and <tt class="xref docutils literal"><span class="pre">urllib</span></tt> reproduces this behaviour.</p>
</div>
<p>The parameters to the constructor are the same as those for <a title="urllib.request.URLopener" class="reference internal" href="#urllib.request.URLopener"><tt class="xref docutils literal"><span class="pre">URLopener</span></tt></a>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<blockquote>
When performing basic authentication, a <a title="urllib.request.FancyURLopener" class="reference internal" href="#urllib.request.FancyURLopener"><tt class="xref docutils literal"><span class="pre">FancyURLopener</span></tt></a> instance calls
its <a title="urllib.request.FancyURLopener.prompt_user_passwd" class="reference internal" href="#urllib.request.FancyURLopener.prompt_user_passwd"><tt class="xref docutils literal"><span class="pre">prompt_user_passwd()</span></tt></a> method.  The default implementation asks the
users for the required information on the controlling terminal.  A subclass may
override this method to support more appropriate behavior if needed.</blockquote>
<p>The <a title="urllib.request.FancyURLopener" class="reference internal" href="#urllib.request.FancyURLopener"><tt class="xref docutils literal"><span class="pre">FancyURLopener</span></tt></a> class offers one additional method that should be
overloaded to provide the appropriate behavior:</p>
<dl class="last method">
<dt id="urllib.request.FancyURLopener.prompt_user_passwd">
<!--[urllib.request.FancyURLopener.prompt_user_passwd]--><tt class="descname">prompt_user_passwd</tt><big>(</big><em>host</em>, <em>realm</em><big>)</big><a class="headerlink" href="#urllib.request.FancyURLopener.prompt_user_passwd" title="Permalink to this definition">¶</a></dt>
<dd><p>Return information needed to authenticate the user at the given host in the
specified security realm.  The return value should be a tuple, <tt class="docutils literal"><span class="pre">(user,</span>
<span class="pre">password)</span></tt>, which can be used for basic authentication.</p>
<p>The implementation prompts for this information on the terminal; an application
should override this method to use an appropriate interaction model in the local
environment.</p>
</dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="urllib.request.OpenerDirector">
<!--[urllib.request.OpenerDirector]-->class <tt class="descclassname">urllib.request.</tt><tt class="descname">OpenerDirector</tt><a class="headerlink" href="#urllib.request.OpenerDirector" title="Permalink to this definition">¶</a></dt>
<dd>The <a title="urllib.request.OpenerDirector" class="reference internal" href="#urllib.request.OpenerDirector"><tt class="xref docutils literal"><span class="pre">OpenerDirector</span></tt></a> class opens URLs via <a title="urllib.request.BaseHandler" class="reference internal" href="#urllib.request.BaseHandler"><tt class="xref docutils literal"><span class="pre">BaseHandler</span></tt></a>s chained
together. It manages the chaining of handlers, and recovery from errors.</dd></dl>

<dl class="class">
<dt id="urllib.request.BaseHandler">
<!--[urllib.request.BaseHandler]-->class <tt class="descclassname">urllib.request.</tt><tt class="descname">BaseHandler</tt><a class="headerlink" href="#urllib.request.BaseHandler" title="Permalink to this definition">¶</a></dt>
<dd>This is the base class for all registered handlers &#8212; and handles only the
simple mechanics of registration.</dd></dl>

<dl class="class">
<dt id="urllib.request.HTTPDefaultErrorHandler">
<!--[urllib.request.HTTPDefaultErrorHandler]-->class <tt class="descclassname">urllib.request.</tt><tt class="descname">HTTPDefaultErrorHandler</tt><a class="headerlink" href="#urllib.request.HTTPDefaultErrorHandler" title="Permalink to this definition">¶</a></dt>
<dd>A class which defines a default handler for HTTP error responses; all responses
are turned into <tt class="xref docutils literal"><span class="pre">HTTPError</span></tt> exceptions.</dd></dl>

<dl class="class">
<dt id="urllib.request.HTTPRedirectHandler">
<!--[urllib.request.HTTPRedirectHandler]-->class <tt class="descclassname">urllib.request.</tt><tt class="descname">HTTPRedirectHandler</tt><a class="headerlink" href="#urllib.request.HTTPRedirectHandler" title="Permalink to this definition">¶</a></dt>
<dd>A class to handle redirections.</dd></dl>

<dl class="class">
<dt id="urllib.request.HTTPCookieProcessor">
<!--[urllib.request.HTTPCookieProcessor]-->class <tt class="descclassname">urllib.request.</tt><tt class="descname">HTTPCookieProcessor</tt><big>(</big><span class="optional">[</span><em>cookiejar</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#urllib.request.HTTPCookieProcessor" title="Permalink to this definition">¶</a></dt>
<dd>A class to handle HTTP Cookies.</dd></dl>

<dl class="class">
<dt id="urllib.request.ProxyHandler">
<!--[urllib.request.ProxyHandler]-->class <tt class="descclassname">urllib.request.</tt><tt class="descname">ProxyHandler</tt><big>(</big><span class="optional">[</span><em>proxies</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#urllib.request.ProxyHandler" title="Permalink to this definition">¶</a></dt>
<dd>Cause requests to go through a proxy. If <em>proxies</em> is given, it must be a
dictionary mapping protocol names to URLs of proxies. The default is to read the
list of proxies from the environment variables <span class="target" id="index-591"></span><strong class="xref"></strong>.
To disable autodetected proxy pass an empty dictionary.</dd></dl>

<dl class="class">
<dt id="urllib.request.HTTPPasswordMgr">
<!--[urllib.request.HTTPPasswordMgr]-->class <tt class="descclassname">urllib.request.</tt><tt class="descname">HTTPPasswordMgr</tt><a class="headerlink" href="#urllib.request.HTTPPasswordMgr" title="Permalink to this definition">¶</a></dt>
<dd>Keep a database of  <tt class="docutils literal"><span class="pre">(realm,</span> <span class="pre">uri)</span> <span class="pre">-&gt;</span> <span class="pre">(user,</span> <span class="pre">password)</span></tt> mappings.</dd></dl>

<dl class="class">
<dt id="urllib.request.HTTPPasswordMgrWithDefaultRealm">
<!--[urllib.request.HTTPPasswordMgrWithDefaultRealm]-->class <tt class="descclassname">urllib.request.</tt><tt class="descname">HTTPPasswordMgrWithDefaultRealm</tt><a class="headerlink" href="#urllib.request.HTTPPasswordMgrWithDefaultRealm" title="Permalink to this definition">¶</a></dt>
<dd>Keep a database of  <tt class="docutils literal"><span class="pre">(realm,</span> <span class="pre">uri)</span> <span class="pre">-&gt;</span> <span class="pre">(user,</span> <span class="pre">password)</span></tt> mappings. A realm of
<tt class="xref docutils literal"><span class="pre">None</span></tt> is considered a catch-all realm, which is searched if no other realm
fits.</dd></dl>

<dl class="class">
<dt id="urllib.request.AbstractBasicAuthHandler">
<!--[urllib.request.AbstractBasicAuthHandler]-->class <tt class="descclassname">urllib.request.</tt><tt class="descname">AbstractBasicAuthHandler</tt><big>(</big><span class="optional">[</span><em>password_mgr</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#urllib.request.AbstractBasicAuthHandler" title="Permalink to this definition">¶</a></dt>
<dd>This is a mixin class that helps with HTTP authentication, both to the remote
host and to a proxy. <em>password_mgr</em>, if given, should be something that is
compatible with <a title="urllib.request.HTTPPasswordMgr" class="reference internal" href="#urllib.request.HTTPPasswordMgr"><tt class="xref docutils literal"><span class="pre">HTTPPasswordMgr</span></tt></a>; refer to section
<a class="reference internal" href="#http-password-mgr"><em>HTTPPasswordMgr Objects</em></a> for information on the interface that must be
supported.</dd></dl>

<dl class="class">
<dt id="urllib.request.HTTPBasicAuthHandler">
<!--[urllib.request.HTTPBasicAuthHandler]-->class <tt class="descclassname">urllib.request.</tt><tt class="descname">HTTPBasicAuthHandler</tt><big>(</big><span class="optional">[</span><em>password_mgr</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#urllib.request.HTTPBasicAuthHandler" title="Permalink to this definition">¶</a></dt>
<dd>Handle authentication with the remote host. <em>password_mgr</em>, if given, should be
something that is compatible with <a title="urllib.request.HTTPPasswordMgr" class="reference internal" href="#urllib.request.HTTPPasswordMgr"><tt class="xref docutils literal"><span class="pre">HTTPPasswordMgr</span></tt></a>; refer to section
<a class="reference internal" href="#http-password-mgr"><em>HTTPPasswordMgr Objects</em></a> for information on the interface that must be
supported.</dd></dl>

<dl class="class">
<dt id="urllib.request.ProxyBasicAuthHandler">
<!--[urllib.request.ProxyBasicAuthHandler]-->class <tt class="descclassname">urllib.request.</tt><tt class="descname">ProxyBasicAuthHandler</tt><big>(</big><span class="optional">[</span><em>password_mgr</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#urllib.request.ProxyBasicAuthHandler" title="Permalink to this definition">¶</a></dt>
<dd>Handle authentication with the proxy. <em>password_mgr</em>, if given, should be
something that is compatible with <a title="urllib.request.HTTPPasswordMgr" class="reference internal" href="#urllib.request.HTTPPasswordMgr"><tt class="xref docutils literal"><span class="pre">HTTPPasswordMgr</span></tt></a>; refer to section
<a class="reference internal" href="#http-password-mgr"><em>HTTPPasswordMgr Objects</em></a> for information on the interface that must be
supported.</dd></dl>

<dl class="class">
<dt id="urllib.request.AbstractDigestAuthHandler">
<!--[urllib.request.AbstractDigestAuthHandler]-->class <tt class="descclassname">urllib.request.</tt><tt class="descname">AbstractDigestAuthHandler</tt><big>(</big><span class="optional">[</span><em>password_mgr</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#urllib.request.AbstractDigestAuthHandler" title="Permalink to this definition">¶</a></dt>
<dd>This is a mixin class that helps with HTTP authentication, both to the remote
host and to a proxy. <em>password_mgr</em>, if given, should be something that is
compatible with <a title="urllib.request.HTTPPasswordMgr" class="reference internal" href="#urllib.request.HTTPPasswordMgr"><tt class="xref docutils literal"><span class="pre">HTTPPasswordMgr</span></tt></a>; refer to section
<a class="reference internal" href="#http-password-mgr"><em>HTTPPasswordMgr Objects</em></a> for information on the interface that must be
supported.</dd></dl>

<dl class="class">
<dt id="urllib.request.HTTPDigestAuthHandler">
<!--[urllib.request.HTTPDigestAuthHandler]-->class <tt class="descclassname">urllib.request.</tt><tt class="descname">HTTPDigestAuthHandler</tt><big>(</big><span class="optional">[</span><em>password_mgr</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#urllib.request.HTTPDigestAuthHandler" title="Permalink to this definition">¶</a></dt>
<dd>Handle authentication with the remote host. <em>password_mgr</em>, if given, should be
something that is compatible with <a title="urllib.request.HTTPPasswordMgr" class="reference internal" href="#urllib.request.HTTPPasswordMgr"><tt class="xref docutils literal"><span class="pre">HTTPPasswordMgr</span></tt></a>; refer to section
<a class="reference internal" href="#http-password-mgr"><em>HTTPPasswordMgr Objects</em></a> for information on the interface that must be
supported.</dd></dl>

<dl class="class">
<dt id="urllib.request.ProxyDigestAuthHandler">
<!--[urllib.request.ProxyDigestAuthHandler]-->class <tt class="descclassname">urllib.request.</tt><tt class="descname">ProxyDigestAuthHandler</tt><big>(</big><span class="optional">[</span><em>password_mgr</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#urllib.request.ProxyDigestAuthHandler" title="Permalink to this definition">¶</a></dt>
<dd>Handle authentication with the proxy. <em>password_mgr</em>, if given, should be
something that is compatible with <a title="urllib.request.HTTPPasswordMgr" class="reference internal" href="#urllib.request.HTTPPasswordMgr"><tt class="xref docutils literal"><span class="pre">HTTPPasswordMgr</span></tt></a>; refer to section
<a class="reference internal" href="#http-password-mgr"><em>HTTPPasswordMgr Objects</em></a> for information on the interface that must be
supported.</dd></dl>

<dl class="class">
<dt id="urllib.request.HTTPHandler">
<!--[urllib.request.HTTPHandler]-->class <tt class="descclassname">urllib.request.</tt><tt class="descname">HTTPHandler</tt><a class="headerlink" href="#urllib.request.HTTPHandler" title="Permalink to this definition">¶</a></dt>
<dd>A class to handle opening of HTTP URLs.</dd></dl>

<dl class="class">
<dt id="urllib.request.HTTPSHandler">
<!--[urllib.request.HTTPSHandler]-->class <tt class="descclassname">urllib.request.</tt><tt class="descname">HTTPSHandler</tt><a class="headerlink" href="#urllib.request.HTTPSHandler" title="Permalink to this definition">¶</a></dt>
<dd>A class to handle opening of HTTPS URLs.</dd></dl>

<dl class="class">
<dt id="urllib.request.FileHandler">
<!--[urllib.request.FileHandler]-->class <tt class="descclassname">urllib.request.</tt><tt class="descname">FileHandler</tt><a class="headerlink" href="#urllib.request.FileHandler" title="Permalink to this definition">¶</a></dt>
<dd>Open local files.</dd></dl>

<dl class="class">
<dt id="urllib.request.FTPHandler">
<!--[urllib.request.FTPHandler]-->class <tt class="descclassname">urllib.request.</tt><tt class="descname">FTPHandler</tt><a class="headerlink" href="#urllib.request.FTPHandler" title="Permalink to this definition">¶</a></dt>
<dd>Open FTP URLs.</dd></dl>

<dl class="class">
<dt id="urllib.request.CacheFTPHandler">
<!--[urllib.request.CacheFTPHandler]-->class <tt class="descclassname">urllib.request.</tt><tt class="descname">CacheFTPHandler</tt><a class="headerlink" href="#urllib.request.CacheFTPHandler" title="Permalink to this definition">¶</a></dt>
<dd>Open FTP URLs, keeping a cache of open FTP connections to minimize delays.</dd></dl>

<dl class="class">
<dt id="urllib.request.UnknownHandler">
<!--[urllib.request.UnknownHandler]-->class <tt class="descclassname">urllib.request.</tt><tt class="descname">UnknownHandler</tt><a class="headerlink" href="#urllib.request.UnknownHandler" title="Permalink to this definition">¶</a></dt>
<dd>A catch-all class to handle unknown URLs.</dd></dl>

<div class="section" id="id1">
<span id="request-objects"></span><h2>Request Objects<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>The following methods describe all of <a title="urllib.request.Request" class="reference internal" href="#urllib.request.Request"><tt class="xref docutils literal"><span class="pre">Request</span></tt></a>&#8216;s public interface, and
so all must be overridden in subclasses.</p>
<dl class="method">
<dt id="urllib.request.Request.add_data">
<!--[urllib.request.Request.add_data]--><tt class="descclassname">Request.</tt><tt class="descname">add_data</tt><big>(</big><em>data</em><big>)</big><a class="headerlink" href="#urllib.request.Request.add_data" title="Permalink to this definition">¶</a></dt>
<dd>Set the <a title="urllib.request.Request" class="reference internal" href="#urllib.request.Request"><tt class="xref docutils literal"><span class="pre">Request</span></tt></a> data to <em>data</em>.  This is ignored by all handlers except
HTTP handlers &#8212; and there it should be a byte string, and will change the
request to be <tt class="docutils literal"><span class="pre">POST</span></tt> rather than <tt class="docutils literal"><span class="pre">GET</span></tt>.</dd></dl>

<dl class="method">
<dt id="urllib.request.Request.get_method">
<!--[urllib.request.Request.get_method]--><tt class="descclassname">Request.</tt><tt class="descname">get_method</tt><big>(</big><big>)</big><a class="headerlink" href="#urllib.request.Request.get_method" title="Permalink to this definition">¶</a></dt>
<dd>Return a string indicating the HTTP request method.  This is only meaningful for
HTTP requests, and currently always returns <tt class="docutils literal"><span class="pre">'GET'</span></tt> or <tt class="docutils literal"><span class="pre">'POST'</span></tt>.</dd></dl>

<dl class="method">
<dt id="urllib.request.Request.has_data">
<!--[urllib.request.Request.has_data]--><tt class="descclassname">Request.</tt><tt class="descname">has_data</tt><big>(</big><big>)</big><a class="headerlink" href="#urllib.request.Request.has_data" title="Permalink to this definition">¶</a></dt>
<dd>Return whether the instance has a non-<tt class="xref docutils literal"><span class="pre">None</span></tt> data.</dd></dl>

<dl class="method">
<dt id="urllib.request.Request.get_data">
<!--[urllib.request.Request.get_data]--><tt class="descclassname">Request.</tt><tt class="descname">get_data</tt><big>(</big><big>)</big><a class="headerlink" href="#urllib.request.Request.get_data" title="Permalink to this definition">¶</a></dt>
<dd>Return the instance&#8217;s data.</dd></dl>

<dl class="method">
<dt id="urllib.request.Request.add_header">
<!--[urllib.request.Request.add_header]--><tt class="descclassname">Request.</tt><tt class="descname">add_header</tt><big>(</big><em>key</em>, <em>val</em><big>)</big><a class="headerlink" href="#urllib.request.Request.add_header" title="Permalink to this definition">¶</a></dt>
<dd>Add another header to the request.  Headers are currently ignored by all
handlers except HTTP handlers, where they are added to the list of headers sent
to the server.  Note that there cannot be more than one header with the same
name, and later calls will overwrite previous calls in case the <em>key</em> collides.
Currently, this is no loss of HTTP functionality, since all headers which have
meaning when used more than once have a (header-specific) way of gaining the
same functionality using only one header.</dd></dl>

<dl class="method">
<dt id="urllib.request.Request.add_unredirected_header">
<!--[urllib.request.Request.add_unredirected_header]--><tt class="descclassname">Request.</tt><tt class="descname">add_unredirected_header</tt><big>(</big><em>key</em>, <em>header</em><big>)</big><a class="headerlink" href="#urllib.request.Request.add_unredirected_header" title="Permalink to this definition">¶</a></dt>
<dd>Add a header that will not be added to a redirected request.</dd></dl>

<dl class="method">
<dt id="urllib.request.Request.has_header">
<!--[urllib.request.Request.has_header]--><tt class="descclassname">Request.</tt><tt class="descname">has_header</tt><big>(</big><em>header</em><big>)</big><a class="headerlink" href="#urllib.request.Request.has_header" title="Permalink to this definition">¶</a></dt>
<dd>Return whether the instance has the named header (checks both regular and
unredirected).</dd></dl>

<dl class="method">
<dt id="urllib.request.Request.get_full_url">
<!--[urllib.request.Request.get_full_url]--><tt class="descclassname">Request.</tt><tt class="descname">get_full_url</tt><big>(</big><big>)</big><a class="headerlink" href="#urllib.request.Request.get_full_url" title="Permalink to this definition">¶</a></dt>
<dd>Return the URL given in the constructor.</dd></dl>

<dl class="method">
<dt id="urllib.request.Request.get_type">
<!--[urllib.request.Request.get_type]--><tt class="descclassname">Request.</tt><tt class="descname">get_type</tt><big>(</big><big>)</big><a class="headerlink" href="#urllib.request.Request.get_type" title="Permalink to this definition">¶</a></dt>
<dd>Return the type of the URL &#8212; also known as the scheme.</dd></dl>

<dl class="method">
<dt id="urllib.request.Request.get_host">
<!--[urllib.request.Request.get_host]--><tt class="descclassname">Request.</tt><tt class="descname">get_host</tt><big>(</big><big>)</big><a class="headerlink" href="#urllib.request.Request.get_host" title="Permalink to this definition">¶</a></dt>
<dd>Return the host to which a connection will be made.</dd></dl>

<dl class="method">
<dt id="urllib.request.Request.get_selector">
<!--[urllib.request.Request.get_selector]--><tt class="descclassname">Request.</tt><tt class="descname">get_selector</tt><big>(</big><big>)</big><a class="headerlink" href="#urllib.request.Request.get_selector" title="Permalink to this definition">¶</a></dt>
<dd>Return the selector &#8212; the part of the URL that is sent to the server.</dd></dl>

<dl class="method">
<dt id="urllib.request.Request.set_proxy">
<!--[urllib.request.Request.set_proxy]--><tt class="descclassname">Request.</tt><tt class="descname">set_proxy</tt><big>(</big><em>host</em>, <em>type</em><big>)</big><a class="headerlink" href="#urllib.request.Request.set_proxy" title="Permalink to this definition">¶</a></dt>
<dd>Prepare the request by connecting to a proxy server. The <em>host</em> and <em>type</em> will
replace those of the instance, and the instance&#8217;s selector will be the original
URL given in the constructor.</dd></dl>

<dl class="method">
<dt id="urllib.request.Request.get_origin_req_host">
<!--[urllib.request.Request.get_origin_req_host]--><tt class="descclassname">Request.</tt><tt class="descname">get_origin_req_host</tt><big>(</big><big>)</big><a class="headerlink" href="#urllib.request.Request.get_origin_req_host" title="Permalink to this definition">¶</a></dt>
<dd>Return the request-host of the origin transaction, as defined by <span class="target" id="index-592"></span><a class="reference external" href="http://rfc.net/rfc2965.html"><strong>RFC 2965</strong></a>.
See the documentation for the <a title="urllib.request.Request" class="reference internal" href="#urllib.request.Request"><tt class="xref docutils literal"><span class="pre">Request</span></tt></a> constructor.</dd></dl>

<dl class="method">
<dt id="urllib.request.Request.is_unverifiable">
<!--[urllib.request.Request.is_unverifiable]--><tt class="descclassname">Request.</tt><tt class="descname">is_unverifiable</tt><big>(</big><big>)</big><a class="headerlink" href="#urllib.request.Request.is_unverifiable" title="Permalink to this definition">¶</a></dt>
<dd>Return whether the request is unverifiable, as defined by RFC 2965. See the
documentation for the <a title="urllib.request.Request" class="reference internal" href="#urllib.request.Request"><tt class="xref docutils literal"><span class="pre">Request</span></tt></a> constructor.</dd></dl>

</div>
<div class="section" id="openerdirector-objects">
<span id="opener-director-objects"></span><h2>OpenerDirector Objects<a class="headerlink" href="#openerdirector-objects" title="Permalink to this headline">¶</a></h2>
<p><a title="urllib.request.OpenerDirector" class="reference internal" href="#urllib.request.OpenerDirector"><tt class="xref docutils literal"><span class="pre">OpenerDirector</span></tt></a> instances have the following methods:</p>
<dl class="method">
<dt id="urllib.request.OpenerDirector.add_handler">
<!--[urllib.request.OpenerDirector.add_handler]--><tt class="descclassname">OpenerDirector.</tt><tt class="descname">add_handler</tt><big>(</big><em>handler</em><big>)</big><a class="headerlink" href="#urllib.request.OpenerDirector.add_handler" title="Permalink to this definition">¶</a></dt>
<dd><p><em>handler</em> should be an instance of <a title="urllib.request.BaseHandler" class="reference internal" href="#urllib.request.BaseHandler"><tt class="xref docutils literal"><span class="pre">BaseHandler</span></tt></a>.  The following methods
are searched, and added to the possible chains (note that HTTP errors are a
special case).</p>
<ul class="simple">
<li><tt class="xref docutils literal"><span class="pre">protocol_open()</span></tt> &#8212; signal that the handler knows how to open <em>protocol</em>
URLs.</li>
<li><tt class="xref docutils literal"><span class="pre">http_error_type()</span></tt> &#8212; signal that the handler knows how to handle HTTP
errors with HTTP error code <em>type</em>.</li>
<li><tt class="xref docutils literal"><span class="pre">protocol_error()</span></tt> &#8212; signal that the handler knows how to handle errors
from (non-<tt class="docutils literal"><span class="pre">http</span></tt>) <em>protocol</em>.</li>
<li><tt class="xref docutils literal"><span class="pre">protocol_request()</span></tt> &#8212; signal that the handler knows how to pre-process
<em>protocol</em> requests.</li>
<li><tt class="xref docutils literal"><span class="pre">protocol_response()</span></tt> &#8212; signal that the handler knows how to
post-process <em>protocol</em> responses.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="urllib.request.OpenerDirector.open">
<!--[urllib.request.OpenerDirector.open]--><tt class="descclassname">OpenerDirector.</tt><tt class="descname">open</tt><big>(</big><em>url</em><span class="optional">[</span>, <em>data</em><span class="optional">]</span><span class="optional">[</span>, <em>timeout</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#urllib.request.OpenerDirector.open" title="Permalink to this definition">¶</a></dt>
<dd>Open the given <em>url</em> (which can be a request object or a string), optionally
passing the given <em>data</em>. Arguments, return values and exceptions raised are
the same as those of <a title="urllib.request.urlopen" class="reference internal" href="#urllib.request.urlopen"><tt class="xref docutils literal"><span class="pre">urlopen()</span></tt></a> (which simply calls the <a title="open" class="reference external" href="functions.html#open"><tt class="xref docutils literal"><span class="pre">open()</span></tt></a>
method on the currently installed global <a title="urllib.request.OpenerDirector" class="reference internal" href="#urllib.request.OpenerDirector"><tt class="xref docutils literal"><span class="pre">OpenerDirector</span></tt></a>).  The
optional <em>timeout</em> parameter specifies a timeout in seconds for blocking
operations like the connection attempt (if not specified, the global default
timeout setting will be usedi). The timeout feature actually works only for
HTTP, HTTPS, FTP and FTPS connections).</dd></dl>

<dl class="method">
<dt id="urllib.request.OpenerDirector.error">
<!--[urllib.request.OpenerDirector.error]--><tt class="descclassname">OpenerDirector.</tt><tt class="descname">error</tt><big>(</big><em>proto</em><span class="optional">[</span>, <em>arg</em><span class="optional">[</span>, <em>...</em><span class="optional">]</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#urllib.request.OpenerDirector.error" title="Permalink to this definition">¶</a></dt>
<dd><p>Handle an error of the given protocol.  This will call the registered error
handlers for the given protocol with the given arguments (which are protocol
specific).  The HTTP protocol is a special case which uses the HTTP response
code to determine the specific error handler; refer to the <tt class="xref docutils literal"><span class="pre">http_error_*()</span></tt>
methods of the handler classes.</p>
<p>Return values and exceptions raised are the same as those of <a title="urllib.request.urlopen" class="reference internal" href="#urllib.request.urlopen"><tt class="xref docutils literal"><span class="pre">urlopen()</span></tt></a>.</p>
</dd></dl>

<p>OpenerDirector objects open URLs in three stages:</p>
<p>The order in which these methods are called within each stage is determined by
sorting the handler instances.</p>
<ol class="arabic">
<li><p class="first">Every handler with a method named like <tt class="xref docutils literal"><span class="pre">protocol_request()</span></tt> has that
method called to pre-process the request.</p>
</li>
<li><p class="first">Handlers with a method named like <tt class="xref docutils literal"><span class="pre">protocol_open()</span></tt> are called to handle
the request. This stage ends when a handler either returns a non-<a title="None" class="reference external" href="constants.html#None"><tt class="xref xref docutils literal"><span class="pre">None</span></tt></a>
value (ie. a response), or raises an exception (usually <tt class="xref docutils literal"><span class="pre">URLError</span></tt>).
Exceptions are allowed to propagate.</p>
<p>In fact, the above algorithm is first tried for methods named
<tt class="xref docutils literal"><span class="pre">default_open()</span></tt>.  If all such methods return <a title="None" class="reference external" href="constants.html#None"><tt class="xref xref docutils literal"><span class="pre">None</span></tt></a>, the algorithm
is repeated for methods named like <tt class="xref docutils literal"><span class="pre">protocol_open()</span></tt>.  If all such methods
return <a title="None" class="reference external" href="constants.html#None"><tt class="xref xref docutils literal"><span class="pre">None</span></tt></a>, the algorithm is repeated for methods named
<tt class="xref docutils literal"><span class="pre">unknown_open()</span></tt>.</p>
<p>Note that the implementation of these methods may involve calls of the parent
<a title="urllib.request.OpenerDirector" class="reference internal" href="#urllib.request.OpenerDirector"><tt class="xref docutils literal"><span class="pre">OpenerDirector</span></tt></a> instance&#8217;s <a title="open" class="reference external" href="functions.html#open"><tt class="xref docutils literal"><span class="pre">open()</span></tt></a> and <tt class="xref docutils literal"><span class="pre">error()</span></tt> methods.</p>
</li>
<li><p class="first">Every handler with a method named like <tt class="xref docutils literal"><span class="pre">protocol_response()</span></tt> has that
method called to post-process the response.</p>
</li>
</ol>
</div>
<div class="section" id="basehandler-objects">
<span id="base-handler-objects"></span><h2>BaseHandler Objects<a class="headerlink" href="#basehandler-objects" title="Permalink to this headline">¶</a></h2>
<p><a title="urllib.request.BaseHandler" class="reference internal" href="#urllib.request.BaseHandler"><tt class="xref docutils literal"><span class="pre">BaseHandler</span></tt></a> objects provide a couple of methods that are directly
useful, and others that are meant to be used by derived classes.  These are
intended for direct use:</p>
<dl class="method">
<dt id="urllib.request.BaseHandler.add_parent">
<!--[urllib.request.BaseHandler.add_parent]--><tt class="descclassname">BaseHandler.</tt><tt class="descname">add_parent</tt><big>(</big><em>director</em><big>)</big><a class="headerlink" href="#urllib.request.BaseHandler.add_parent" title="Permalink to this definition">¶</a></dt>
<dd>Add a director as parent.</dd></dl>

<dl class="method">
<dt id="urllib.request.BaseHandler.close">
<!--[urllib.request.BaseHandler.close]--><tt class="descclassname">BaseHandler.</tt><tt class="descname">close</tt><big>(</big><big>)</big><a class="headerlink" href="#urllib.request.BaseHandler.close" title="Permalink to this definition">¶</a></dt>
<dd>Remove any parents.</dd></dl>

<p>The following members and methods should only be used by classes derived from
<a title="urllib.request.BaseHandler" class="reference internal" href="#urllib.request.BaseHandler"><tt class="xref docutils literal"><span class="pre">BaseHandler</span></tt></a>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The convention has been adopted that subclasses defining
<tt class="xref docutils literal"><span class="pre">protocol_request()</span></tt> or <tt class="xref docutils literal"><span class="pre">protocol_response()</span></tt> methods are named
<tt class="xref docutils literal"><span class="pre">*Processor</span></tt>; all others are named <tt class="xref docutils literal"><span class="pre">*Handler</span></tt>.</p>
</div>
<dl class="attribute">
<dt id="urllib.request.BaseHandler.parent">
<!--[urllib.request.BaseHandler.parent]--><tt class="descclassname">BaseHandler.</tt><tt class="descname">parent</tt><a class="headerlink" href="#urllib.request.BaseHandler.parent" title="Permalink to this definition">¶</a></dt>
<dd>A valid <a title="urllib.request.OpenerDirector" class="reference internal" href="#urllib.request.OpenerDirector"><tt class="xref docutils literal"><span class="pre">OpenerDirector</span></tt></a>, which can be used to open using a different
protocol, or handle errors.</dd></dl>

<dl class="method">
<dt id="urllib.request.BaseHandler.default_open">
<!--[urllib.request.BaseHandler.default_open]--><tt class="descclassname">BaseHandler.</tt><tt class="descname">default_open</tt><big>(</big><em>req</em><big>)</big><a class="headerlink" href="#urllib.request.BaseHandler.default_open" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is <em>not</em> defined in <a title="urllib.request.BaseHandler" class="reference internal" href="#urllib.request.BaseHandler"><tt class="xref docutils literal"><span class="pre">BaseHandler</span></tt></a>, but subclasses should
define it if they want to catch all URLs.</p>
<p>This method, if implemented, will be called by the parent
<a title="urllib.request.OpenerDirector" class="reference internal" href="#urllib.request.OpenerDirector"><tt class="xref docutils literal"><span class="pre">OpenerDirector</span></tt></a>.  It should return a file-like object as described in
the return value of the <a title="open" class="reference external" href="functions.html#open"><tt class="xref docutils literal"><span class="pre">open()</span></tt></a> of <a title="urllib.request.OpenerDirector" class="reference internal" href="#urllib.request.OpenerDirector"><tt class="xref docutils literal"><span class="pre">OpenerDirector</span></tt></a>, or <tt class="xref docutils literal"><span class="pre">None</span></tt>.
It should raise <tt class="xref docutils literal"><span class="pre">URLError</span></tt>, unless a truly exceptional thing happens (for
example, <a title="exceptions.MemoryError" class="reference external" href="exceptions.html#exceptions.MemoryError"><tt class="xref docutils literal"><span class="pre">MemoryError</span></tt></a> should not be mapped to <tt class="xref docutils literal"><span class="pre">URLError</span></tt>).</p>
<p>This method will be called before any protocol-specific open method.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">BaseHandler.</tt><tt class="descname">protocol_open</tt><big>(</big><em>req</em><big>)</big></dt>
<dd><p>This method is <em>not</em> defined in <a title="urllib.request.BaseHandler" class="reference internal" href="#urllib.request.BaseHandler"><tt class="xref docutils literal"><span class="pre">BaseHandler</span></tt></a>, but subclasses should
define it if they want to handle URLs with the given protocol.</p>
<p>This method, if defined, will be called by the parent <a title="urllib.request.OpenerDirector" class="reference internal" href="#urllib.request.OpenerDirector"><tt class="xref docutils literal"><span class="pre">OpenerDirector</span></tt></a>.
Return values should be the same as for  <a title="urllib.request.BaseHandler.default_open" class="reference internal" href="#urllib.request.BaseHandler.default_open"><tt class="xref docutils literal"><span class="pre">default_open()</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.BaseHandler.unknown_open">
<!--[urllib.request.BaseHandler.unknown_open]--><tt class="descclassname">BaseHandler.</tt><tt class="descname">unknown_open</tt><big>(</big><em>req</em><big>)</big><a class="headerlink" href="#urllib.request.BaseHandler.unknown_open" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is <em>not</em> defined in <a title="urllib.request.BaseHandler" class="reference internal" href="#urllib.request.BaseHandler"><tt class="xref docutils literal"><span class="pre">BaseHandler</span></tt></a>, but subclasses should
define it if they want to catch all URLs with no specific registered handler to
open it.</p>
<p>This method, if implemented, will be called by the <a title="urllib.request.BaseHandler.parent" class="reference internal" href="#urllib.request.BaseHandler.parent"><tt class="xref docutils literal"><span class="pre">parent</span></tt></a>
<a title="urllib.request.OpenerDirector" class="reference internal" href="#urllib.request.OpenerDirector"><tt class="xref docutils literal"><span class="pre">OpenerDirector</span></tt></a>.  Return values should be the same as for
<a title="urllib.request.BaseHandler.default_open" class="reference internal" href="#urllib.request.BaseHandler.default_open"><tt class="xref docutils literal"><span class="pre">default_open()</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.BaseHandler.http_error_default">
<!--[urllib.request.BaseHandler.http_error_default]--><tt class="descclassname">BaseHandler.</tt><tt class="descname">http_error_default</tt><big>(</big><em>req</em>, <em>fp</em>, <em>code</em>, <em>msg</em>, <em>hdrs</em><big>)</big><a class="headerlink" href="#urllib.request.BaseHandler.http_error_default" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is <em>not</em> defined in <a title="urllib.request.BaseHandler" class="reference internal" href="#urllib.request.BaseHandler"><tt class="xref docutils literal"><span class="pre">BaseHandler</span></tt></a>, but subclasses should
override it if they intend to provide a catch-all for otherwise unhandled HTTP
errors.  It will be called automatically by the  <a title="urllib.request.OpenerDirector" class="reference internal" href="#urllib.request.OpenerDirector"><tt class="xref docutils literal"><span class="pre">OpenerDirector</span></tt></a> getting
the error, and should not normally be called in other circumstances.</p>
<p><em>req</em> will be a <a title="urllib.request.Request" class="reference internal" href="#urllib.request.Request"><tt class="xref docutils literal"><span class="pre">Request</span></tt></a> object, <em>fp</em> will be a file-like object with
the HTTP error body, <em>code</em> will be the three-digit code of the error, <em>msg</em>
will be the user-visible explanation of the code and <em>hdrs</em> will be a mapping
object with the headers of the error.</p>
<p>Return values and exceptions raised should be the same as those of
<a title="urllib.request.urlopen" class="reference internal" href="#urllib.request.urlopen"><tt class="xref docutils literal"><span class="pre">urlopen()</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="urllib.request.BaseHandler.http_error_nnn">
<!--[urllib.request.BaseHandler.http_error_nnn]--><tt class="descclassname">BaseHandler.</tt><tt class="descname">http_error_nnn</tt><big>(</big><em>req</em>, <em>fp</em>, <em>code</em>, <em>msg</em>, <em>hdrs</em><big>)</big><a class="headerlink" href="#urllib.request.BaseHandler.http_error_nnn" title="Permalink to this definition">¶</a></dt>
<dd><p><em>nnn</em> should be a three-digit HTTP error code.  This method is also not defined
in <a title="urllib.request.BaseHandler" class="reference internal" href="#urllib.request.BaseHandler"><tt class="xref docutils literal"><span class="pre">BaseHandler</span></tt></a>, but will be called, if it exists, on an instance of a
subclass, when an HTTP error with code <em>nnn</em> occurs.</p>
<p>Subclasses should override this method to handle specific HTTP errors.</p>
<p>Arguments, return values and exceptions raised should be the same as for
<a title="urllib.request.BaseHandler.http_error_default" class="reference internal" href="#urllib.request.BaseHandler.http_error_default"><tt class="xref docutils literal"><span class="pre">http_error_default()</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">BaseHandler.</tt><tt class="descname">protocol_request</tt><big>(</big><em>req</em><big>)</big></dt>
<dd><p>This method is <em>not</em> defined in <a title="urllib.request.BaseHandler" class="reference internal" href="#urllib.request.BaseHandler"><tt class="xref docutils literal"><span class="pre">BaseHandler</span></tt></a>, but subclasses should
define it if they want to pre-process requests of the given protocol.</p>
<p>This method, if defined, will be called by the parent <a title="urllib.request.OpenerDirector" class="reference internal" href="#urllib.request.OpenerDirector"><tt class="xref docutils literal"><span class="pre">OpenerDirector</span></tt></a>.
<em>req</em> will be a <a title="urllib.request.Request" class="reference internal" href="#urllib.request.Request"><tt class="xref docutils literal"><span class="pre">Request</span></tt></a> object. The return value should be a
<a title="urllib.request.Request" class="reference internal" href="#urllib.request.Request"><tt class="xref docutils literal"><span class="pre">Request</span></tt></a> object.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">BaseHandler.</tt><tt class="descname">protocol_response</tt><big>(</big><em>req</em>, <em>response</em><big>)</big></dt>
<dd><p>This method is <em>not</em> defined in <a title="urllib.request.BaseHandler" class="reference internal" href="#urllib.request.BaseHandler"><tt class="xref docutils literal"><span class="pre">BaseHandler</span></tt></a>, but subclasses should
define it if they want to post-process responses of the given protocol.</p>
<p>This method, if defined, will be called by the parent <a title="urllib.request.OpenerDirector" class="reference internal" href="#urllib.request.OpenerDirector"><tt class="xref docutils literal"><span class="pre">OpenerDirector</span></tt></a>.
<em>req</em> will be a <a title="urllib.request.Request" class="reference internal" href="#urllib.request.Request"><tt class="xref docutils literal"><span class="pre">Request</span></tt></a> object. <em>response</em> will be an object
implementing the same interface as the return value of <a title="urllib.request.urlopen" class="reference internal" href="#urllib.request.urlopen"><tt class="xref docutils literal"><span class="pre">urlopen()</span></tt></a>.  The
return value should implement the same interface as the return value of
<a title="urllib.request.urlopen" class="reference internal" href="#urllib.request.urlopen"><tt class="xref docutils literal"><span class="pre">urlopen()</span></tt></a>.</p>
</dd></dl>

</div>
<div class="section" id="httpredirecthandler-objects">
<span id="http-redirect-handler"></span><h2>HTTPRedirectHandler Objects<a class="headerlink" href="#httpredirecthandler-objects" title="Permalink to this headline">¶</a></h2>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Some HTTP redirections require action from this module&#8217;s client code.  If this
is the case, <tt class="xref docutils literal"><span class="pre">HTTPError</span></tt> is raised.  See <span class="target" id="index-593"></span><a class="reference external" href="http://rfc.net/rfc2616.html"><strong>RFC 2616</strong></a> for details of the
precise meanings of the various redirection codes.</p>
</div>
<dl class="method">
<dt id="urllib.request.HTTPRedirectHandler.redirect_request">
<!--[urllib.request.HTTPRedirectHandler.redirect_request]--><tt class="descclassname">HTTPRedirectHandler.</tt><tt class="descname">redirect_request</tt><big>(</big><em>req</em>, <em>fp</em>, <em>code</em>, <em>msg</em>, <em>hdrs</em><big>)</big><a class="headerlink" href="#urllib.request.HTTPRedirectHandler.redirect_request" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a <a title="urllib.request.Request" class="reference internal" href="#urllib.request.Request"><tt class="xref docutils literal"><span class="pre">Request</span></tt></a> or <tt class="xref docutils literal"><span class="pre">None</span></tt> in response to a redirect. This is called
by the default implementations of the <tt class="xref docutils literal"><span class="pre">http_error_30*()</span></tt> methods when a
redirection is received from the server.  If a redirection should take place,
return a new <a title="urllib.request.Request" class="reference internal" href="#urllib.request.Request"><tt class="xref docutils literal"><span class="pre">Request</span></tt></a> to allow <tt class="xref docutils literal"><span class="pre">http_error_30*()</span></tt> to perform the
redirect.  Otherwise, raise <tt class="xref docutils literal"><span class="pre">HTTPError</span></tt> if no other handler should try to
handle this URL, or return <tt class="xref docutils literal"><span class="pre">None</span></tt> if you can&#8217;t but another handler might.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The default implementation of this method does not strictly follow <span class="target" id="index-594"></span><a class="reference external" href="http://rfc.net/rfc2616.html"><strong>RFC 2616</strong></a>,
which says that 301 and 302 responses to <tt class="docutils literal"><span class="pre">POST</span></tt> requests must not be
automatically redirected without confirmation by the user.  In reality, browsers
do allow automatic redirection of these responses, changing the POST to a
<tt class="docutils literal"><span class="pre">GET</span></tt>, and the default implementation reproduces this behavior.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="urllib.request.HTTPRedirectHandler.http_error_301">
<!--[urllib.request.HTTPRedirectHandler.http_error_301]--><tt class="descclassname">HTTPRedirectHandler.</tt><tt class="descname">http_error_301</tt><big>(</big><em>req</em>, <em>fp</em>, <em>code</em>, <em>msg</em>, <em>hdrs</em><big>)</big><a class="headerlink" href="#urllib.request.HTTPRedirectHandler.http_error_301" title="Permalink to this definition">¶</a></dt>
<dd>Redirect to the <tt class="docutils literal"><span class="pre">Location:</span></tt> URL.  This method is called by the parent
<a title="urllib.request.OpenerDirector" class="reference internal" href="#urllib.request.OpenerDirector"><tt class="xref docutils literal"><span class="pre">OpenerDirector</span></tt></a> when getting an HTTP &#8216;moved permanently&#8217; response.</dd></dl>

<dl class="method">
<dt id="urllib.request.HTTPRedirectHandler.http_error_302">
<!--[urllib.request.HTTPRedirectHandler.http_error_302]--><tt class="descclassname">HTTPRedirectHandler.</tt><tt class="descname">http_error_302</tt><big>(</big><em>req</em>, <em>fp</em>, <em>code</em>, <em>msg</em>, <em>hdrs</em><big>)</big><a class="headerlink" href="#urllib.request.HTTPRedirectHandler.http_error_302" title="Permalink to this definition">¶</a></dt>
<dd>The same as <a title="urllib.request.HTTPRedirectHandler.http_error_301" class="reference internal" href="#urllib.request.HTTPRedirectHandler.http_error_301"><tt class="xref docutils literal"><span class="pre">http_error_301()</span></tt></a>, but called for the &#8216;found&#8217; response.</dd></dl>

<dl class="method">
<dt id="urllib.request.HTTPRedirectHandler.http_error_303">
<!--[urllib.request.HTTPRedirectHandler.http_error_303]--><tt class="descclassname">HTTPRedirectHandler.</tt><tt class="descname">http_error_303</tt><big>(</big><em>req</em>, <em>fp</em>, <em>code</em>, <em>msg</em>, <em>hdrs</em><big>)</big><a class="headerlink" href="#urllib.request.HTTPRedirectHandler.http_error_303" title="Permalink to this definition">¶</a></dt>
<dd>The same as <a title="urllib.request.HTTPRedirectHandler.http_error_301" class="reference internal" href="#urllib.request.HTTPRedirectHandler.http_error_301"><tt class="xref docutils literal"><span class="pre">http_error_301()</span></tt></a>, but called for the &#8216;see other&#8217; response.</dd></dl>

<dl class="method">
<dt id="urllib.request.HTTPRedirectHandler.http_error_307">
<!--[urllib.request.HTTPRedirectHandler.http_error_307]--><tt class="descclassname">HTTPRedirectHandler.</tt><tt class="descname">http_error_307</tt><big>(</big><em>req</em>, <em>fp</em>, <em>code</em>, <em>msg</em>, <em>hdrs</em><big>)</big><a class="headerlink" href="#urllib.request.HTTPRedirectHandler.http_error_307" title="Permalink to this definition">¶</a></dt>
<dd>The same as <a title="urllib.request.HTTPRedirectHandler.http_error_301" class="reference internal" href="#urllib.request.HTTPRedirectHandler.http_error_301"><tt class="xref docutils literal"><span class="pre">http_error_301()</span></tt></a>, but called for the &#8216;temporary redirect&#8217;
response.</dd></dl>

</div>
<div class="section" id="httpcookieprocessor-objects">
<span id="http-cookie-processor"></span><h2>HTTPCookieProcessor Objects<a class="headerlink" href="#httpcookieprocessor-objects" title="Permalink to this headline">¶</a></h2>
<p><a title="urllib.request.HTTPCookieProcessor" class="reference internal" href="#urllib.request.HTTPCookieProcessor"><tt class="xref docutils literal"><span class="pre">HTTPCookieProcessor</span></tt></a> instances have one attribute:</p>
<dl class="attribute">
<dt id="urllib.request.HTTPCookieProcessor.cookiejar">
<!--[urllib.request.HTTPCookieProcessor.cookiejar]--><tt class="descclassname">HTTPCookieProcessor.</tt><tt class="descname">cookiejar</tt><a class="headerlink" href="#urllib.request.HTTPCookieProcessor.cookiejar" title="Permalink to this definition">¶</a></dt>
<dd>The <a title="http.cookiejar.CookieJar" class="reference external" href="http.cookiejar.html#http.cookiejar.CookieJar"><tt class="xref docutils literal"><span class="pre">http.cookiejar.CookieJar</span></tt></a> in which cookies are stored.</dd></dl>

</div>
<div class="section" id="proxyhandler-objects">
<span id="proxy-handler"></span><h2>ProxyHandler Objects<a class="headerlink" href="#proxyhandler-objects" title="Permalink to this headline">¶</a></h2>
<dl class="method">
<dt>
<tt class="descclassname">ProxyHandler.</tt><tt class="descname">protocol_open</tt><big>(</big><em>request</em><big>)</big></dt>
<dd>The <a title="urllib.request.ProxyHandler" class="reference internal" href="#urllib.request.ProxyHandler"><tt class="xref docutils literal"><span class="pre">ProxyHandler</span></tt></a> will have a method <tt class="xref docutils literal"><span class="pre">protocol_open()</span></tt> for every
<em>protocol</em> which has a proxy in the <em>proxies</em> dictionary given in the
constructor.  The method will modify requests to go through the proxy, by
calling <tt class="docutils literal"><span class="pre">request.set_proxy()</span></tt>, and call the next handler in the chain to
actually execute the protocol.</dd></dl>

</div>
<div class="section" id="httppasswordmgr-objects">
<span id="http-password-mgr"></span><h2>HTTPPasswordMgr Objects<a class="headerlink" href="#httppasswordmgr-objects" title="Permalink to this headline">¶</a></h2>
<p>These methods are available on <a title="urllib.request.HTTPPasswordMgr" class="reference internal" href="#urllib.request.HTTPPasswordMgr"><tt class="xref docutils literal"><span class="pre">HTTPPasswordMgr</span></tt></a> and
<a title="urllib.request.HTTPPasswordMgrWithDefaultRealm" class="reference internal" href="#urllib.request.HTTPPasswordMgrWithDefaultRealm"><tt class="xref docutils literal"><span class="pre">HTTPPasswordMgrWithDefaultRealm</span></tt></a> objects.</p>
<dl class="method">
<dt id="urllib.request.HTTPPasswordMgr.add_password">
<!--[urllib.request.HTTPPasswordMgr.add_password]--><tt class="descclassname">HTTPPasswordMgr.</tt><tt class="descname">add_password</tt><big>(</big><em>realm</em>, <em>uri</em>, <em>user</em>, <em>passwd</em><big>)</big><a class="headerlink" href="#urllib.request.HTTPPasswordMgr.add_password" title="Permalink to this definition">¶</a></dt>
<dd><em>uri</em> can be either a single URI, or a sequence of URIs. <em>realm</em>, <em>user</em> and
<em>passwd</em> must be strings. This causes <tt class="docutils literal"><span class="pre">(user,</span> <span class="pre">passwd)</span></tt> to be used as
authentication tokens when authentication for <em>realm</em> and a super-URI of any of
the given URIs is given.</dd></dl>

<dl class="method">
<dt id="urllib.request.HTTPPasswordMgr.find_user_password">
<!--[urllib.request.HTTPPasswordMgr.find_user_password]--><tt class="descclassname">HTTPPasswordMgr.</tt><tt class="descname">find_user_password</tt><big>(</big><em>realm</em>, <em>authuri</em><big>)</big><a class="headerlink" href="#urllib.request.HTTPPasswordMgr.find_user_password" title="Permalink to this definition">¶</a></dt>
<dd><p>Get user/password for given realm and URI, if any.  This method will return
<tt class="docutils literal"><span class="pre">(None,</span> <span class="pre">None)</span></tt> if there is no matching user/password.</p>
<p>For <a title="urllib.request.HTTPPasswordMgrWithDefaultRealm" class="reference internal" href="#urllib.request.HTTPPasswordMgrWithDefaultRealm"><tt class="xref docutils literal"><span class="pre">HTTPPasswordMgrWithDefaultRealm</span></tt></a> objects, the realm <tt class="xref docutils literal"><span class="pre">None</span></tt> will be
searched if the given <em>realm</em> has no matching user/password.</p>
</dd></dl>

</div>
<div class="section" id="abstractbasicauthhandler-objects">
<span id="abstract-basic-auth-handler"></span><h2>AbstractBasicAuthHandler Objects<a class="headerlink" href="#abstractbasicauthhandler-objects" title="Permalink to this headline">¶</a></h2>
<dl class="method">
<dt id="urllib.request.AbstractBasicAuthHandler.http_error_auth_reqed">
<!--[urllib.request.AbstractBasicAuthHandler.http_error_auth_reqed]--><tt class="descclassname">AbstractBasicAuthHandler.</tt><tt class="descname">http_error_auth_reqed</tt><big>(</big><em>authreq</em>, <em>host</em>, <em>req</em>, <em>headers</em><big>)</big><a class="headerlink" href="#urllib.request.AbstractBasicAuthHandler.http_error_auth_reqed" title="Permalink to this definition">¶</a></dt>
<dd><p>Handle an authentication request by getting a user/password pair, and re-trying
the request.  <em>authreq</em> should be the name of the header where the information
about the realm is included in the request, <em>host</em> specifies the URL and path to
authenticate for, <em>req</em> should be the (failed) <a title="urllib.request.Request" class="reference internal" href="#urllib.request.Request"><tt class="xref docutils literal"><span class="pre">Request</span></tt></a> object, and
<em>headers</em> should be the error headers.</p>
<p><em>host</em> is either an authority (e.g. <tt class="docutils literal"><span class="pre">&quot;python.org&quot;</span></tt>) or a URL containing an
authority component (e.g. <tt class="docutils literal"><span class="pre">&quot;http://python.org/&quot;</span></tt>). In either case, the
authority must not contain a userinfo component (so, <tt class="docutils literal"><span class="pre">&quot;python.org&quot;</span></tt> and
<tt class="docutils literal"><span class="pre">&quot;python.org:80&quot;</span></tt> are fine, <tt class="docutils literal"><span class="pre">&quot;joe:password&#64;python.org&quot;</span></tt> is not).</p>
</dd></dl>

</div>
<div class="section" id="httpbasicauthhandler-objects">
<span id="http-basic-auth-handler"></span><h2>HTTPBasicAuthHandler Objects<a class="headerlink" href="#httpbasicauthhandler-objects" title="Permalink to this headline">¶</a></h2>
<dl class="method">
<dt id="urllib.request.HTTPBasicAuthHandler.http_error_401">
<!--[urllib.request.HTTPBasicAuthHandler.http_error_401]--><tt class="descclassname">HTTPBasicAuthHandler.</tt><tt class="descname">http_error_401</tt><big>(</big><em>req</em>, <em>fp</em>, <em>code</em>, <em>msg</em>, <em>hdrs</em><big>)</big><a class="headerlink" href="#urllib.request.HTTPBasicAuthHandler.http_error_401" title="Permalink to this definition">¶</a></dt>
<dd>Retry the request with authentication information, if available.</dd></dl>

</div>
<div class="section" id="proxybasicauthhandler-objects">
<span id="proxy-basic-auth-handler"></span><h2>ProxyBasicAuthHandler Objects<a class="headerlink" href="#proxybasicauthhandler-objects" title="Permalink to this headline">¶</a></h2>
<dl class="method">
<dt id="urllib.request.ProxyBasicAuthHandler.http_error_407">
<!--[urllib.request.ProxyBasicAuthHandler.http_error_407]--><tt class="descclassname">ProxyBasicAuthHandler.</tt><tt class="descname">http_error_407</tt><big>(</big><em>req</em>, <em>fp</em>, <em>code</em>, <em>msg</em>, <em>hdrs</em><big>)</big><a class="headerlink" href="#urllib.request.ProxyBasicAuthHandler.http_error_407" title="Permalink to this definition">¶</a></dt>
<dd>Retry the request with authentication information, if available.</dd></dl>

</div>
<div class="section" id="abstractdigestauthhandler-objects">
<span id="abstract-digest-auth-handler"></span><h2>AbstractDigestAuthHandler Objects<a class="headerlink" href="#abstractdigestauthhandler-objects" title="Permalink to this headline">¶</a></h2>
<dl class="method">
<dt id="urllib.request.AbstractDigestAuthHandler.http_error_auth_reqed">
<!--[urllib.request.AbstractDigestAuthHandler.http_error_auth_reqed]--><tt class="descclassname">AbstractDigestAuthHandler.</tt><tt class="descname">http_error_auth_reqed</tt><big>(</big><em>authreq</em>, <em>host</em>, <em>req</em>, <em>headers</em><big>)</big><a class="headerlink" href="#urllib.request.AbstractDigestAuthHandler.http_error_auth_reqed" title="Permalink to this definition">¶</a></dt>
<dd><em>authreq</em> should be the name of the header where the information about the realm
is included in the request, <em>host</em> should be the host to authenticate to, <em>req</em>
should be the (failed) <a title="urllib.request.Request" class="reference internal" href="#urllib.request.Request"><tt class="xref docutils literal"><span class="pre">Request</span></tt></a> object, and <em>headers</em> should be the
error headers.</dd></dl>

</div>
<div class="section" id="httpdigestauthhandler-objects">
<span id="http-digest-auth-handler"></span><h2>HTTPDigestAuthHandler Objects<a class="headerlink" href="#httpdigestauthhandler-objects" title="Permalink to this headline">¶</a></h2>
<dl class="method">
<dt id="urllib.request.HTTPDigestAuthHandler.http_error_401">
<!--[urllib.request.HTTPDigestAuthHandler.http_error_401]--><tt class="descclassname">HTTPDigestAuthHandler.</tt><tt class="descname">http_error_401</tt><big>(</big><em>req</em>, <em>fp</em>, <em>code</em>, <em>msg</em>, <em>hdrs</em><big>)</big><a class="headerlink" href="#urllib.request.HTTPDigestAuthHandler.http_error_401" title="Permalink to this definition">¶</a></dt>
<dd>Retry the request with authentication information, if available.</dd></dl>

</div>
<div class="section" id="proxydigestauthhandler-objects">
<span id="proxy-digest-auth-handler"></span><h2>ProxyDigestAuthHandler Objects<a class="headerlink" href="#proxydigestauthhandler-objects" title="Permalink to this headline">¶</a></h2>
<dl class="method">
<dt id="urllib.request.ProxyDigestAuthHandler.http_error_407">
<!--[urllib.request.ProxyDigestAuthHandler.http_error_407]--><tt class="descclassname">ProxyDigestAuthHandler.</tt><tt class="descname">http_error_407</tt><big>(</big><em>req</em>, <em>fp</em>, <em>code</em>, <em>msg</em>, <em>hdrs</em><big>)</big><a class="headerlink" href="#urllib.request.ProxyDigestAuthHandler.http_error_407" title="Permalink to this definition">¶</a></dt>
<dd>Retry the request with authentication information, if available.</dd></dl>

</div>
<div class="section" id="httphandler-objects">
<span id="http-handler-objects"></span><h2>HTTPHandler Objects<a class="headerlink" href="#httphandler-objects" title="Permalink to this headline">¶</a></h2>
<dl class="method">
<dt id="urllib.request.HTTPHandler.http_open">
<!--[urllib.request.HTTPHandler.http_open]--><tt class="descclassname">HTTPHandler.</tt><tt class="descname">http_open</tt><big>(</big><em>req</em><big>)</big><a class="headerlink" href="#urllib.request.HTTPHandler.http_open" title="Permalink to this definition">¶</a></dt>
<dd>Send an HTTP request, which can be either GET or POST, depending on
<tt class="docutils literal"><span class="pre">req.has_data()</span></tt>.</dd></dl>

</div>
<div class="section" id="httpshandler-objects">
<span id="https-handler-objects"></span><h2>HTTPSHandler Objects<a class="headerlink" href="#httpshandler-objects" title="Permalink to this headline">¶</a></h2>
<dl class="method">
<dt id="urllib.request.HTTPSHandler.https_open">
<!--[urllib.request.HTTPSHandler.https_open]--><tt class="descclassname">HTTPSHandler.</tt><tt class="descname">https_open</tt><big>(</big><em>req</em><big>)</big><a class="headerlink" href="#urllib.request.HTTPSHandler.https_open" title="Permalink to this definition">¶</a></dt>
<dd>Send an HTTPS request, which can be either GET or POST, depending on
<tt class="docutils literal"><span class="pre">req.has_data()</span></tt>.</dd></dl>

</div>
<div class="section" id="filehandler-objects">
<span id="file-handler-objects"></span><h2>FileHandler Objects<a class="headerlink" href="#filehandler-objects" title="Permalink to this headline">¶</a></h2>
<dl class="method">
<dt id="urllib.request.FileHandler.file_open">
<!--[urllib.request.FileHandler.file_open]--><tt class="descclassname">FileHandler.</tt><tt class="descname">file_open</tt><big>(</big><em>req</em><big>)</big><a class="headerlink" href="#urllib.request.FileHandler.file_open" title="Permalink to this definition">¶</a></dt>
<dd>Open the file locally, if there is no host name, or the host name is
<tt class="docutils literal"><span class="pre">'localhost'</span></tt>. Change the protocol to <tt class="docutils literal"><span class="pre">ftp</span></tt> otherwise, and retry opening it
using <tt class="xref docutils literal"><span class="pre">parent</span></tt>.</dd></dl>

</div>
<div class="section" id="ftphandler-objects">
<span id="ftp-handler-objects"></span><h2>FTPHandler Objects<a class="headerlink" href="#ftphandler-objects" title="Permalink to this headline">¶</a></h2>
<dl class="method">
<dt id="urllib.request.FTPHandler.ftp_open">
<!--[urllib.request.FTPHandler.ftp_open]--><tt class="descclassname">FTPHandler.</tt><tt class="descname">ftp_open</tt><big>(</big><em>req</em><big>)</big><a class="headerlink" href="#urllib.request.FTPHandler.ftp_open" title="Permalink to this definition">¶</a></dt>
<dd>Open the FTP file indicated by <em>req</em>. The login is always done with empty
username and password.</dd></dl>

</div>
<div class="section" id="cacheftphandler-objects">
<span id="cacheftp-handler-objects"></span><h2>CacheFTPHandler Objects<a class="headerlink" href="#cacheftphandler-objects" title="Permalink to this headline">¶</a></h2>
<p><a title="urllib.request.CacheFTPHandler" class="reference internal" href="#urllib.request.CacheFTPHandler"><tt class="xref docutils literal"><span class="pre">CacheFTPHandler</span></tt></a> objects are <a title="urllib.request.FTPHandler" class="reference internal" href="#urllib.request.FTPHandler"><tt class="xref docutils literal"><span class="pre">FTPHandler</span></tt></a> objects with the
following additional methods:</p>
<dl class="method">
<dt id="urllib.request.CacheFTPHandler.setTimeout">
<!--[urllib.request.CacheFTPHandler.setTimeout]--><tt class="descclassname">CacheFTPHandler.</tt><tt class="descname">setTimeout</tt><big>(</big><em>t</em><big>)</big><a class="headerlink" href="#urllib.request.CacheFTPHandler.setTimeout" title="Permalink to this definition">¶</a></dt>
<dd>Set timeout of connections to <em>t</em> seconds.</dd></dl>

<dl class="method">
<dt id="urllib.request.CacheFTPHandler.setMaxConns">
<!--[urllib.request.CacheFTPHandler.setMaxConns]--><tt class="descclassname">CacheFTPHandler.</tt><tt class="descname">setMaxConns</tt><big>(</big><em>m</em><big>)</big><a class="headerlink" href="#urllib.request.CacheFTPHandler.setMaxConns" title="Permalink to this definition">¶</a></dt>
<dd>Set maximum number of cached connections to <em>m</em>.</dd></dl>

</div>
<div class="section" id="unknownhandler-objects">
<span id="unknown-handler-objects"></span><h2>UnknownHandler Objects<a class="headerlink" href="#unknownhandler-objects" title="Permalink to this headline">¶</a></h2>
<dl class="method">
<dt id="urllib.request.UnknownHandler.unknown_open">
<!--[urllib.request.UnknownHandler.unknown_open]--><tt class="descclassname">UnknownHandler.</tt><tt class="descname">unknown_open</tt><big>(</big><big>)</big><a class="headerlink" href="#urllib.request.UnknownHandler.unknown_open" title="Permalink to this definition">¶</a></dt>
<dd>Raise a <tt class="xref docutils literal"><span class="pre">URLError</span></tt> exception.</dd></dl>

</div>
<div class="section" id="httperrorprocessor-objects">
<span id="http-error-processor-objects"></span><h2>HTTPErrorProcessor Objects<a class="headerlink" href="#httperrorprocessor-objects" title="Permalink to this headline">¶</a></h2>
<dl class="method">
<dt id="urllib.request.HTTPErrorProcessor.unknown_open">
<!--[urllib.request.HTTPErrorProcessor.unknown_open]--><tt class="descclassname">HTTPErrorProcessor.</tt><tt class="descname">unknown_open</tt><big>(</big><big>)</big><a class="headerlink" href="#urllib.request.HTTPErrorProcessor.unknown_open" title="Permalink to this definition">¶</a></dt>
<dd><p>Process HTTP error responses.</p>
<p>For 200 error codes, the response object is returned immediately.</p>
<p>For non-200 error codes, this simply passes the job on to the
<tt class="xref docutils literal"><span class="pre">protocol_error_code()</span></tt> handler methods, via <a title="urllib.request.OpenerDirector.error" class="reference internal" href="#urllib.request.OpenerDirector.error"><tt class="xref docutils literal"><span class="pre">OpenerDirector.error()</span></tt></a>.
Eventually, <a title="urllib.request.HTTPDefaultErrorHandler" class="reference internal" href="#urllib.request.HTTPDefaultErrorHandler"><tt class="xref docutils literal"><span class="pre">HTTPDefaultErrorHandler</span></tt></a> will raise an
<tt class="xref docutils literal"><span class="pre">HTTPError</span></tt> if no other handler handles the error.</p>
</dd></dl>

</div>
<div class="section" id="examples">
<span id="urllib-request-examples"></span><h2>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h2>
<p>This example gets the python.org main page and displays the first 100 bytes of
it:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="s">&#39;http://www.python.org/&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mf">100</span><span class="p">))</span>
<span class="go">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;</span>
<span class="go">&lt;?xml-stylesheet href=&quot;./css/ht2html</span>
</pre></div>
<p>Here we are sending a data-stream to the stdin of a CGI and reading the data it
returns to us. Note that this example will only work when the Python
installation supports SSL.</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">req</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">Request</span><span class="p">(</span><span class="n">url</span><span class="o">=</span><span class="s">&#39;https://localhost/cgi-bin/test.cgi&#39;</span><span class="p">,</span>
<span class="gp">... </span>                      <span class="n">data</span><span class="o">=</span><span class="s">&#39;This data is passed to stdin of the CGI&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="n">req</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>
<span class="go">Got Data: &quot;This data is passed to stdin of the CGI&quot;</span>
</pre></div>
<p>The code for the sample CGI used in the above example is:</p>
<div class="highlight"><pre><span class="c">#!/usr/bin/env python</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s">&#39;Content-type: text-plain</span><span class="se">\n\n</span><span class="s">Got Data: &quot;%s&quot;&#39;</span> <span class="o">%</span> <span class="n">data</span><span class="p">)</span>
</pre></div>
<p>Use of Basic HTTP Authentication:</p>
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="c"># Create an OpenerDirector with support for Basic HTTP Authentication...</span>
<span class="n">auth_handler</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">HTTPBasicAuthHandler</span><span class="p">()</span>
<span class="n">auth_handler</span><span class="o">.</span><span class="n">add_password</span><span class="p">(</span><span class="n">realm</span><span class="o">=</span><span class="s">&#39;PDQ Application&#39;</span><span class="p">,</span>
                          <span class="n">uri</span><span class="o">=</span><span class="s">&#39;https://mahler:8092/site-updates.py&#39;</span><span class="p">,</span>
                          <span class="n">user</span><span class="o">=</span><span class="s">&#39;klem&#39;</span><span class="p">,</span>
                          <span class="n">passwd</span><span class="o">=</span><span class="s">&#39;kadidd!ehopper&#39;</span><span class="p">)</span>
<span class="n">opener</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">build_opener</span><span class="p">(</span><span class="n">auth_handler</span><span class="p">)</span>
<span class="c"># ...and install it globally so it can be used with urlopen.</span>
<span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">install_opener</span><span class="p">(</span><span class="n">opener</span><span class="p">)</span>
<span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="s">&#39;http://www.example.com/login.html&#39;</span><span class="p">)</span>
</pre></div>
<p><a title="urllib.request.build_opener" class="reference internal" href="#urllib.request.build_opener"><tt class="xref docutils literal"><span class="pre">build_opener()</span></tt></a> provides many handlers by default, including a
<a title="urllib.request.ProxyHandler" class="reference internal" href="#urllib.request.ProxyHandler"><tt class="xref docutils literal"><span class="pre">ProxyHandler</span></tt></a>.  By default, <a title="urllib.request.ProxyHandler" class="reference internal" href="#urllib.request.ProxyHandler"><tt class="xref docutils literal"><span class="pre">ProxyHandler</span></tt></a> uses the environment
variables named <tt class="docutils literal"><span class="pre">&lt;scheme&gt;_proxy</span></tt>, where <tt class="docutils literal"><span class="pre">&lt;scheme&gt;</span></tt> is the URL scheme
involved.  For example, the <span class="target" id="index-595"></span><strong class="xref">http_proxy</strong> environment variable is read to
obtain the HTTP proxy&#8217;s URL.</p>
<p>This example replaces the default <a title="urllib.request.ProxyHandler" class="reference internal" href="#urllib.request.ProxyHandler"><tt class="xref docutils literal"><span class="pre">ProxyHandler</span></tt></a> with one that uses
programmatically-supplied proxy URLs, and adds proxy authorization support with
<a title="urllib.request.ProxyBasicAuthHandler" class="reference internal" href="#urllib.request.ProxyBasicAuthHandler"><tt class="xref docutils literal"><span class="pre">ProxyBasicAuthHandler</span></tt></a>.</p>
<div class="highlight"><pre><span class="n">proxy_handler</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">ProxyHandler</span><span class="p">({</span><span class="s">&#39;http&#39;</span><span class="p">:</span> <span class="s">&#39;http://www.example.com:3128/&#39;</span><span class="p">})</span>
<span class="n">proxy_auth_handler</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">HTTPBasicAuthHandler</span><span class="p">()</span>
<span class="n">proxy_auth_handler</span><span class="o">.</span><span class="n">add_password</span><span class="p">(</span><span class="s">&#39;realm&#39;</span><span class="p">,</span> <span class="s">&#39;host&#39;</span><span class="p">,</span> <span class="s">&#39;username&#39;</span><span class="p">,</span> <span class="s">&#39;password&#39;</span><span class="p">)</span>

<span class="n">opener</span> <span class="o">=</span> <span class="n">build_opener</span><span class="p">(</span><span class="n">proxy_handler</span><span class="p">,</span> <span class="n">proxy_auth_handler</span><span class="p">)</span>
<span class="c"># This time, rather than install the OpenerDirector, we use it directly:</span>
<span class="n">opener</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s">&#39;http://www.example.com/login.html&#39;</span><span class="p">)</span>
</pre></div>
<p>Adding HTTP headers:</p>
<p>Use the <em>headers</em> argument to the <a title="urllib.request.Request" class="reference internal" href="#urllib.request.Request"><tt class="xref docutils literal"><span class="pre">Request</span></tt></a> constructor, or:</p>
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="n">req</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">Request</span><span class="p">(</span><span class="s">&#39;http://www.example.com/&#39;</span><span class="p">)</span>
<span class="n">req</span><span class="o">.</span><span class="n">add_header</span><span class="p">(</span><span class="s">&#39;Referer&#39;</span><span class="p">,</span> <span class="s">&#39;http://www.python.org/&#39;</span><span class="p">)</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="n">req</span><span class="p">)</span>
</pre></div>
<p><a title="urllib.request.OpenerDirector" class="reference internal" href="#urllib.request.OpenerDirector"><tt class="xref docutils literal"><span class="pre">OpenerDirector</span></tt></a> automatically adds a <em>User-Agent</em> header to
every <a title="urllib.request.Request" class="reference internal" href="#urllib.request.Request"><tt class="xref docutils literal"><span class="pre">Request</span></tt></a>.  To change this:</p>
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="n">opener</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">build_opener</span><span class="p">()</span>
<span class="n">opener</span><span class="o">.</span><span class="n">addheaders</span> <span class="o">=</span> <span class="p">[(</span><span class="s">&#39;User-agent&#39;</span><span class="p">,</span> <span class="s">&#39;Mozilla/5.0&#39;</span><span class="p">)]</span>
<span class="n">opener</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s">&#39;http://www.example.com/&#39;</span><span class="p">)</span>
</pre></div>
<p>Also, remember that a few standard headers (<em>Content-Length</em>,
<em>Content-Type</em> and <em>Host</em>) are added when the
<a title="urllib.request.Request" class="reference internal" href="#urllib.request.Request"><tt class="xref docutils literal"><span class="pre">Request</span></tt></a> is passed to <a title="urllib.request.urlopen" class="reference internal" href="#urllib.request.urlopen"><tt class="xref docutils literal"><span class="pre">urlopen()</span></tt></a> (or <a title="urllib.request.OpenerDirector.open" class="reference internal" href="#urllib.request.OpenerDirector.open"><tt class="xref docutils literal"><span class="pre">OpenerDirector.open()</span></tt></a>).</p>
<p id="urllib-examples">Here is an example session that uses the <tt class="docutils literal"><span class="pre">GET</span></tt> method to retrieve a URL
containing parameters:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.parse</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">params</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">parse</span><span class="o">.</span><span class="n">urlencode</span><span class="p">({</span><span class="s">&#39;spam&#39;</span><span class="p">:</span> <span class="mf">1</span><span class="p">,</span> <span class="s">&#39;eggs&#39;</span><span class="p">:</span> <span class="mf">2</span><span class="p">,</span> <span class="s">&#39;bacon&#39;</span><span class="p">:</span> <span class="mf">0</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="s">&quot;http://www.musi-cal.com/cgi-bin/query?</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">params</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>
</pre></div>
<p>The following example uses the <tt class="docutils literal"><span class="pre">POST</span></tt> method instead:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.parse</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">params</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">parse</span><span class="o">.</span><span class="n">urlencode</span><span class="p">({</span><span class="s">&#39;spam&#39;</span><span class="p">:</span> <span class="mf">1</span><span class="p">,</span> <span class="s">&#39;eggs&#39;</span><span class="p">:</span> <span class="mf">2</span><span class="p">,</span> <span class="s">&#39;bacon&#39;</span><span class="p">:</span> <span class="mf">0</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="s">&quot;http://www.musi-cal.com/cgi-bin/query&quot;</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>
</pre></div>
<p>The following example uses an explicitly specified HTTP proxy, overriding
environment settings:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">proxies</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;http&#39;</span><span class="p">:</span> <span class="s">&#39;http://proxy.example.com:8080/&#39;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">opener</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">FancyURLopener</span><span class="p">(</span><span class="n">proxies</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">opener</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s">&quot;http://www.python.org&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
</pre></div>
<p>The following example uses no proxies at all, overriding environment settings:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">urllib.request</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">opener</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">FancyURLopener</span><span class="p">({})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">opener</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s">&quot;http://www.python.org/&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
</pre></div>
</div>
<div class="section" id="urllib-request-restrictions">
<h2><tt class="xref docutils literal"><span class="pre">urllib.request</span></tt> Restrictions<a class="headerlink" href="#urllib-request-restrictions" title="Permalink to this headline">¶</a></h2>
<blockquote>
</blockquote>
<ul id="index-596">
<li><p class="first">Currently, only the following protocols are supported: HTTP, (versions 0.9 and
1.0),  FTP, and local files.</p>
</li>
<li><p class="first">The caching feature of <a title="urllib.request.urlretrieve" class="reference internal" href="#urllib.request.urlretrieve"><tt class="xref docutils literal"><span class="pre">urlretrieve()</span></tt></a> has been disabled until I find the
time to hack proper processing of Expiration time headers.</p>
</li>
<li><p class="first">There should be a function to query whether a particular URL is in the cache.</p>
</li>
<li><p class="first">For backward compatibility, if a URL appears to point to a local file but the
file can&#8217;t be opened, the URL is re-interpreted using the FTP protocol.  This
can sometimes cause confusing error messages.</p>
</li>
<li><p class="first">The <a title="urllib.request.urlopen" class="reference internal" href="#urllib.request.urlopen"><tt class="xref docutils literal"><span class="pre">urlopen()</span></tt></a> and <a title="urllib.request.urlretrieve" class="reference internal" href="#urllib.request.urlretrieve"><tt class="xref docutils literal"><span class="pre">urlretrieve()</span></tt></a> functions can cause arbitrarily
long delays while waiting for a network connection to be set up.  This means
that it is difficult to build an interactive Web client using these functions
without using threads.</p>
</li>
<li id="index-597"><p class="first">The data returned by <a title="urllib.request.urlopen" class="reference internal" href="#urllib.request.urlopen"><tt class="xref docutils literal"><span class="pre">urlopen()</span></tt></a> or <a title="urllib.request.urlretrieve" class="reference internal" href="#urllib.request.urlretrieve"><tt class="xref docutils literal"><span class="pre">urlretrieve()</span></tt></a> is the raw data
returned by the server.  This may be binary data (such as an image), plain text
or (for example) HTML.  The HTTP protocol provides type information in the reply
header, which can be inspected by looking at the <em>Content-Type</em>
header.  If the returned data is HTML, you can use the module
<a title="A simple parser that can handle HTML and XHTML." class="reference external" href="html.parser.html"><tt class="xref docutils literal"><span class="pre">html.parser</span></tt></a> to parse it.</p>
</li>
<li id="index-598"><p class="first">The code handling the FTP protocol cannot differentiate between a file and a
directory.  This can lead to unexpected behavior when attempting to read a URL
that points to a file that is not accessible.  If the URL ends in a <tt class="docutils literal"><span class="pre">/</span></tt>, it is
assumed to refer to a directory and will be handled accordingly.  But if an
attempt to read a file leads to a 550 error (meaning the URL cannot be found or
is not accessible, often for permission reasons), then the path is treated as a
directory in order to handle the case when a directory is specified by a URL but
the trailing <tt class="docutils literal"><span class="pre">/</span></tt> has been left off.  This can cause misleading results when
you try to fetch a file whose read permissions make it inaccessible; the FTP
code will try to read it, fail with a 550 error, and then perform a directory
listing for the unreadable file. If fine-grained control is needed, consider
using the <a title="FTP protocol client (requires sockets)." class="reference external" href="ftplib.html"><tt class="xref docutils literal"><span class="pre">ftplib</span></tt></a> module, subclassing <tt class="xref docutils literal"><span class="pre">FancyURLOpener</span></tt>, or changing
<em>_urlopener</em> to meet your needs.</p>
</li>
</ul>
</div>
</div>
<div class="section" id="module-urllib.response">
<h1><tt class="xref docutils literal"><span class="pre">urllib.response</span></tt> &#8212; Response classes used by urllib.<a class="headerlink" href="#module-urllib.response" title="Permalink to this headline">¶</a></h1>
<p>The <tt class="xref docutils literal"><span class="pre">urllib.response</span></tt> module defines functions and classes which define a
minimal file like interface, including <tt class="docutils literal"><span class="pre">read()</span></tt> and <tt class="docutils literal"><span class="pre">readline()</span></tt>. The
typical response object is an addinfourl instance, which defines and <tt class="docutils literal"><span class="pre">info()</span></tt>
method and that returns headers and a <tt class="docutils literal"><span class="pre">geturl()</span></tt> method that returns the url.
Functions defined by this module are used internally by the
<tt class="xref docutils literal"><span class="pre">urllib.request</span></tt> module.</p>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <h3><a href="../contents.html">Table Of Contents</a></h3>
            <ul>
<li><a class="reference external" href=""><tt class="docutils literal"><span class="pre">urllib.request</span></tt> &#8212; extensible library for opening URLs</a><ul>
<li><a class="reference external" href="#id1">Request Objects</a></li>
<li><a class="reference external" href="#openerdirector-objects">OpenerDirector Objects</a></li>
<li><a class="reference external" href="#basehandler-objects">BaseHandler Objects</a></li>
<li><a class="reference external" href="#httpredirecthandler-objects">HTTPRedirectHandler Objects</a></li>
<li><a class="reference external" href="#httpcookieprocessor-objects">HTTPCookieProcessor Objects</a></li>
<li><a class="reference external" href="#proxyhandler-objects">ProxyHandler Objects</a></li>
<li><a class="reference external" href="#httppasswordmgr-objects">HTTPPasswordMgr Objects</a></li>
<li><a class="reference external" href="#abstractbasicauthhandler-objects">AbstractBasicAuthHandler Objects</a></li>
<li><a class="reference external" href="#httpbasicauthhandler-objects">HTTPBasicAuthHandler Objects</a></li>
<li><a class="reference external" href="#proxybasicauthhandler-objects">ProxyBasicAuthHandler Objects</a></li>
<li><a class="reference external" href="#abstractdigestauthhandler-objects">AbstractDigestAuthHandler Objects</a></li>
<li><a class="reference external" href="#httpdigestauthhandler-objects">HTTPDigestAuthHandler Objects</a></li>
<li><a class="reference external" href="#proxydigestauthhandler-objects">ProxyDigestAuthHandler Objects</a></li>
<li><a class="reference external" href="#httphandler-objects">HTTPHandler Objects</a></li>
<li><a class="reference external" href="#httpshandler-objects">HTTPSHandler Objects</a></li>
<li><a class="reference external" href="#filehandler-objects">FileHandler Objects</a></li>
<li><a class="reference external" href="#ftphandler-objects">FTPHandler Objects</a></li>
<li><a class="reference external" href="#cacheftphandler-objects">CacheFTPHandler Objects</a></li>
<li><a class="reference external" href="#unknownhandler-objects">UnknownHandler Objects</a></li>
<li><a class="reference external" href="#httperrorprocessor-objects">HTTPErrorProcessor Objects</a></li>
<li><a class="reference external" href="#examples">Examples</a></li>
<li><a class="reference external" href="#urllib-request-restrictions"><tt class="docutils literal"><span class="pre">urllib.request</span></tt> Restrictions</a></li>
</ul>
</li>
<li><a class="reference external" href="#module-urllib.response"><tt class="docutils literal"><span class="pre">urllib.response</span></tt> &#8212; Response classes used by urllib.</a></li>
</ul>

            <h4>Previous topic</h4>
            <p class="topless"><a href="wsgiref.html" title="previous chapter"><tt class="docutils literal docutils literal"><span class="pre">wsgiref</span></tt> &#8212; WSGI Utilities and Reference Implementation</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="urllib.parse.html" title="next chapter"><tt class="docutils literal docutils literal docutils literal"><span class="pre">urllib.parse</span></tt> &#8212; Parse URLs into components</a></p>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="../_sources/library/urllib.request.txt">Show Source</a></li>
            </ul>
          <h3>Quick search</h3>
            <form class="search" action="../search.html" method="get">
              <input type="text" name="q" size="18" /> <input type="submit" value="Go" />
              <input type="hidden" name="check_keywords" value="yes" />
              <input type="hidden" name="area" value="default" />
            </form>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../modindex.html" title="Global Module Index"
             accesskey="M">modules</a> |</li>
        <li class="right" >
          <a href="urllib.parse.html" title="urllib.parse &#8212; Parse URLs into components"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="wsgiref.html" title="wsgiref &#8212; WSGI Utilities and Reference Implementation"
             accesskey="P">previous</a> |</li>
<li><img src="../_static/py.png" alt="" style="vertical-align: middle; margin-top: -1px"/></li>

        <li><a href="../contents.html">Python v3.0c1 documentation</a> &raquo;</li>

          <li><a href="index.html" accesskey="U">The Python Standard Library</a> &raquo;</li>
          <li><a href="internet.html" accesskey="U">Internet Protocols and Support</a> &raquo;</li>
      </ul>
    </div>
    <div class="footer">
      &copy; <a href="../copyright.html">Copyright</a> 1990-2008, Python Software Foundation.
      Last updated on Oct 31, 2008.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 0.5.
    </div>
  </body>
</html>