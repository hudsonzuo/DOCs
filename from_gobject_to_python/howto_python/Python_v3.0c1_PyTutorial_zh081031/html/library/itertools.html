<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>itertools &#8212; Functions creating iterators for efficient looping &mdash; Python v3.0c1 documentation</title>
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
          URL_ROOT:    '../',
          VERSION:     '3.0c1',
          COLLAPSE_MODINDEX: false,
          FILE_SUFFIX: '.html'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Python v3.0c1 documentation"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="Python v3.0c1 documentation" href="../index.html" />
    <link rel="up" title="Numeric and Mathematical Modules" href="numeric.html" />
    <link rel="next" title="functools &#8212; Higher order functions and operations on callable objects" href="functools.html" />
    <link rel="prev" title="random &#8212; Generate pseudo-random numbers" href="random.html" />
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../modindex.html" title="Global Module Index"
             accesskey="M">modules</a> |</li>
        <li class="right" >
          <a href="functools.html" title="functools &#8212; Higher order functions and operations on callable objects"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="random.html" title="random &#8212; Generate pseudo-random numbers"
             accesskey="P">previous</a> |</li>
<li><img src="../_static/py.png" alt="" style="vertical-align: middle; margin-top: -1px"/></li>

        <li><a href="../contents.html">Python v3.0c1 documentation</a> &raquo;</li>

          <li><a href="index.html" accesskey="U">The Python Standard Library</a> &raquo;</li>
          <li><a href="numeric.html" accesskey="U">Numeric and Mathematical Modules</a> &raquo;</li>
      </ul>
    </div>
    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  
  <div class="section" id="module-itertools">
<h1><tt class="xref docutils literal"><span class="pre">itertools</span></tt> &#8212; Functions creating iterators for efficient looping<a class="headerlink" href="#module-itertools" title="Permalink to this headline">¶</a></h1>
<p>This module implements a number of <a class="reference external" href="../glossary.html#term-iterator"><em class="xref">iterator</em></a> building blocks inspired by
constructs from the Haskell and SML programming languages.  Each has been recast
in a form suitable for Python.</p>
<p>The module standardizes a core set of fast, memory efficient tools that are
useful by themselves or in combination.  Standardization helps avoid the
readability and reliability problems which arise when many different individuals
create their own slightly varying implementations, each with their own quirks
and naming conventions.</p>
<p>The tools are designed to combine readily with one another.  This makes it easy
to construct more specialized tools succinctly and efficiently in pure Python.</p>
<p>For instance, SML provides a tabulation tool: <tt class="docutils literal"><span class="pre">tabulate(f)</span></tt> which produces a
sequence <tt class="docutils literal"><span class="pre">f(0),</span> <span class="pre">f(1),</span> <span class="pre">...</span></tt>.  But, this effect can be achieved in Python
by combining <a title="map" class="reference external" href="functions.html#map"><tt class="xref docutils literal"><span class="pre">map()</span></tt></a> and <a title="itertools.count" class="reference internal" href="#itertools.count"><tt class="xref docutils literal"><span class="pre">count()</span></tt></a> to form <tt class="docutils literal"><span class="pre">map(f,</span> <span class="pre">count())</span></tt>.</p>
<p>Likewise, the functional tools are designed to work well with the high-speed
functions provided by the <a title="Functions corresponding to the standard operators." class="reference external" href="operator.html"><tt class="xref docutils literal"><span class="pre">operator</span></tt></a> module.</p>
<p>Whether cast in pure python form or compiled code, tools that use iterators are
more memory efficient (and often faster) than their list based counterparts. Adopting
the principles of just-in-time manufacturing, they create data when and where
needed instead of consuming memory with the computer equivalent of &#8220;inventory&#8221;.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p>The Standard ML Basis Library, <a class="reference external" href="http://www.standardml.org/Basis/">The Standard ML Basis Library</a>.</p>
<p class="last">Haskell, A Purely Functional Language, <a class="reference external" href="http://www.haskell.org/definition/">Definition of Haskell and the Standard
Libraries</a>.</p>
</div>
<div class="section" id="itertool-functions">
<span id="itertools-functions"></span><h2>Itertool functions<a class="headerlink" href="#itertool-functions" title="Permalink to this headline">¶</a></h2>
<p>The following module functions all construct and return iterators. Some provide
streams of infinite length, so they should only be accessed by functions or
loops that truncate the stream.</p>
<dl class="function">
<dt id="itertools.chain">
<!--[itertools.chain]--><tt class="descclassname">itertools.</tt><tt class="descname">chain</tt><big>(</big><em>*iterables</em><big>)</big><a class="headerlink" href="#itertools.chain" title="Permalink to this definition">¶</a></dt>
<dd><p>Make an iterator that returns elements from the first iterable until it is
exhausted, then proceeds to the next iterable, until all of the iterables are
exhausted.  Used for treating consecutive sequences as a single sequence.
Equivalent to:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">chain</span><span class="p">(</span><span class="o">*</span><span class="n">iterables</span><span class="p">):</span>
    <span class="c"># chain(&#39;ABC&#39;, &#39;DEF&#39;) --&gt; A B C D E F</span>
    <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">iterables</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">element</span>
</pre></div>
</dd></dl>

<dl class="function">
<dt id="itertools.itertools.chain.from_iterable">
<!--[itertools.itertools.chain.from_iterable]--><tt class="descclassname">itertools.chain.</tt><tt class="descname">from_iterable</tt><big>(</big><em>iterable</em><big>)</big><a class="headerlink" href="#itertools.itertools.chain.from_iterable" title="Permalink to this definition">¶</a></dt>
<dd><p>Alternate constructor for <a title="itertools.chain" class="reference internal" href="#itertools.chain"><tt class="xref docutils literal"><span class="pre">chain()</span></tt></a>.  Gets chained inputs from a
single iterable argument that is evaluated lazily.  Equivalent to:</p>
<div class="highlight"><pre><span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">from_iterable</span><span class="p">(</span><span class="n">iterables</span><span class="p">):</span>
    <span class="c"># chain.from_iterable([&#39;ABC&#39;, &#39;DEF&#39;]) --&gt; A B C D E F</span>
    <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">iterables</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">element</span>
</pre></div>
</dd></dl>

<dl class="function">
<dt id="itertools.combinations">
<!--[itertools.combinations]--><tt class="descclassname">itertools.</tt><tt class="descname">combinations</tt><big>(</big><em>iterable</em>, <em>r</em><big>)</big><a class="headerlink" href="#itertools.combinations" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <em>r</em> length subsequences of elements from the input <em>iterable</em>.</p>
<p>Combinations are emitted in lexicographic sort order.  So, if the
input <em>iterable</em> is sorted, the combination tuples will be produced
in sorted order.</p>
<p>Elements are treated as unique based on their position, not on their
value.  So if the input elements are unique, there will be no repeat
values in each combination.</p>
<p>Equivalent to:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">combinations</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
    <span class="c"># combinations(&#39;ABCD&#39;, 2) --&gt; AB AC AD BC BD CD</span>
    <span class="c"># combinations(range(4), 3) --&gt; 012 013 023 123</span>
    <span class="n">pool</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pool</span><span class="p">)</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="k">yield</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">pool</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">)</span>
    <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">r</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">n</span> <span class="o">-</span> <span class="n">r</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
            <span class="n">indices</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">yield</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">pool</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">)</span>
</pre></div>
<p>The code for <a title="itertools.combinations" class="reference internal" href="#itertools.combinations"><tt class="xref docutils literal"><span class="pre">combinations()</span></tt></a> can be also expressed as a subsequence
of <a title="itertools.permutations" class="reference internal" href="#itertools.permutations"><tt class="xref docutils literal"><span class="pre">permutations()</span></tt></a> after filtering entries where the elements are not
in sorted order (according to their position in the input pool):</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">combinations</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
    <span class="n">pool</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pool</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">indices</span> <span class="ow">in</span> <span class="n">permutations</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">r</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">(</span><span class="n">indices</span><span class="p">):</span>
            <span class="k">yield</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">pool</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">)</span>
</pre></div>
</dd></dl>

<dl class="function">
<dt id="itertools.count">
<!--[itertools.count]--><tt class="descclassname">itertools.</tt><tt class="descname">count</tt><big>(</big><span class="optional">[</span><em>n</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#itertools.count" title="Permalink to this definition">¶</a></dt>
<dd><p>Make an iterator that returns consecutive integers starting with <em>n</em>. If not
specified <em>n</em> defaults to zero.   Often used as an argument to <a title="map" class="reference external" href="functions.html#map"><tt class="xref docutils literal"><span class="pre">map()</span></tt></a> to
generate consecutive data points. Also, used with <a title="zip" class="reference external" href="functions.html#zip"><tt class="xref docutils literal"><span class="pre">zip()</span></tt></a> to add sequence
numbers.  Equivalent to:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="c"># count(10) --&gt; 10 11 12 13 14 ...</span>
    <span class="k">while</span> <span class="k">True</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">n</span>
        <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</dd></dl>

<dl class="function">
<dt id="itertools.cycle">
<!--[itertools.cycle]--><tt class="descclassname">itertools.</tt><tt class="descname">cycle</tt><big>(</big><em>iterable</em><big>)</big><a class="headerlink" href="#itertools.cycle" title="Permalink to this definition">¶</a></dt>
<dd><p>Make an iterator returning elements from the iterable and saving a copy of each.
When the iterable is exhausted, return elements from the saved copy.  Repeats
indefinitely.  Equivalent to:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">cycle</span><span class="p">(</span><span class="n">iterable</span><span class="p">):</span>
    <span class="c"># cycle(&#39;ABCD&#39;) --&gt; A B C D A B C D A B C D ...</span>
    <span class="n">saved</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">element</span>
        <span class="n">saved</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">saved</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">saved</span><span class="p">:</span>
              <span class="k">yield</span> <span class="n">element</span>
</pre></div>
<p>Note, this member of the toolkit may require significant auxiliary storage
(depending on the length of the iterable).</p>
</dd></dl>

<dl class="function">
<dt id="itertools.dropwhile">
<!--[itertools.dropwhile]--><tt class="descclassname">itertools.</tt><tt class="descname">dropwhile</tt><big>(</big><em>predicate</em>, <em>iterable</em><big>)</big><a class="headerlink" href="#itertools.dropwhile" title="Permalink to this definition">¶</a></dt>
<dd><p>Make an iterator that drops elements from the iterable as long as the predicate
is true; afterwards, returns every element.  Note, the iterator does not produce
<em>any</em> output until the predicate first becomes false, so it may have a lengthy
start-up time.  Equivalent to:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">dropwhile</span><span class="p">(</span><span class="n">predicate</span><span class="p">,</span> <span class="n">iterable</span><span class="p">):</span>
    <span class="c"># dropwhile(lambda x: x&lt;5, [1,4,6,4,1]) --&gt; 6 4 1</span>
    <span class="n">iterable</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">predicate</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">x</span>
            <span class="k">break</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">x</span>
</pre></div>
</dd></dl>

<dl class="function">
<dt id="itertools.groupby">
<!--[itertools.groupby]--><tt class="descclassname">itertools.</tt><tt class="descname">groupby</tt><big>(</big><em>iterable</em><span class="optional">[</span>, <em>key</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#itertools.groupby" title="Permalink to this definition">¶</a></dt>
<dd><p>Make an iterator that returns consecutive keys and groups from the <em>iterable</em>.
The <em>key</em> is a function computing a key value for each element.  If not
specified or is <tt class="xref docutils literal"><span class="pre">None</span></tt>, <em>key</em> defaults to an identity function and returns
the element unchanged.  Generally, the iterable needs to already be sorted on
the same key function.</p>
<p>The operation of <a title="itertools.groupby" class="reference internal" href="#itertools.groupby"><tt class="xref docutils literal"><span class="pre">groupby()</span></tt></a> is similar to the <tt class="docutils literal"><span class="pre">uniq</span></tt> filter in Unix.  It
generates a break or new group every time the value of the key function changes
(which is why it is usually necessary to have sorted the data using the same key
function).  That behavior differs from SQL&#8217;s GROUP BY which aggregates common
elements regardless of their input order.</p>
<p>The returned group is itself an iterator that shares the underlying iterable
with <a title="itertools.groupby" class="reference internal" href="#itertools.groupby"><tt class="xref docutils literal"><span class="pre">groupby()</span></tt></a>.  Because the source is shared, when the <a title="itertools.groupby" class="reference internal" href="#itertools.groupby"><tt class="xref docutils literal"><span class="pre">groupby()</span></tt></a>
object is advanced, the previous group is no longer visible.  So, if that data
is needed later, it should be stored as a list:</p>
<div class="highlight"><pre><span class="n">groups</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">uniquekeys</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">data</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">keyfunc</span><span class="p">)</span>
<span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">groupby</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">keyfunc</span><span class="p">):</span>
    <span class="n">groups</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">g</span><span class="p">))</span>      <span class="c"># Store group iterator as a list</span>
    <span class="n">uniquekeys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
</pre></div>
<p><a title="itertools.groupby" class="reference internal" href="#itertools.groupby"><tt class="xref docutils literal"><span class="pre">groupby()</span></tt></a> is equivalent to:</p>
<pre>class groupby(object):
    # [k for k, g in groupby('AAAABBBCCDAABBB')] --&gt; A B C D A B
    # [(list(g)) for k, g in groupby('AAAABBBCCD')] --&gt; AAAA BBB CC D
    def __init__(self, iterable, key=None):
        if key is None:
            key = lambda x: x
        self.keyfunc = key
        self.it = iter(iterable)
        self.tgtkey = self.currkey = self.currvalue = object()
    def __iter__(self):
        return self
    def __next__(self):
        while self.currkey == self.tgtkey:
            self.currvalue = next(self.it) # Exit on StopIteration
            self.currkey = self.keyfunc(self.currvalue)
        self.tgtkey = self.currkey
        return (self.currkey, self._grouper(self.tgtkey))
    def _grouper(self, tgtkey):
        while self.currkey == tgtkey:
            yield self.currvalue
            self.currvalue = next(self.it) # Exit on StopIteration
            self.currkey = self.keyfunc(self.currvalue)</pre>
</dd></dl>

<dl class="function">
<dt id="itertools.filterfalse">
<!--[itertools.filterfalse]--><tt class="descclassname">itertools.</tt><tt class="descname">filterfalse</tt><big>(</big><em>predicate</em>, <em>iterable</em><big>)</big><a class="headerlink" href="#itertools.filterfalse" title="Permalink to this definition">¶</a></dt>
<dd><p>Make an iterator that filters elements from iterable returning only those for
which the predicate is <tt class="xref docutils literal"><span class="pre">False</span></tt>. If <em>predicate</em> is <tt class="xref docutils literal"><span class="pre">None</span></tt>, return the items
that are false. Equivalent to:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">filterfalse</span><span class="p">(</span><span class="n">predicate</span><span class="p">,</span> <span class="n">iterable</span><span class="p">):</span>
    <span class="c"># filterfalse(lambda x: x%2, range(10)) --&gt; 0 2 4 6 8</span>
    <span class="k">if</span> <span class="n">predicate</span> <span class="ow">is</span> <span class="k">None</span><span class="p">:</span>
        <span class="n">predicate</span> <span class="o">=</span> <span class="nb">bool</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">predicate</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">x</span>
</pre></div>
</dd></dl>

<dl class="function">
<dt id="itertools.islice">
<!--[itertools.islice]--><tt class="descclassname">itertools.</tt><tt class="descname">islice</tt><big>(</big><em>iterable</em><span class="optional">[</span>, <em>start</em><span class="optional">]</span>, <em>stop</em><span class="optional">[</span>, <em>step</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#itertools.islice" title="Permalink to this definition">¶</a></dt>
<dd><p>Make an iterator that returns selected elements from the iterable. If <em>start</em> is
non-zero, then elements from the iterable are skipped until start is reached.
Afterward, elements are returned consecutively unless <em>step</em> is set higher than
one which results in items being skipped.  If <em>stop</em> is <tt class="xref docutils literal"><span class="pre">None</span></tt>, then iteration
continues until the iterator is exhausted, if at all; otherwise, it stops at the
specified position.  Unlike regular slicing, <a title="itertools.islice" class="reference internal" href="#itertools.islice"><tt class="xref docutils literal"><span class="pre">islice()</span></tt></a> does not support
negative values for <em>start</em>, <em>stop</em>, or <em>step</em>.  Can be used to extract related
fields from data where the internal structure has been flattened (for example, a
multi-line report may list a name field on every third line).  Equivalent to:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">islice</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="c"># islice(&#39;ABCDEFG&#39;, 2) --&gt; A B</span>
    <span class="c"># islice(&#39;ABCDEFG&#39;, 2, 4) --&gt; C D</span>
    <span class="c"># islice(&#39;ABCDEFG&#39;, 2, None) --&gt; C D E F G</span>
    <span class="c"># islice(&#39;ABCDEFG&#39;, 0, None, 2) --&gt; A C E G</span>
    <span class="n">s</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
    <span class="n">it</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">start</span> <span class="ow">or</span> <span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">stop</span> <span class="ow">or</span> <span class="n">sys</span><span class="o">.</span><span class="n">maxsize</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">step</span> <span class="ow">or</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">nexti</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">element</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">iterable</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">nexti</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">element</span>
            <span class="n">nexti</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
</pre></div>
<p>If <em>start</em> is <tt class="xref docutils literal"><span class="pre">None</span></tt>, then iteration starts at zero. If <em>step</em> is <tt class="xref docutils literal"><span class="pre">None</span></tt>,
then the step defaults to one.</p>
</dd></dl>

<dl class="function">
<dt id="itertools.zip_longest">
<!--[itertools.zip_longest]--><tt class="descclassname">itertools.</tt><tt class="descname">zip_longest</tt><big>(</big><em>*iterables</em><span class="optional">[</span>, <em>fillvalue</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#itertools.zip_longest" title="Permalink to this definition">¶</a></dt>
<dd><p>Make an iterator that aggregates elements from each of the iterables. If the
iterables are of uneven length, missing values are filled-in with <em>fillvalue</em>.
Iteration continues until the longest iterable is exhausted.  Equivalent to:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">zip_longest</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">fillvalue</span><span class="o">=</span><span class="k">None</span><span class="p">):</span>
    <span class="c"># zip_longest(&#39;ABCD&#39;, &#39;xy&#39;, fillvalue=&#39;-&#39;) --&gt; Ax By C- D-</span>
    <span class="k">def</span> <span class="nf">sentinel</span><span class="p">(</span><span class="n">counter</span> <span class="o">=</span> <span class="p">([</span><span class="n">fillvalue</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">pop</span><span class="p">):</span>
        <span class="k">yield</span> <span class="n">counter</span><span class="p">()</span>         <span class="c"># yields the fillvalue, or raises IndexError</span>
    <span class="n">fillers</span> <span class="o">=</span> <span class="n">repeat</span><span class="p">(</span><span class="n">fillvalue</span><span class="p">)</span>
    <span class="n">iters</span> <span class="o">=</span> <span class="p">[</span><span class="n">chain</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="n">sentinel</span><span class="p">(),</span> <span class="n">fillers</span><span class="p">)</span> <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">tup</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">iters</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">tup</span>
    <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
        <span class="k">pass</span>
</pre></div>
<p>If one of the iterables is potentially infinite, then the
<tt class="xref docutils literal"><span class="pre">izip_longest()</span></tt> function should be wrapped with something that limits
the number of calls (for example <a title="itertools.islice" class="reference internal" href="#itertools.islice"><tt class="xref docutils literal"><span class="pre">islice()</span></tt></a> or <a title="itertools.takewhile" class="reference internal" href="#itertools.takewhile"><tt class="xref docutils literal"><span class="pre">takewhile()</span></tt></a>).  If
not specified, <em>fillvalue</em> defaults to <tt class="xref docutils literal"><span class="pre">None</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="itertools.permutations">
<!--[itertools.permutations]--><tt class="descclassname">itertools.</tt><tt class="descname">permutations</tt><big>(</big><em>iterable</em><span class="optional">[</span>, <em>r</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#itertools.permutations" title="Permalink to this definition">¶</a></dt>
<dd><p>Return successive <em>r</em> length permutations of elements in the <em>iterable</em>.</p>
<p>If <em>r</em> is not specified or is <tt class="xref docutils literal"><span class="pre">None</span></tt>, then <em>r</em> defaults to the length
of the <em>iterable</em> and all possible full-length permutations
are generated.</p>
<p>Permutations are emitted in lexicographic sort order.  So, if the
input <em>iterable</em> is sorted, the permutation tuples will be produced
in sorted order.</p>
<p>Elements are treated as unique based on their position, not on their
value.  So if the input elements are unique, there will be no repeat
values in each permutation.</p>
<p>Equivalent to:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">permutations</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="k">None</span><span class="p">):</span>
    <span class="c"># permutations(&#39;ABCD&#39;, 2) --&gt; AB AC AD BA BC BD CA CB CD DA DB DC</span>
    <span class="c"># permutations(range(3)) --&gt; 012 021 102 120 201 210</span>
    <span class="n">pool</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pool</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">n</span> <span class="k">if</span> <span class="n">r</span> <span class="ow">is</span> <span class="k">None</span> <span class="k">else</span> <span class="n">r</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">cycles</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="n">r</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">yield</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">pool</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">[:</span><span class="n">r</span><span class="p">])</span>
    <span class="k">while</span> <span class="n">n</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">r</span><span class="p">)):</span>
            <span class="n">cycles</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">cycles</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">:]</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">cycles</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="n">i</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">cycles</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">indices</span><span class="p">[</span><span class="o">-</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="o">-</span><span class="n">j</span><span class="p">],</span> <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">yield</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">pool</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">[:</span><span class="n">r</span><span class="p">])</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span>
</pre></div>
<p>The code for <a title="itertools.permutations" class="reference internal" href="#itertools.permutations"><tt class="xref docutils literal"><span class="pre">permutations()</span></tt></a> can be also expressed as a subsequence of
<a title="itertools.product" class="reference internal" href="#itertools.product"><tt class="xref docutils literal"><span class="pre">product()</span></tt></a>, filtered to exclude entries with repeated elements (those
from the same position in the input pool):</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">permutations</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="k">None</span><span class="p">):</span>
    <span class="n">pool</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pool</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">n</span> <span class="k">if</span> <span class="n">r</span> <span class="ow">is</span> <span class="k">None</span> <span class="k">else</span> <span class="n">r</span>
    <span class="k">for</span> <span class="n">indices</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">repeat</span><span class="o">=</span><span class="n">r</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">indices</span><span class="p">))</span> <span class="o">==</span> <span class="n">r</span><span class="p">:</span>
            <span class="k">yield</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">pool</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">)</span>
</pre></div>
</dd></dl>

<dl class="function">
<dt id="itertools.product">
<!--[itertools.product]--><tt class="descclassname">itertools.</tt><tt class="descname">product</tt><big>(</big><em>*iterables</em><span class="optional">[</span>, <em>repeat</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#itertools.product" title="Permalink to this definition">¶</a></dt>
<dd><p>Cartesian product of input iterables.</p>
<p>Equivalent to nested for-loops in a generator expression. For example,
<tt class="docutils literal"><span class="pre">product(A,</span> <span class="pre">B)</span></tt> returns the same as <tt class="docutils literal"><span class="pre">((x,y)</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">A</span> <span class="pre">for</span> <span class="pre">y</span> <span class="pre">in</span> <span class="pre">B)</span></tt>.</p>
<p>The nested loops cycle like an odometer with the rightmost element advancing
on every iteration.  This pattern creates a lexicographic ordering so that if
the input&#8217;s iterables are sorted, the product tuples are emitted in sorted
order.</p>
<p>To compute the product of an iterable with itself, specify the number of
repetitions with the optional <em>repeat</em> keyword argument.  For example,
<tt class="docutils literal"><span class="pre">product(A,</span> <span class="pre">repeat=4)</span></tt> means the same as <tt class="docutils literal"><span class="pre">product(A,</span> <span class="pre">A,</span> <span class="pre">A,</span> <span class="pre">A)</span></tt>.</p>
<p>This function is equivalent to the following code, except that the
actual implementation does not build up intermediate results in memory:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">product</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">repeat</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="c"># product(&#39;ABCD&#39;, &#39;xy&#39;) --&gt; Ax Ay Bx By Cx Cy Dx Dy</span>
    <span class="c"># product(range(2), repeat=3) --&gt; 000 001 010 011 100 101 110 111</span>
    <span class="n">pools</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span> <span class="o">*</span> <span class="n">repeat</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[[]]</span>
    <span class="k">for</span> <span class="n">pool</span> <span class="ow">in</span> <span class="n">pools</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">+</span><span class="p">[</span><span class="n">y</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">result</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">pool</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">prod</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
        <span class="k">yield</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">prod</span><span class="p">)</span>
</pre></div>
</dd></dl>

<dl class="function">
<dt id="itertools.repeat">
<!--[itertools.repeat]--><tt class="descclassname">itertools.</tt><tt class="descname">repeat</tt><big>(</big><em>object</em><span class="optional">[</span>, <em>times</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#itertools.repeat" title="Permalink to this definition">¶</a></dt>
<dd><p>Make an iterator that returns <em>object</em> over and over again. Runs indefinitely
unless the <em>times</em> argument is specified. Used as argument to <a title="map" class="reference external" href="functions.html#map"><tt class="xref docutils literal"><span class="pre">map()</span></tt></a> for
invariant parameters to the called function.  Also used with <a title="zip" class="reference external" href="functions.html#zip"><tt class="xref docutils literal"><span class="pre">zip()</span></tt></a> to
create an invariant part of a tuple record.  Equivalent to:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">repeat</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">times</span><span class="o">=</span><span class="k">None</span><span class="p">):</span>
    <span class="c"># repeat(10, 3) --&gt; 10 10 10</span>
    <span class="k">if</span> <span class="n">times</span> <span class="ow">is</span> <span class="k">None</span><span class="p">:</span>
        <span class="k">while</span> <span class="k">True</span><span class="p">:</span>
            <span class="k">yield</span> <span class="nb">object</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">times</span><span class="p">):</span>
            <span class="k">yield</span> <span class="nb">object</span>
</pre></div>
</dd></dl>

<dl class="function">
<dt id="itertools.starmap">
<!--[itertools.starmap]--><tt class="descclassname">itertools.</tt><tt class="descname">starmap</tt><big>(</big><em>function</em>, <em>iterable</em><big>)</big><a class="headerlink" href="#itertools.starmap" title="Permalink to this definition">¶</a></dt>
<dd><p>Make an iterator that computes the function using arguments obtained from
the iterable.  Used instead of <a title="map" class="reference external" href="functions.html#map"><tt class="xref docutils literal"><span class="pre">map()</span></tt></a> when argument parameters are already
grouped in tuples from a single iterable (the data has been &#8220;pre-zipped&#8221;).  The
difference between <a title="map" class="reference external" href="functions.html#map"><tt class="xref docutils literal"><span class="pre">map()</span></tt></a> and <a title="itertools.starmap" class="reference internal" href="#itertools.starmap"><tt class="xref docutils literal"><span class="pre">starmap()</span></tt></a> parallels the distinction
between <tt class="docutils literal"><span class="pre">function(a,b)</span></tt> and <tt class="docutils literal"><span class="pre">function(*c)</span></tt>. Equivalent to:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">starmap</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">iterable</span><span class="p">):</span>
    <span class="c"># starmap(pow, [(2,5), (3,2), (10,3)]) --&gt; 32 9 1000</span>
    <span class="k">for</span> <span class="n">args</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">function</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>
</dd></dl>

<dl class="function">
<dt id="itertools.takewhile">
<!--[itertools.takewhile]--><tt class="descclassname">itertools.</tt><tt class="descname">takewhile</tt><big>(</big><em>predicate</em>, <em>iterable</em><big>)</big><a class="headerlink" href="#itertools.takewhile" title="Permalink to this definition">¶</a></dt>
<dd><p>Make an iterator that returns elements from the iterable as long as the
predicate is true.  Equivalent to:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">takewhile</span><span class="p">(</span><span class="n">predicate</span><span class="p">,</span> <span class="n">iterable</span><span class="p">):</span>
    <span class="c"># takewhile(lambda x: x&lt;5, [1,4,6,4,1]) --&gt; 1 4</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">predicate</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">x</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">break</span>
</pre></div>
</dd></dl>

<dl class="function">
<dt id="itertools.tee">
<!--[itertools.tee]--><tt class="descclassname">itertools.</tt><tt class="descname">tee</tt><big>(</big><em>iterable</em><span class="optional">[</span>, <em>n=2</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#itertools.tee" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <em>n</em> independent iterators from a single iterable. The case where <tt class="docutils literal"><span class="pre">n==2</span></tt>
is equivalent to:</p>
<pre>def tee(iterable):
    def gen(next, data={}):
        for i in count():
            if i in data:
                yield data.pop(i)
            else:
                data[i] = next()
                yield data[i]
    it = iter(iterable)
    return (gen(it.__next__), gen(it.__next__))</pre>
<p>Note, once <a title="itertools.tee" class="reference internal" href="#itertools.tee"><tt class="xref docutils literal"><span class="pre">tee()</span></tt></a> has made a split, the original <em>iterable</em> should not be
used anywhere else; otherwise, the <em>iterable</em> could get advanced without the tee
objects being informed.</p>
<p>Note, this member of the toolkit may require significant auxiliary storage
(depending on how much temporary data needs to be stored). In general, if one
iterator is going to use most or all of the data before the other iterator, it
is faster to use <a title="list" class="reference external" href="functions.html#list"><tt class="xref docutils literal"><span class="pre">list()</span></tt></a> instead of <a title="itertools.tee" class="reference internal" href="#itertools.tee"><tt class="xref docutils literal"><span class="pre">tee()</span></tt></a>.</p>
</dd></dl>

</div>
<div class="section" id="examples">
<span id="itertools-example"></span><h2>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h2>
<p>The following examples show common uses for each tool and demonstrate ways they
can be combined.</p>
<div class="highlight"><pre><span class="c"># Show a dictionary sorted and grouped by value</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">operator</span> <span class="k">import</span> <span class="n">itemgetter</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">e</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">f</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">g</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">di</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">groupby</span><span class="p">(</span><span class="n">di</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">1</span><span class="p">)):</span>
<span class="o">...</span>     <span class="nb">print</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="nb">map</span><span class="p">(</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">g</span><span class="p">))</span>
<span class="o">...</span>
<span class="mi">1</span> <span class="p">[</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;c&#39;</span><span class="p">,</span> <span class="s">&#39;e&#39;</span><span class="p">]</span>
<span class="mi">2</span> <span class="p">[</span><span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="s">&#39;d&#39;</span><span class="p">,</span> <span class="s">&#39;f&#39;</span><span class="p">]</span>
<span class="mi">3</span> <span class="p">[</span><span class="s">&#39;g&#39;</span><span class="p">]</span>

<span class="c"># Find runs of consecutive numbers using groupby.  The key to the solution</span>
<span class="c"># is differencing with a range so that consecutive numbers all appear in</span>
<span class="c"># same group.</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">data</span> <span class="o">=</span> <span class="p">[</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">18</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span><span class="mi">26</span><span class="p">,</span><span class="mi">27</span><span class="p">,</span><span class="mi">28</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">groupby</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
<span class="o">...</span>     <span class="nb">print</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">g</span><span class="p">))</span>
<span class="o">...</span>
<span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
<span class="p">[</span><span class="mi">10</span><span class="p">]</span>
<span class="p">[</span><span class="mi">15</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">18</span><span class="p">]</span>
<span class="p">[</span><span class="mi">22</span><span class="p">]</span>
<span class="p">[</span><span class="mi">25</span><span class="p">,</span> <span class="mi">26</span><span class="p">,</span> <span class="mi">27</span><span class="p">,</span> <span class="mi">28</span><span class="p">]</span>
</pre></div>
</div>
<div class="section" id="recipes">
<span id="itertools-recipes"></span><h2>Recipes<a class="headerlink" href="#recipes" title="Permalink to this headline">¶</a></h2>
<p>This section shows recipes for creating an extended toolset using the existing
itertools as building blocks.</p>
<p>The extended tools offer the same high performance as the underlying toolset.
The superior memory performance is kept by processing elements one at a time
rather than bringing the whole iterable into memory all at once. Code volume is
kept small by linking the tools together in a functional style which helps
eliminate temporary variables.  High speed is retained by preferring
&#8220;vectorized&#8221; building blocks over the use of for-loops and <a class="reference external" href="../glossary.html#term-generator"><em class="xref">generator</em></a>s
which incur interpreter overhead.</p>
<pre>def take(n, iterable):
    "Return first n items of the iterable as a list"
    return list(islice(iterable, n))

def enumerate(iterable, start=0):
    return zip(count(start), iterable)

def tabulate(function, start=0):
    "Return function(0), function(1), ..."
    return map(function, count(start))

def nth(iterable, n):
    "Returns the nth item or empty list"
    return list(islice(iterable, n, n+1))

def quantify(iterable, pred=bool):
    "Count how many times the predicate is true"
    return sum(map(pred, iterable))

def padnone(iterable):
    """Returns the sequence elements and then returns None indefinitely.

    Useful for emulating the behavior of the built-in map() function.
    """
    return chain(iterable, repeat(None))

def ncycles(iterable, n):
    "Returns the sequence elements n times"
    return chain.from_iterable(repeat(iterable, n))

def dotproduct(vec1, vec2):
    return sum(map(operator.mul, vec1, vec2))

def flatten(listOfLists):
    return list(chain.from_iterable(listOfLists))

def repeatfunc(func, times=None, *args):
    """Repeat calls to func with specified arguments.

    Example:  repeatfunc(random.random)
    """
    if times is None:
        return starmap(func, repeat(args))
    return starmap(func, repeat(args, times))

def pairwise(iterable):
    "s -&gt; (s0,s1), (s1,s2), (s2, s3), ..."
    a, b = tee(iterable)
    for elem in b:
        break
    return zip(a, b)

def grouper(n, iterable, fillvalue=None):
    "grouper(3, 'ABCDEFG', 'x') --&gt; ABC DEF Gxx"
    args = [iter(iterable)] * n
    return zip_longest(fillvalue=fillvalue, *args)

def roundrobin(*iterables):
    "roundrobin('ABC', 'D', 'EF') --&gt; A D E B F C"
    # Recipe credited to George Sakkis
    pending = len(iterables)
    nexts = cycle(iter(it).__next__ for it in iterables)
    while pending:
        try:
            for next in nexts:
                yield next()
        except StopIteration:
            pending -= 1
            nexts = cycle(islice(nexts, pending))

def powerset(iterable):
    "powerset('ab') --&gt; set([]), set(['a']), set(['b']), set(['a', 'b'])"
    # Recipe credited to Eric Raymond
    pairs = [(2**i, x) for i, x in enumerate(iterable)]
    for n in xrange(2**len(pairs)):
        yield set(x for m, x in pairs if m&amp;n)

def compress(data, selectors):
    "compress('ABCDEF', [1,0,1,0,1,1]) --&gt; A C E F"
    return (d for d, s in izip(data, selectors) if s)

def combinations_with_replacement(iterable, r):
    "combinations_with_replacement('ABC', 3) --&gt; AA AB AC BB BC CC"
    pool = tuple(iterable)
    n = len(pool)
    indices = [0] * r
    yield tuple(pool[i] for i in indices)
    while True:
        for i in reversed(range(r)):
            if indices[i] != n - 1:
                break
        else:
            return
        indices[i:] = [indices[i] + 1] * (r - i)
        yield tuple(pool[i] for i in indices)</pre>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <h3><a href="../contents.html">Table Of Contents</a></h3>
            <ul>
<li><a class="reference external" href=""><tt class="docutils literal"><span class="pre">itertools</span></tt> &#8212; Functions creating iterators for efficient looping</a><ul>
<li><a class="reference external" href="#itertool-functions">Itertool functions</a></li>
<li><a class="reference external" href="#examples">Examples</a></li>
<li><a class="reference external" href="#recipes">Recipes</a></li>
</ul>
</li>
</ul>

            <h4>Previous topic</h4>
            <p class="topless"><a href="random.html" title="previous chapter"><tt class="docutils literal docutils literal"><span class="pre">random</span></tt> &#8212; Generate pseudo-random numbers</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="functools.html" title="next chapter"><tt class="docutils literal docutils literal"><span class="pre">functools</span></tt> &#8212; Higher order functions and operations on callable objects</a></p>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="../_sources/library/itertools.txt">Show Source</a></li>
            </ul>
          <h3>Quick search</h3>
            <form class="search" action="../search.html" method="get">
              <input type="text" name="q" size="18" /> <input type="submit" value="Go" />
              <input type="hidden" name="check_keywords" value="yes" />
              <input type="hidden" name="area" value="default" />
            </form>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../modindex.html" title="Global Module Index"
             accesskey="M">modules</a> |</li>
        <li class="right" >
          <a href="functools.html" title="functools &#8212; Higher order functions and operations on callable objects"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="random.html" title="random &#8212; Generate pseudo-random numbers"
             accesskey="P">previous</a> |</li>
<li><img src="../_static/py.png" alt="" style="vertical-align: middle; margin-top: -1px"/></li>

        <li><a href="../contents.html">Python v3.0c1 documentation</a> &raquo;</li>

          <li><a href="index.html" accesskey="U">The Python Standard Library</a> &raquo;</li>
          <li><a href="numeric.html" accesskey="U">Numeric and Mathematical Modules</a> &raquo;</li>
      </ul>
    </div>
    <div class="footer">
      &copy; <a href="../copyright.html">Copyright</a> 1990-2008, Python Software Foundation.
      Last updated on Oct 31, 2008.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 0.5.
    </div>
  </body>
</html>