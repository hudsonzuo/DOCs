<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Buffer Objects &mdash; Python v3.0c1 documentation</title>
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
          URL_ROOT:    '../',
          VERSION:     '3.0c1',
          COLLAPSE_MODINDEX: false,
          FILE_SUFFIX: '.html'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Python v3.0c1 documentation"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="Python v3.0c1 documentation" href="../index.html" />
    <link rel="up" title="Concrete Objects Layer" href="concrete.html" />
    <link rel="next" title="Tuple Objects" href="tuple.html" />
    <link rel="prev" title="Unicode Objects and Codecs" href="unicode.html" />
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../modindex.html" title="Global Module Index"
             accesskey="M">modules</a> |</li>
        <li class="right" >
          <a href="tuple.html" title="Tuple Objects"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="unicode.html" title="Unicode Objects and Codecs"
             accesskey="P">previous</a> |</li>
<li><img src="../_static/py.png" alt="" style="vertical-align: middle; margin-top: -1px"/></li>

        <li><a href="../contents.html">Python v3.0c1 documentation</a> &raquo;</li>

          <li><a href="index.html" accesskey="U">Python/C API Reference Manual</a> &raquo;</li>
          <li><a href="concrete.html" accesskey="U">Concrete Objects Layer</a> &raquo;</li>
      </ul>
    </div>
    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  
  <div class="section" id="buffer-objects">
<span id="bufferobjects"></span><h1>Buffer Objects<a class="headerlink" href="#buffer-objects" title="Permalink to this headline">¶</a></h1>
<p id="index-0">Python objects implemented in C can export a &#8220;buffer interface.&#8221;  These
functions can be used by an object to expose its data in a raw, byte-oriented
format. Clients of the object can use the buffer interface to access the object
data directly, without needing to copy it first.</p>
<p>Two examples of objects that support the buffer interface are bytes and
arrays. The bytes object exposes the character contents in the buffer
interface&#8217;s byte-oriented form. An array can also expose its contents, but it
should be noted that array elements may be multi-byte values.</p>
<p>An example user of the buffer interface is the file object&#8217;s <tt class="xref docutils literal"><span class="pre">write()</span></tt>
method. Any object that can export a series of bytes through the buffer
interface can be written to a file. There are a number of format codes to
<a title="PyArg_ParseTuple" class="reference external" href="arg.html#PyArg_ParseTuple"><tt class="xref docutils literal"><span class="pre">PyArg_ParseTuple</span></tt></a> that operate against an object&#8217;s buffer interface,
returning data from the target object.</p>
<p id="index-1">More information on the buffer interface is provided in the section
<a class="reference external" href="typeobj.html#buffer-structs"><em>Buffer Object Structures</em></a>, under the description for <a title="PyBufferProcs" class="reference external" href="typeobj.html#PyBufferProcs"><tt class="xref docutils literal"><span class="pre">PyBufferProcs</span></tt></a>.</p>
<p>Buffer objects are useful as a way to expose the data from another object&#8217;s
buffer interface to the Python programmer.  They can also be used as a zero-copy
slicing mechanism.  Using their ability to reference a block of memory, it is
possible to expose any data to the Python programmer quite easily.  The memory
could be a large, constant array in a C extension, it could be a raw block of
memory for manipulation before passing to an operating system library, or it
could be used to pass around structured data in its native, in-memory format.</p>
<dl class="ctype">
<dt id="Py_buffer">
<!--[Py_buffer]--><tt class="descname">Py_buffer</tt><a class="headerlink" href="#Py_buffer" title="Permalink to this definition">¶</a></dt>
<dd><dl class="cmember">
<dt id="buf">
<!--[buf]-->void *<tt class="descname">buf</tt><a class="headerlink" href="#buf" title="Permalink to this definition">¶</a></dt>
<dd>A pointer to the start of the memory for the object.</dd></dl>

<dl class="cmember">
<dt>
Py_ssize_t <tt class="descname">len</tt></dt>
<dd>The total length of the memory in bytes.</dd></dl>

<dl class="cmember">
<dt id="readonly">
<!--[readonly]-->int <tt class="descname">readonly</tt><a class="headerlink" href="#readonly" title="Permalink to this definition">¶</a></dt>
<dd>An indicator of whether the buffer is read only.</dd></dl>

<dl class="cmember">
<dt>
const char *<tt class="descname">format</tt></dt>
<dd>A <em>NULL</em> terminated string in <a title="Interpret bytes as packed binary data." class="reference external" href="../library/struct.html"><tt class="xref docutils literal"><span class="pre">struct</span></tt></a> module style syntax giving the
contents of the elements available through the buffer.  If this is <em>NULL</em>,
<tt class="docutils literal"><span class="pre">&quot;B&quot;</span></tt> (unsigned bytes) is assumed.</dd></dl>

<dl class="cmember">
<dt id="ndim">
<!--[ndim]-->int <tt class="descname">ndim</tt><a class="headerlink" href="#ndim" title="Permalink to this definition">¶</a></dt>
<dd>The number of dimensions the memory represents as a multi-dimensional
array.  If it is 0, <a title="strides" class="reference internal" href="#strides"><tt class="xref docutils literal"><span class="pre">strides</span></tt></a> and <a title="suboffsets" class="reference internal" href="#suboffsets"><tt class="xref docutils literal"><span class="pre">suboffsets</span></tt></a> must be
<em>NULL</em>.</dd></dl>

<dl class="cmember">
<dt id="shape">
<!--[shape]-->Py_ssize_t *<tt class="descname">shape</tt><a class="headerlink" href="#shape" title="Permalink to this definition">¶</a></dt>
<dd>An array of <tt class="xref docutils literal"><span class="pre">Py_ssize_t</span></tt>s the length of <a title="ndim" class="reference internal" href="#ndim"><tt class="xref docutils literal"><span class="pre">ndim</span></tt></a> giving the
shape of the memory as a multi-dimensional array.  Note that
<tt class="docutils literal"><span class="pre">((*shape)[0]</span> <span class="pre">*</span> <span class="pre">...</span> <span class="pre">*</span> <span class="pre">(*shape)[ndims-1])*itemsize</span></tt> should be equal to
<tt class="xref docutils literal"><span class="pre">len</span></tt>.</dd></dl>

<dl class="cmember">
<dt id="strides">
<!--[strides]-->Py_ssize_t *<tt class="descname">strides</tt><a class="headerlink" href="#strides" title="Permalink to this definition">¶</a></dt>
<dd>An array of <tt class="xref docutils literal"><span class="pre">Py_ssize_t</span></tt>s the length of <a title="ndim" class="reference internal" href="#ndim"><tt class="xref docutils literal"><span class="pre">ndim</span></tt></a> giving the
number of bytes to skip to get to a new element in each dimension.</dd></dl>

<dl class="cmember">
<dt id="suboffsets">
<!--[suboffsets]-->Py_ssize_t *<tt class="descname">suboffsets</tt><a class="headerlink" href="#suboffsets" title="Permalink to this definition">¶</a></dt>
<dd><p>An array of <tt class="xref docutils literal"><span class="pre">Py_ssize_t</span></tt>s the length of <a title="ndim" class="reference internal" href="#ndim"><tt class="xref docutils literal"><span class="pre">ndim</span></tt></a>.  If these
suboffset numbers are greater than or equal to 0, then the value stored
along the indicated dimension is a pointer and the suboffset value
dictates how many bytes to add to the pointer after de-referencing. A
suboffset value that it negative indicates that no de-referencing should
occur (striding in a contiguous memory block).</p>
<p>Here is a function that returns a pointer to the element in an N-D array
pointed to by an N-dimesional index when there are both non-NULL strides
and suboffsets:</p>
<div class="highlight"><pre><span class="kt">void</span> <span class="o">*</span><span class="nf">get_item_pointer</span><span class="p">(</span><span class="kt">int</span> <span class="n">ndim</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">Py_ssize_t</span> <span class="o">*</span><span class="n">strides</span><span class="p">,</span>
    <span class="n">Py_ssize_t</span> <span class="o">*</span><span class="n">suboffsets</span><span class="p">,</span> <span class="n">Py_ssize_t</span> <span class="o">*</span><span class="n">indices</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">pointer</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ndim</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">pointer</span> <span class="o">+=</span> <span class="n">strides</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">suboffsets</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span><span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">pointer</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="kt">char</span><span class="o">**</span><span class="p">)</span><span class="n">pointer</span><span class="p">)</span> <span class="o">+</span> <span class="n">suboffsets</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">pointer</span><span class="p">;</span>
 <span class="p">}</span>
</pre></div>
</dd></dl>

<dl class="cmember">
<dt id="itemsize">
<!--[itemsize]-->Py_ssize_t <tt class="descname">itemsize</tt><a class="headerlink" href="#itemsize" title="Permalink to this definition">¶</a></dt>
<dd>This is a storage for the itemsize (in bytes) of each element of the
shared memory. It is technically un-necessary as it can be obtained using
<a title="PyBuffer_SizeFromFormat" class="reference internal" href="#PyBuffer_SizeFromFormat"><tt class="xref docutils literal"><span class="pre">PyBuffer_SizeFromFormat</span></tt></a>, however an exporter may know this
information without parsing the format string and it is necessary to know
the itemsize for proper interpretation of striding. Therefore, storing it
is more convenient and faster.</dd></dl>

<dl class="cmember">
<dt id="internal">
<!--[internal]-->void *<tt class="descname">internal</tt><a class="headerlink" href="#internal" title="Permalink to this definition">¶</a></dt>
<dd>This is for use internally by the exporting object. For example, this
might be re-cast as an integer by the exporter and used to store flags
about whether or not the shape, strides, and suboffsets arrays must be
freed when the buffer is released. The consumer should never alter this
value.</dd></dl>

</dd></dl>

<div class="section" id="buffer-related-functions">
<h2>Buffer related functions<a class="headerlink" href="#buffer-related-functions" title="Permalink to this headline">¶</a></h2>
<dl class="cfunction">
<dt id="PyObject_CheckBuffer">
<!--[PyObject_CheckBuffer]-->int <tt class="descname">PyObject_CheckBuffer</tt><big>(</big><a title="PyObject" class="reference external" href="structures.html#PyObject">PyObject</a><em> *obj</em><big>)</big><a class="headerlink" href="#PyObject_CheckBuffer" title="Permalink to this definition">¶</a></dt>
<dd>Return 1 if <em>obj</em> supports the buffer interface otherwise 0.</dd></dl>

<dl class="cfunction">
<dt id="PyObject_GetBuffer">
<!--[PyObject_GetBuffer]-->int <tt class="descname">PyObject_GetBuffer</tt><big>(</big><a title="PyObject" class="reference external" href="structures.html#PyObject">PyObject</a><em> *obj</em>, <a title="PyObject" class="reference external" href="structures.html#PyObject">PyObject</a><em> *view</em>, int<em> flags</em><big>)</big><a class="headerlink" href="#PyObject_GetBuffer" title="Permalink to this definition">¶</a></dt>
<dd><p>Export <em>obj</em> into a <a title="Py_buffer" class="reference internal" href="#Py_buffer"><tt class="xref docutils literal"><span class="pre">Py_buffer</span></tt></a>, <em>view</em>.  These arguments must
never be <em>NULL</em>.  The <em>flags</em> argument is a bit field indicating what kind
of buffer the caller is prepared to deal with and therefore what kind of
buffer the exporter is allowed to return.  The buffer interface allows for
complicated memory sharing possibilities, but some caller may not be able
to handle all the complexibity but may want to see if the exporter will
let them take a simpler view to its memory.</p>
<p>Some exporters may not be able to share memory in every possible way and
may need to raise errors to signal to some consumers that something is
just not possible. These errors should be a <tt class="xref docutils literal"><span class="pre">BufferError</span></tt> unless
there is another error that is actually causing the problem. The exporter
can use flags information to simplify how much of the <a title="Py_buffer" class="reference internal" href="#Py_buffer"><tt class="xref docutils literal"><span class="pre">Py_buffer</span></tt></a>
structure is filled in with non-default values and/or raise an error if
the object can&#8217;t support a simpler view of its memory.</p>
<p>0 is returned on success and -1 on error.</p>
<p>The following table gives possible values to the <em>flags</em> arguments.</p>
<table border="1" class="docutils">
<colgroup>
<col width="39%" />
<col width="61%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Flag</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="xref docutils literal"><span class="pre">PyBUF_SIMPLE</span></tt></td>
<td>This is the default flag state.  The returned
buffer may or may not have writable memory.
The format will be assumed to be unsigned bytes
.  This is a &#8220;stand-alone&#8221; flag constant. It
never needs to be <a href="#id1"><span class="problematic" id="id2">|</span></a>&#8216;d to the others. The
exporter will raise an error if it cannot
provide such a contiguous buffer of bytes.</td>
</tr>
<tr><td><tt class="xref docutils literal"><span class="pre">PyBUF_WRITABLE</span></tt></td>
<td>The returned buffer must be writable. If it is
not writable, then raise an error.</td>
</tr>
<tr><td><tt class="xref docutils literal"><span class="pre">PyBUF_STRIDES</span></tt></td>
<td>This implies <tt class="xref docutils literal"><span class="pre">PyBUF_ND</span></tt>. The returned
buffer must provide strides information
(i.e. the strides cannot be NULL). This would
be used when the consumer can handle strided,
discontiguous arrays. Handling strides
automatically assumes you can handle shape. The
exporter may raise an error if cannot provide a
strided-only representation of the data
(i.e. without the suboffsets).</td>
</tr>
<tr><td><tt class="xref docutils literal"><span class="pre">PyBUF_ND</span></tt></td>
<td>The returned buffer must provide shape
information. The memory will be assumed C-style
contiguous (last dimension varies the
fastest). The exporter may raise an error if it
cannot provide this kind of contiguous
buffer. If this is not given then shape will be
<em>NULL</em>.</td>
</tr>
<tr><td><tt class="xref docutils literal"><span class="pre">PyBUF_C_CONTIGUOUS</span></tt>
<tt class="xref docutils literal"><span class="pre">PyBUF_F_CONTIGUOUS</span></tt>
<tt class="xref docutils literal"><span class="pre">PyBUF_ANY_CONTIGUOUS</span></tt></td>
<td>These flags indicate that the contiguoity
returned buffer must be respectively,
C-contiguous (last dimension varies the
fastest), Fortran contiguous (first dimension
varies the fastest) or either one.  All of
these flags imply <tt class="xref docutils literal"><span class="pre">PyBUF_STRIDES</span></tt> and
guarantee that the strides buffer info
structure will be filled in correctly.</td>
</tr>
<tr><td><tt class="xref docutils literal"><span class="pre">PyBUF_INDIRECT</span></tt></td>
<td>This implies <tt class="xref docutils literal"><span class="pre">PyBUF_STRIDES</span></tt>. The
returned buffer must have suboffsets
information (which can be NULL if no suboffsets
are needed). This would be used when the
consumer can handle indirect array referencing
implied by these suboffsets.</td>
</tr>
<tr><td><tt class="xref docutils literal"><span class="pre">PyBUF_FORMAT</span></tt></td>
<td>The returned buffer must have true format
information if this flag is provided. This
would be used when the consumer is going to be
checking for what &#8216;kind&#8217; of data is actually
stored. An exporter should always be able to
provide this information if requested. If
format is not explicitly requested then the
format must be returned as <em>NULL</em> (which means
<tt class="docutils literal"><span class="pre">'B'</span></tt>, or unsigned bytes)</td>
</tr>
<tr><td><tt class="xref docutils literal"><span class="pre">PyBUF_STRIDED</span></tt></td>
<td>This is equivalent to <tt class="docutils literal"><span class="pre">(PyBUF_STRIDES</span> <span class="pre">|</span>
<span class="pre">PyBUF_WRITABLE)</span></tt>.</td>
</tr>
<tr><td><tt class="xref docutils literal"><span class="pre">PyBUF_STRIDED_RO</span></tt></td>
<td>This is equivalent to <tt class="docutils literal"><span class="pre">(PyBUF_STRIDES)</span></tt>.</td>
</tr>
<tr><td><tt class="xref docutils literal"><span class="pre">PyBUF_RECORDS</span></tt></td>
<td>This is equivalent to <tt class="docutils literal"><span class="pre">(PyBUF_STRIDES</span> <span class="pre">|</span>
<span class="pre">PyBUF_FORMAT</span> <span class="pre">|</span> <span class="pre">PyBUF_WRITABLE)</span></tt>.</td>
</tr>
<tr><td><tt class="xref docutils literal"><span class="pre">PyBUF_RECORDS_RO</span></tt></td>
<td>This is equivalent to <tt class="docutils literal"><span class="pre">(PyBUF_STRIDES</span> <span class="pre">|</span>
<span class="pre">PyBUF_FORMAT)</span></tt>.</td>
</tr>
<tr><td><tt class="xref docutils literal"><span class="pre">PyBUF_FULL</span></tt></td>
<td>This is equivalent to <tt class="docutils literal"><span class="pre">(PyBUF_INDIRECT</span> <span class="pre">|</span>
<span class="pre">PyBUF_FORMAT</span> <span class="pre">|</span> <span class="pre">PyBUF_WRITABLE)</span></tt>.</td>
</tr>
<tr><td><tt class="xref docutils literal"><span class="pre">PyBUF_FULL_RO`</span></tt></td>
<td>This is equivalent to <tt class="docutils literal"><span class="pre">(PyBUF_INDIRECT</span> <span class="pre">|</span>
<span class="pre">PyBUF_FORMAT)</span></tt>.</td>
</tr>
<tr><td><tt class="xref docutils literal"><span class="pre">PyBUF_CONTIG</span></tt></td>
<td>This is equivalent to <tt class="docutils literal"><span class="pre">(PyBUF_ND</span> <span class="pre">|</span>
<span class="pre">PyBUF_WRITABLE)</span></tt>.</td>
</tr>
<tr><td><tt class="xref docutils literal"><span class="pre">PyBUF_CONTIG_RO</span></tt></td>
<td>This is equivalent to <tt class="docutils literal"><span class="pre">(PyBUF_ND)</span></tt>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="cfunction">
<dt id="PyBuffer_Release">
<!--[PyBuffer_Release]-->void <tt class="descname">PyBuffer_Release</tt><big>(</big><a title="PyObject" class="reference external" href="structures.html#PyObject">PyObject</a><em> *obj</em>, <a title="Py_buffer" class="reference internal" href="#Py_buffer">Py_buffer</a><em> *view</em><big>)</big><a class="headerlink" href="#PyBuffer_Release" title="Permalink to this definition">¶</a></dt>
<dd>Release the buffer <em>view</em> over <em>obj</em>.  This shouldd be called when the buffer
is no longer being used as it may free memory from it.</dd></dl>

<dl class="cfunction">
<dt id="PyBuffer_SizeFromFormat">
<!--[PyBuffer_SizeFromFormat]-->Py_ssize_t <tt class="descname">PyBuffer_SizeFromFormat</tt><big>(</big>const char<em> *</em><big>)</big><a class="headerlink" href="#PyBuffer_SizeFromFormat" title="Permalink to this definition">¶</a></dt>
<dd>Return the implied <tt class="xref docutils literal"><span class="pre">~Py_buffer.itemsize</span></tt> from the struct-stype
<tt class="xref docutils literal"><span class="pre">~Py_buffer.format</span></tt>.</dd></dl>

<dl class="cfunction">
<dt id="PyObject_CopyToObject">
<!--[PyObject_CopyToObject]-->int <tt class="descname">PyObject_CopyToObject</tt><big>(</big><a title="PyObject" class="reference external" href="structures.html#PyObject">PyObject</a><em> *obj</em>, void<em> *buf</em>, Py_ssize_t<em> len</em>, char<em> fortran</em><big>)</big><a class="headerlink" href="#PyObject_CopyToObject" title="Permalink to this definition">¶</a></dt>
<dd>Copy <em>len</em> bytes of data pointed to by the contiguous chunk of memory pointed
to by <em>buf</em> into the buffer exported by obj.  The buffer must of course be
writable.  Return 0 on success and return -1 and raise an error on failure.
If the object does not have a writable buffer, then an error is raised.  If
<em>fortran</em> is <tt class="docutils literal"><span class="pre">'F'</span></tt>, then if the object is multi-dimensional, then the data
will be copied into the array in Fortran-style (first dimension varies the
fastest).  If <em>fortran</em> is <tt class="docutils literal"><span class="pre">'C'</span></tt>, then the data will be copied into the
array in C-style (last dimension varies the fastest).  If <em>fortran</em> is
<tt class="docutils literal"><span class="pre">'A'</span></tt>, then it does not matter and the copy will be made in whatever way is
more efficient.</dd></dl>

<dl class="cfunction">
<dt id="PyBuffer_IsContiguous">
<!--[PyBuffer_IsContiguous]-->int <tt class="descname">PyBuffer_IsContiguous</tt><big>(</big><a title="Py_buffer" class="reference internal" href="#Py_buffer">Py_buffer</a><em> *view</em>, char<em> fortran</em><big>)</big><a class="headerlink" href="#PyBuffer_IsContiguous" title="Permalink to this definition">¶</a></dt>
<dd>Return 1 if the memory defined by the <em>view</em> is C-style (<em>fortran</em> is
<tt class="docutils literal"><span class="pre">'C'</span></tt>) or Fortran-style (<em>fortran</em> is <tt class="docutils literal"><span class="pre">'F'</span></tt>) contiguous or either one
(<em>fortran</em> is <tt class="docutils literal"><span class="pre">'A'</span></tt>).  Return 0 otherwise.</dd></dl>

<dl class="cfunction">
<dt id="PyBuffer_FillContiguousStrides">
<!--[PyBuffer_FillContiguousStrides]-->void <tt class="descname">PyBuffer_FillContiguousStrides</tt><big>(</big>int<em> ndim</em>, Py_ssize_t<em> *shape</em>, Py_ssize_t<em> *strides</em>, Py_ssize_t<em> itemsize</em>, char<em> fortran</em><big>)</big><a class="headerlink" href="#PyBuffer_FillContiguousStrides" title="Permalink to this definition">¶</a></dt>
<dd>Fill the <em>strides</em> array with byte-strides of a contiguous (C-style if
<em>fortran</em> is <tt class="docutils literal"><span class="pre">'C'</span></tt> or Fortran-style if <em>fortran</em> is <tt class="docutils literal"><span class="pre">'F'</span></tt> array of the
given shape with the given number of bytes per element.</dd></dl>

<dl class="cfunction">
<dt id="PyBuffer_FillInfo">
<!--[PyBuffer_FillInfo]-->int <tt class="descname">PyBuffer_FillInfo</tt><big>(</big><a title="Py_buffer" class="reference internal" href="#Py_buffer">Py_buffer</a><em> *view</em>, void<em> *buf</em>, Py_ssize_t<em> len</em>, int<em> readonly</em>, int<em> infoflags</em><big>)</big><a class="headerlink" href="#PyBuffer_FillInfo" title="Permalink to this definition">¶</a></dt>
<dd>Fill in a buffer-info structure, <em>view</em>, correctly for an exporter that can
only share a contiguous chunk of memory of &#8220;unsigned bytes&#8221; of the given
length.  Return 0 on success and -1 (with raising an error) on error.</dd></dl>

</div>
<div class="section" id="memoryview-objects">
<h2>MemoryView objects<a class="headerlink" href="#memoryview-objects" title="Permalink to this headline">¶</a></h2>
<p>A memoryview object is an extended buffer object that could replace the buffer
object (but doesn&#8217;t have to as that could be kept as a simple 1-d memoryview
object).  It, unlike <a title="Py_buffer" class="reference internal" href="#Py_buffer"><tt class="xref docutils literal"><span class="pre">Py_buffer</span></tt></a>, is a Python object (exposed as
<a title="memoryview" class="reference external" href="../library/stdtypes.html#memoryview"><tt class="xref docutils literal"><span class="pre">memoryview</span></tt></a> in <a title="The module that provides the built-in namespace." class="reference external" href="../library/builtins.html"><tt class="xref docutils literal"><span class="pre">builtins</span></tt></a>), so it can be used with Python code.</p>
<dl class="cfunction">
<dt id="PyMemoryView_FromObject">
<!--[PyMemoryView_FromObject]--><a title="PyObject" class="reference external" href="structures.html#PyObject">PyObject</a>* <tt class="descname">PyMemoryView_FromObject</tt><big>(</big><a title="PyObject" class="reference external" href="structures.html#PyObject">PyObject</a><em> *obj</em><big>)</big><a class="headerlink" href="#PyMemoryView_FromObject" title="Permalink to this definition">¶</a></dt>
<dd>Return a memoryview object from an object that defines the buffer interface.</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <h3><a href="../contents.html">Table Of Contents</a></h3>
            <ul>
<li><a class="reference external" href="">Buffer Objects</a><ul>
<li><a class="reference external" href="#buffer-related-functions">Buffer related functions</a></li>
<li><a class="reference external" href="#memoryview-objects">MemoryView objects</a></li>
</ul>
</li>
</ul>

            <h4>Previous topic</h4>
            <p class="topless"><a href="unicode.html" title="previous chapter">Unicode Objects and Codecs</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="tuple.html" title="next chapter">Tuple Objects</a></p>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="../_sources/c-api/buffer.txt">Show Source</a></li>
            </ul>
          <h3>Quick search</h3>
            <form class="search" action="../search.html" method="get">
              <input type="text" name="q" size="18" /> <input type="submit" value="Go" />
              <input type="hidden" name="check_keywords" value="yes" />
              <input type="hidden" name="area" value="default" />
            </form>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../modindex.html" title="Global Module Index"
             accesskey="M">modules</a> |</li>
        <li class="right" >
          <a href="tuple.html" title="Tuple Objects"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="unicode.html" title="Unicode Objects and Codecs"
             accesskey="P">previous</a> |</li>
<li><img src="../_static/py.png" alt="" style="vertical-align: middle; margin-top: -1px"/></li>

        <li><a href="../contents.html">Python v3.0c1 documentation</a> &raquo;</li>

          <li><a href="index.html" accesskey="U">Python/C API Reference Manual</a> &raquo;</li>
          <li><a href="concrete.html" accesskey="U">Concrete Objects Layer</a> &raquo;</li>
      </ul>
    </div>
    <div class="footer">
      &copy; <a href="../copyright.html">Copyright</a> 1990-2008, Python Software Foundation.
      Last updated on Oct 31, 2008.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 0.5.
    </div>
  </body>
</html>