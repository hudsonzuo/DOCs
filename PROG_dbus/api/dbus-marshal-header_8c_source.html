<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>D-Bus: dbus-marshal-header.c Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">D-Bus
   &#160;<span id="projectnumber">1.6.8</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">dbus-marshal-header.c</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* -*- mode: C; c-file-style: &quot;gnu&quot;; indent-tabs-mode: nil; -*- */</span>
<a name="l00002"></a>00002 <span class="comment">/* dbus-marshal-header.c  Managing marshaling/demarshaling of message headers</span>
<a name="l00003"></a>00003 <span class="comment"> *</span>
<a name="l00004"></a>00004 <span class="comment"> * Copyright (C) 2005  Red Hat, Inc.</span>
<a name="l00005"></a>00005 <span class="comment"> *</span>
<a name="l00006"></a>00006 <span class="comment"> * Licensed under the Academic Free License version 2.1</span>
<a name="l00007"></a>00007 <span class="comment"> *</span>
<a name="l00008"></a>00008 <span class="comment"> * This program is free software; you can redistribute it and/or modify</span>
<a name="l00009"></a>00009 <span class="comment"> * it under the terms of the GNU General Public License as published by</span>
<a name="l00010"></a>00010 <span class="comment"> * the Free Software Foundation; either version 2 of the License, or</span>
<a name="l00011"></a>00011 <span class="comment"> * (at your option) any later version.</span>
<a name="l00012"></a>00012 <span class="comment"> *</span>
<a name="l00013"></a>00013 <span class="comment"> * This program is distributed in the hope that it will be useful,</span>
<a name="l00014"></a>00014 <span class="comment"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00015"></a>00015 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00016"></a>00016 <span class="comment"> * GNU General Public License for more details.</span>
<a name="l00017"></a>00017 <span class="comment"> *</span>
<a name="l00018"></a>00018 <span class="comment"> * You should have received a copy of the GNU General Public License</span>
<a name="l00019"></a>00019 <span class="comment"> * along with this program; if not, write to the Free Software</span>
<a name="l00020"></a>00020 <span class="comment"> * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA</span>
<a name="l00021"></a>00021 <span class="comment"> *</span>
<a name="l00022"></a>00022 <span class="comment"> */</span>
<a name="l00023"></a>00023 
<a name="l00024"></a>00024 <span class="preprocessor">#include &lt;config.h&gt;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &quot;dbus/dbus-shared.h&quot;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &quot;dbus-marshal-header.h&quot;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &quot;dbus-marshal-recursive.h&quot;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &quot;dbus-marshal-byteswap.h&quot;</span>
<a name="l00029"></a>00029 
<a name="l00037"></a>00037 <span class="comment">/* Not thread locked, but strictly const/read-only so should be OK</span>
<a name="l00038"></a>00038 <span class="comment"> */</span>
<a name="l00040"></a>00040 <a class="code" href="group__DBusMarshal.html#gab49ca4819ef45b26463427bb09060844" title="Static DBusString containing the signature of a message header.">_DBUS_STRING_DEFINE_STATIC</a>(_dbus_header_signature_str, <a class="code" href="group__DBusProtocol.html#ga82e39a6508e551fb14c7bdbb17590cc6" title="Header format is defined as a signature: byte byte order byte message type ID byte flags byte protoco...">DBUS_HEADER_SIGNATURE</a>);
<a name="l00042"></a>00042 <a class="code" href="group__DBusMarshal.html#gab49ca4819ef45b26463427bb09060844" title="Static DBusString containing the signature of a message header.">_DBUS_STRING_DEFINE_STATIC</a>(_dbus_local_interface_str,  <a class="code" href="group__DBusShared.html#ga9ef6478aae637449ec0c5de1679f75ce" title="This is a special interface whose methods can only be invoked by the local implementation (messages f...">DBUS_INTERFACE_LOCAL</a>);
<a name="l00044"></a>00044 <a class="code" href="group__DBusMarshal.html#gab49ca4819ef45b26463427bb09060844" title="Static DBusString containing the signature of a message header.">_DBUS_STRING_DEFINE_STATIC</a>(_dbus_local_path_str,       <a class="code" href="group__DBusShared.html#ga850990a54a46142ee7c5f8174cc932c1" title="The object path used in local/in-process-generated messages.">DBUS_PATH_LOCAL</a>);
<a name="l00045"></a>00045 
<a name="l00047"></a><a class="code" href="group__DBusMarshal.html#ga935ea6d7c6bb72a10c670f5ef3e34d49">00047</a> <span class="preprocessor">#define FIELDS_ARRAY_SIGNATURE_OFFSET 6</span>
<a name="l00048"></a>00048 <span class="preprocessor"></span>
<a name="l00049"></a><a class="code" href="group__DBusMarshal.html#gaca36ac2e9b37067279d1bc967793e071">00049</a> <span class="preprocessor">#define FIELDS_ARRAY_ELEMENT_SIGNATURE_OFFSET 7</span>
<a name="l00050"></a>00050 <span class="preprocessor"></span>
<a name="l00051"></a>00051 
<a name="l00053"></a><a class="code" href="group__DBusMarshal.html#gaa5b7e77f37761139698892e4b8aad029">00053</a> <span class="preprocessor">#define BYTE_ORDER_OFFSET    0</span>
<a name="l00054"></a>00054 <span class="preprocessor"></span>
<a name="l00055"></a><a class="code" href="group__DBusMarshal.html#gaf4fe78df75f4afa2ec63304462614b03">00055</a> <span class="preprocessor">#define TYPE_OFFSET          1</span>
<a name="l00056"></a>00056 <span class="preprocessor"></span>
<a name="l00057"></a><a class="code" href="group__DBusMarshal.html#ga7fe1bac4010cdc7e27de1e19702c071e">00057</a> <span class="preprocessor">#define FLAGS_OFFSET         2</span>
<a name="l00058"></a>00058 <span class="preprocessor"></span>
<a name="l00059"></a><a class="code" href="group__DBusMarshal.html#ga4f04ecce1223b00d263c0accdea144ad">00059</a> <span class="preprocessor">#define VERSION_OFFSET       3</span>
<a name="l00060"></a>00060 <span class="preprocessor"></span>
<a name="l00061"></a><a class="code" href="group__DBusMarshal.html#ga190a2d89e79c9d76fcba4f06ec8b5b5c">00061</a> <span class="preprocessor">#define BODY_LENGTH_OFFSET 4</span>
<a name="l00062"></a>00062 <span class="preprocessor"></span>
<a name="l00063"></a><a class="code" href="group__DBusMarshal.html#ga4a9c0639714b478a4905cdd6e999b6b3">00063</a> <span class="preprocessor">#define SERIAL_OFFSET 8</span>
<a name="l00064"></a>00064 <span class="preprocessor"></span>
<a name="l00065"></a><a class="code" href="group__DBusMarshal.html#gae9759e0de1d8a650f37632c3dc22427e">00065</a> <span class="preprocessor">#define FIELDS_ARRAY_LENGTH_OFFSET 12</span>
<a name="l00066"></a>00066 <span class="preprocessor"></span>
<a name="l00067"></a><a class="code" href="group__DBusMarshal.html#gaaa085e57f49f527ef210e842be999929">00067</a> <span class="preprocessor">#define FIRST_FIELD_OFFSET 16</span>
<a name="l00068"></a>00068 <span class="preprocessor"></span>
<a name="l00069"></a><a class="code" href="structHeaderFieldType.html">00069</a> <span class="keyword">typedef</span> <span class="keyword">struct</span>
<a name="l00070"></a>00070 {
<a name="l00071"></a><a class="code" href="structHeaderFieldType.html#aa9431b99ba54853099db8d7a7882b437">00071</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> <a class="code" href="structHeaderFieldType.html#aa9431b99ba54853099db8d7a7882b437" title="the field code">code</a>; 
<a name="l00072"></a><a class="code" href="structHeaderFieldType.html#a904875b9ce744f8103a55aae312521bb">00072</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> <a class="code" href="structHeaderFieldType.html#a904875b9ce744f8103a55aae312521bb" title="the value type">type</a>; 
<a name="l00073"></a>00073 } <a class="code" href="structHeaderFieldType.html">HeaderFieldType</a>;
<a name="l00074"></a>00074 
<a name="l00075"></a>00075 <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="structHeaderFieldType.html">HeaderFieldType</a>
<a name="l00076"></a>00076 _dbus_header_field_types[<a class="code" href="group__DBusProtocol.html#ga94f09d2b35473c8ffa6d3190b5f97c5c" title="Value of the highest-numbered header field code, can be used to determine the size of an array indexe...">DBUS_HEADER_FIELD_LAST</a>+1] = {
<a name="l00077"></a>00077   { <a class="code" href="group__DBusProtocol.html#ga075b0efc570129393d3fb653ce4bbd76" title="Not equal to any valid header field code.">DBUS_HEADER_FIELD_INVALID</a>, <a class="code" href="group__DBusProtocol.html#gaa9588da889743b2119dc6664712ae51e" title="Type code that is never equal to a legitimate type code.">DBUS_TYPE_INVALID</a> },
<a name="l00078"></a>00078   { <a class="code" href="group__DBusProtocol.html#ga0cd885e6e808b28ff082a7f8a2c9f579" title="Header field code for the path - the path is the object emitting a signal or the object receiving a m...">DBUS_HEADER_FIELD_PATH</a>, <a class="code" href="group__DBusProtocol.html#ga31cc59c99a6cbbfcef71756e1390dc4c" title="Type code marking a D-Bus object path.">DBUS_TYPE_OBJECT_PATH</a> },
<a name="l00079"></a>00079   { <a class="code" href="group__DBusProtocol.html#ga296b5f099b6c347f65d53ef0a6fa2b0d" title="Header field code for the interface containing a member (method or signal).">DBUS_HEADER_FIELD_INTERFACE</a>, <a class="code" href="group__DBusProtocol.html#ga7eb77066dadf5415896b44c56d93acce" title="Type code marking a UTF-8 encoded, nul-terminated Unicode string.">DBUS_TYPE_STRING</a> },
<a name="l00080"></a>00080   { <a class="code" href="group__DBusProtocol.html#ga2aa9d65ef983ac9c08c1d4cb31366818" title="Header field code for a member (method or signal).">DBUS_HEADER_FIELD_MEMBER</a>, <a class="code" href="group__DBusProtocol.html#ga7eb77066dadf5415896b44c56d93acce" title="Type code marking a UTF-8 encoded, nul-terminated Unicode string.">DBUS_TYPE_STRING</a> },
<a name="l00081"></a>00081   { <a class="code" href="group__DBusProtocol.html#gac551be0f921390d01104cce30a814a5e" title="Header field code for an error name (found in DBUS_MESSAGE_TYPE_ERROR messages).">DBUS_HEADER_FIELD_ERROR_NAME</a>, <a class="code" href="group__DBusProtocol.html#ga7eb77066dadf5415896b44c56d93acce" title="Type code marking a UTF-8 encoded, nul-terminated Unicode string.">DBUS_TYPE_STRING</a> },
<a name="l00082"></a>00082   { <a class="code" href="group__DBusProtocol.html#ga1067e28a7151a161e5fd601a3b017584" title="Header field code for a reply serial, used to match a DBUS_MESSAGE_TYPE_METHOD_RETURN message with th...">DBUS_HEADER_FIELD_REPLY_SERIAL</a>, <a class="code" href="group__DBusProtocol.html#gaedb1740bd8a9174b98ac593eded25d49" title="Type code marking a 32-bit unsigned integer.">DBUS_TYPE_UINT32</a> },
<a name="l00083"></a>00083   { <a class="code" href="group__DBusProtocol.html#gade98f71a08a1e0198d095fdb6d46cab9" title="Header field code for the destination bus name of a message.">DBUS_HEADER_FIELD_DESTINATION</a>, <a class="code" href="group__DBusProtocol.html#ga7eb77066dadf5415896b44c56d93acce" title="Type code marking a UTF-8 encoded, nul-terminated Unicode string.">DBUS_TYPE_STRING</a> },
<a name="l00084"></a>00084   { <a class="code" href="group__DBusProtocol.html#ga3ba84ae623951832bd73e2796bb13e71" title="Header field code for the sender of a message; usually initialized by the message bus...">DBUS_HEADER_FIELD_SENDER</a>, <a class="code" href="group__DBusProtocol.html#ga7eb77066dadf5415896b44c56d93acce" title="Type code marking a UTF-8 encoded, nul-terminated Unicode string.">DBUS_TYPE_STRING</a> },
<a name="l00085"></a>00085   { <a class="code" href="group__DBusProtocol.html#ga450d63fa110d3cb891082e23291580b4" title="Header field code for the type signature of a message.">DBUS_HEADER_FIELD_SIGNATURE</a>, <a class="code" href="group__DBusProtocol.html#ga26ed6c20c3d9f0b50ea0a1cf80be3279" title="Type code marking a D-Bus type signature.">DBUS_TYPE_SIGNATURE</a> },
<a name="l00086"></a>00086   { <a class="code" href="group__DBusProtocol.html#ga03b9c24acbfd1e3da19804c739612885" title="Header field code for the number of unix file descriptors associated with this message.">DBUS_HEADER_FIELD_UNIX_FDS</a>, <a class="code" href="group__DBusProtocol.html#gaedb1740bd8a9174b98ac593eded25d49" title="Type code marking a 32-bit unsigned integer.">DBUS_TYPE_UINT32</a> }
<a name="l00087"></a>00087 };
<a name="l00088"></a>00088 
<a name="l00090"></a><a class="code" href="group__DBusMarshal.html#ga37be3d294f5be31c95bc7620e451b0b2">00090</a> <span class="preprocessor">#define EXPECTED_TYPE_OF_FIELD(field) (_dbus_header_field_types[field].type)</span>
<a name="l00091"></a>00091 <span class="preprocessor"></span>
<a name="l00093"></a><a class="code" href="group__DBusMarshal.html#gaa10402f90ea6e004e3b9f04eea34f73c">00093</a> <span class="preprocessor">#define MAX_POSSIBLE_HEADER_PADDING 7</span>
<a name="l00094"></a>00094 <span class="preprocessor"></span><span class="keyword">static</span> <a class="code" href="group__DBusTypes.html#ga39c9cb0f3a2a8ad6f55cc4855d035349" title="A boolean, valid values are TRUE and FALSE.">dbus_bool_t</a>
<a name="l00095"></a>00095 reserve_header_padding (<a class="code" href="structDBusHeader.html" title="Message header data and some cached details of it.">DBusHeader</a> *header)
<a name="l00096"></a>00096 {
<a name="l00097"></a>00097   _dbus_assert (header-&gt;<a class="code" href="structDBusHeader.html#aa22a8d00f061310e12716f656b4d9b8f" title="bytes of alignment in header">padding</a> &lt;= <a class="code" href="group__DBusMarshal.html#gaa10402f90ea6e004e3b9f04eea34f73c" title="The most padding we could ever need for a header.">MAX_POSSIBLE_HEADER_PADDING</a>);
<a name="l00098"></a>00098 
<a name="l00099"></a>00099   <span class="keywordflow">if</span> (!<a class="code" href="group__DBusString.html#ga8f13997d90ceed2f437706e6b7804d9b" title="Makes a string longer by the given number of bytes.">_dbus_string_lengthen</a> (&amp;header-&gt;<a class="code" href="structDBusHeader.html#a67df8bff43c10e2d4f6ae36b56ee5814" title="Header network data, stored separately from body so we can independently realloc it.">data</a>,
<a name="l00100"></a>00100                               <a class="code" href="group__DBusMarshal.html#gaa10402f90ea6e004e3b9f04eea34f73c" title="The most padding we could ever need for a header.">MAX_POSSIBLE_HEADER_PADDING</a> - header-&gt;<a class="code" href="structDBusHeader.html#aa22a8d00f061310e12716f656b4d9b8f" title="bytes of alignment in header">padding</a>))
<a name="l00101"></a>00101     <span class="keywordflow">return</span> <a class="code" href="group__DBusMacros.html#gaa93f0eb578d23995850d61f7d61c55c1" title="Expands to &quot;0&quot;.">FALSE</a>;
<a name="l00102"></a>00102   header-&gt;<a class="code" href="structDBusHeader.html#aa22a8d00f061310e12716f656b4d9b8f" title="bytes of alignment in header">padding</a> = <a class="code" href="group__DBusMarshal.html#gaa10402f90ea6e004e3b9f04eea34f73c" title="The most padding we could ever need for a header.">MAX_POSSIBLE_HEADER_PADDING</a>;
<a name="l00103"></a>00103   <span class="keywordflow">return</span> <a class="code" href="group__DBusMacros.html#gaa8cecfc5c5c054d2875c03e77b7be15d" title="Expands to &quot;1&quot;.">TRUE</a>;
<a name="l00104"></a>00104 }
<a name="l00105"></a>00105 
<a name="l00106"></a>00106 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00107"></a>00107 correct_header_padding (<a class="code" href="structDBusHeader.html" title="Message header data and some cached details of it.">DBusHeader</a> *header)
<a name="l00108"></a>00108 {
<a name="l00109"></a>00109   <span class="keywordtype">int</span> unpadded_len;
<a name="l00110"></a>00110 
<a name="l00111"></a>00111   _dbus_assert (header-&gt;<a class="code" href="structDBusHeader.html#aa22a8d00f061310e12716f656b4d9b8f" title="bytes of alignment in header">padding</a> == 7);
<a name="l00112"></a>00112 
<a name="l00113"></a>00113   <a class="code" href="group__DBusString.html#ga7af1cbfa905f26d972ab644d890548b8" title="Makes a string shorter by the given number of bytes.">_dbus_string_shorten</a> (&amp;header-&gt;<a class="code" href="structDBusHeader.html#a67df8bff43c10e2d4f6ae36b56ee5814" title="Header network data, stored separately from body so we can independently realloc it.">data</a>, header-&gt;<a class="code" href="structDBusHeader.html#aa22a8d00f061310e12716f656b4d9b8f" title="bytes of alignment in header">padding</a>);
<a name="l00114"></a>00114   unpadded_len = _dbus_string_get_length (&amp;header-&gt;<a class="code" href="structDBusHeader.html#a67df8bff43c10e2d4f6ae36b56ee5814" title="Header network data, stored separately from body so we can independently realloc it.">data</a>);
<a name="l00115"></a>00115 
<a name="l00116"></a>00116   <span class="keywordflow">if</span> (!<a class="code" href="group__DBusString.html#gaeadfb67c4e796131610499c91d0d7813" title="Align the length of a string to a specific alignment (typically 4 or 8) by appending nul bytes to the...">_dbus_string_align_length</a> (&amp;header-&gt;<a class="code" href="structDBusHeader.html#a67df8bff43c10e2d4f6ae36b56ee5814" title="Header network data, stored separately from body so we can independently realloc it.">data</a>, 8))
<a name="l00117"></a>00117     _dbus_assert_not_reached (<span class="stringliteral">&quot;couldn&#39;t pad header though enough padding was preallocated&quot;</span>);
<a name="l00118"></a>00118 
<a name="l00119"></a>00119   header-&gt;<a class="code" href="structDBusHeader.html#aa22a8d00f061310e12716f656b4d9b8f" title="bytes of alignment in header">padding</a> = _dbus_string_get_length (&amp;header-&gt;<a class="code" href="structDBusHeader.html#a67df8bff43c10e2d4f6ae36b56ee5814" title="Header network data, stored separately from body so we can independently realloc it.">data</a>) - unpadded_len;
<a name="l00120"></a>00120 }
<a name="l00121"></a>00121 
<a name="l00123"></a><a class="code" href="group__DBusMarshal.html#gaef7e86e442aeb887c8bfe5559cd4eabb">00123</a> <span class="preprocessor">#define HEADER_END_BEFORE_PADDING(header) \</span>
<a name="l00124"></a>00124 <span class="preprocessor">  (_dbus_string_get_length (&amp;(header)-&gt;data) - (header)-&gt;padding)</span>
<a name="l00125"></a>00125 <span class="preprocessor"></span>
<a name="l00133"></a>00133 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00134"></a>00134 _dbus_header_cache_invalidate_all (<a class="code" href="structDBusHeader.html" title="Message header data and some cached details of it.">DBusHeader</a> *header)
<a name="l00135"></a>00135 {
<a name="l00136"></a>00136   <span class="keywordtype">int</span> i;
<a name="l00137"></a>00137 
<a name="l00138"></a>00138   i = 0;
<a name="l00139"></a>00139   <span class="keywordflow">while</span> (i &lt;= <a class="code" href="group__DBusProtocol.html#ga94f09d2b35473c8ffa6d3190b5f97c5c" title="Value of the highest-numbered header field code, can be used to determine the size of an array indexe...">DBUS_HEADER_FIELD_LAST</a>)
<a name="l00140"></a>00140     {
<a name="l00141"></a>00141       header-&gt;<a class="code" href="structDBusHeader.html#ac58a309593d0dc7e8d5a02f3b3442384" title="Track the location of each field in header.">fields</a>[i].<a class="code" href="structDBusHeaderField.html#aa9616d127de7488f6d9dc18c4d0c2133" title="Position of field value, or -1/-2.">value_pos</a> = _DBUS_HEADER_FIELD_VALUE_UNKNOWN;
<a name="l00142"></a>00142       ++i;
<a name="l00143"></a>00143     }
<a name="l00144"></a>00144 }
<a name="l00145"></a>00145 
<a name="l00153"></a>00153 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00154"></a>00154 _dbus_header_cache_one (<a class="code" href="structDBusHeader.html" title="Message header data and some cached details of it.">DBusHeader</a>     *header,
<a name="l00155"></a>00155                         <span class="keywordtype">int</span>             field_code,
<a name="l00156"></a>00156                         <a class="code" href="structDBusTypeReader.html" title="The type reader is an iterator for reading values from a block of values.">DBusTypeReader</a> *variant_reader)
<a name="l00157"></a>00157 {
<a name="l00158"></a>00158   header-&gt;<a class="code" href="structDBusHeader.html#ac58a309593d0dc7e8d5a02f3b3442384" title="Track the location of each field in header.">fields</a>[field_code].<a class="code" href="structDBusHeaderField.html#aa9616d127de7488f6d9dc18c4d0c2133" title="Position of field value, or -1/-2.">value_pos</a> =
<a name="l00159"></a>00159     <a class="code" href="group__DBusMarshal.html#ga2a8ab1152821950b1fe29e000954981c" title="Gets the current position in the value block.">_dbus_type_reader_get_value_pos</a> (variant_reader);
<a name="l00160"></a>00160 
<a name="l00161"></a>00161 <span class="preprocessor">#if 0</span>
<a name="l00162"></a>00162 <span class="preprocessor"></span>  _dbus_verbose (<span class="stringliteral">&quot;cached value_pos %d for field %d\n&quot;</span>,
<a name="l00163"></a>00163                  header-&gt;<a class="code" href="structDBusHeader.html#ac58a309593d0dc7e8d5a02f3b3442384" title="Track the location of each field in header.">fields</a>[field_code].<a class="code" href="structDBusHeaderField.html#aa9616d127de7488f6d9dc18c4d0c2133" title="Position of field value, or -1/-2.">value_pos</a>, field_code)
<a name="l00164"></a>00164 <span class="preprocessor">#endif</span>
<a name="l00165"></a>00165 <span class="preprocessor"></span>}
<a name="l00166"></a>00166 
<a name="l00173"></a>00173 <span class="keywordtype">char</span>
<a name="l00174"></a><a class="code" href="group__DBusMarshal.html#ga65c023673b837c27e8ccda5c2528d806">00174</a> <a class="code" href="group__DBusMarshal.html#ga65c023673b837c27e8ccda5c2528d806" title="Returns the header&#39;s byte order.">_dbus_header_get_byte_order</a> (<span class="keyword">const</span> <a class="code" href="structDBusHeader.html" title="Message header data and some cached details of it.">DBusHeader</a> *header)
<a name="l00175"></a>00175 {
<a name="l00176"></a>00176   _dbus_assert (_dbus_string_get_length (&amp;header-&gt;<a class="code" href="structDBusHeader.html#a67df8bff43c10e2d4f6ae36b56ee5814" title="Header network data, stored separately from body so we can independently realloc it.">data</a>) &gt; <a class="code" href="group__DBusMarshal.html#gaa5b7e77f37761139698892e4b8aad029" title="Offset to byte order from start of header.">BYTE_ORDER_OFFSET</a>);
<a name="l00177"></a>00177 
<a name="l00178"></a>00178   <span class="keywordflow">return</span> (<span class="keywordtype">char</span>) _dbus_string_get_byte (&amp;header-&gt;<a class="code" href="structDBusHeader.html#a67df8bff43c10e2d4f6ae36b56ee5814" title="Header network data, stored separately from body so we can independently realloc it.">data</a>, <a class="code" href="group__DBusMarshal.html#gaa5b7e77f37761139698892e4b8aad029" title="Offset to byte order from start of header.">BYTE_ORDER_OFFSET</a>);
<a name="l00179"></a>00179 }
<a name="l00180"></a>00180 
<a name="l00186"></a>00186 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00187"></a>00187 _dbus_header_cache_revalidate (<a class="code" href="structDBusHeader.html" title="Message header data and some cached details of it.">DBusHeader</a> *header)
<a name="l00188"></a>00188 {
<a name="l00189"></a>00189   <a class="code" href="structDBusTypeReader.html" title="The type reader is an iterator for reading values from a block of values.">DBusTypeReader</a> array;
<a name="l00190"></a>00190   <a class="code" href="structDBusTypeReader.html" title="The type reader is an iterator for reading values from a block of values.">DBusTypeReader</a> reader;
<a name="l00191"></a>00191   <span class="keywordtype">int</span> i;
<a name="l00192"></a>00192 
<a name="l00193"></a>00193   i = 0;
<a name="l00194"></a>00194   <span class="keywordflow">while</span> (i &lt;= <a class="code" href="group__DBusProtocol.html#ga94f09d2b35473c8ffa6d3190b5f97c5c" title="Value of the highest-numbered header field code, can be used to determine the size of an array indexe...">DBUS_HEADER_FIELD_LAST</a>)
<a name="l00195"></a>00195     {
<a name="l00196"></a>00196       header-&gt;<a class="code" href="structDBusHeader.html#ac58a309593d0dc7e8d5a02f3b3442384" title="Track the location of each field in header.">fields</a>[i].<a class="code" href="structDBusHeaderField.html#aa9616d127de7488f6d9dc18c4d0c2133" title="Position of field value, or -1/-2.">value_pos</a> = _DBUS_HEADER_FIELD_VALUE_NONEXISTENT;
<a name="l00197"></a>00197       ++i;
<a name="l00198"></a>00198     }
<a name="l00199"></a>00199 
<a name="l00200"></a>00200   <a class="code" href="group__DBusMarshal.html#ga35d70cf69b1196518367e3e68e9b2dd2" title="Initializes a type reader.">_dbus_type_reader_init</a> (&amp;reader,
<a name="l00201"></a>00201                           <a class="code" href="group__DBusMarshal.html#ga65c023673b837c27e8ccda5c2528d806" title="Returns the header&#39;s byte order.">_dbus_header_get_byte_order</a> (header),
<a name="l00202"></a>00202                           &amp;_dbus_header_signature_str,
<a name="l00203"></a>00203                           <a class="code" href="group__DBusMarshal.html#ga935ea6d7c6bb72a10c670f5ef3e34d49" title="Offset from start of _dbus_header_signature_str to the signature of the fields array.">FIELDS_ARRAY_SIGNATURE_OFFSET</a>,
<a name="l00204"></a>00204                           &amp;header-&gt;<a class="code" href="structDBusHeader.html#a67df8bff43c10e2d4f6ae36b56ee5814" title="Header network data, stored separately from body so we can independently realloc it.">data</a>,
<a name="l00205"></a>00205                           <a class="code" href="group__DBusMarshal.html#gae9759e0de1d8a650f37632c3dc22427e" title="Offset to fields array length from start of header.">FIELDS_ARRAY_LENGTH_OFFSET</a>);
<a name="l00206"></a>00206 
<a name="l00207"></a>00207   <a class="code" href="group__DBusMarshal.html#ga082b410820c74b2a6ca816a8e0c91803" title="Initialize a new reader pointing to the first type and corresponding value that&#39;s a child of the curr...">_dbus_type_reader_recurse</a> (&amp;reader, &amp;array);
<a name="l00208"></a>00208 
<a name="l00209"></a>00209   <span class="keywordflow">while</span> (<a class="code" href="group__DBusMarshal.html#gab8e39cb8084247d54d7f272c51622a73" title="Gets the type of the value the reader is currently pointing to; or for a types-only reader gets the t...">_dbus_type_reader_get_current_type</a> (&amp;array) != <a class="code" href="group__DBusProtocol.html#gaa9588da889743b2119dc6664712ae51e" title="Type code that is never equal to a legitimate type code.">DBUS_TYPE_INVALID</a>)
<a name="l00210"></a>00210     {
<a name="l00211"></a>00211       <a class="code" href="structDBusTypeReader.html" title="The type reader is an iterator for reading values from a block of values.">DBusTypeReader</a> sub;
<a name="l00212"></a>00212       <a class="code" href="structDBusTypeReader.html" title="The type reader is an iterator for reading values from a block of values.">DBusTypeReader</a> variant;
<a name="l00213"></a>00213       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> field_code;
<a name="l00214"></a>00214 
<a name="l00215"></a>00215       <a class="code" href="group__DBusMarshal.html#ga082b410820c74b2a6ca816a8e0c91803" title="Initialize a new reader pointing to the first type and corresponding value that&#39;s a child of the curr...">_dbus_type_reader_recurse</a> (&amp;array, &amp;sub);
<a name="l00216"></a>00216 
<a name="l00217"></a>00217       _dbus_assert (<a class="code" href="group__DBusMarshal.html#gab8e39cb8084247d54d7f272c51622a73" title="Gets the type of the value the reader is currently pointing to; or for a types-only reader gets the t...">_dbus_type_reader_get_current_type</a> (&amp;sub) == <a class="code" href="group__DBusProtocol.html#ga355d6d0998164a5eb915a26fb67fce5f" title="Type code marking an 8-bit unsigned integer.">DBUS_TYPE_BYTE</a>);
<a name="l00218"></a>00218       <a class="code" href="group__DBusMarshal.html#gaa54355ee98d6721d7a29b5ae7d92eb9a" title="Reads a basic-typed value, as with _dbus_marshal_read_basic().">_dbus_type_reader_read_basic</a> (&amp;sub, &amp;field_code);
<a name="l00219"></a>00219 
<a name="l00220"></a>00220       <span class="comment">/* Unknown fields should be ignored */</span>
<a name="l00221"></a>00221       <span class="keywordflow">if</span> (field_code &gt; <a class="code" href="group__DBusProtocol.html#ga94f09d2b35473c8ffa6d3190b5f97c5c" title="Value of the highest-numbered header field code, can be used to determine the size of an array indexe...">DBUS_HEADER_FIELD_LAST</a>)
<a name="l00222"></a>00222         <span class="keywordflow">goto</span> next_field;
<a name="l00223"></a>00223 
<a name="l00224"></a>00224       <a class="code" href="group__DBusMarshal.html#ga746c09512d4905f2d2fac7ed4c3c63c2" title="Skip to the next value on this &quot;level&quot;.">_dbus_type_reader_next</a> (&amp;sub);
<a name="l00225"></a>00225 
<a name="l00226"></a>00226       _dbus_assert (<a class="code" href="group__DBusMarshal.html#gab8e39cb8084247d54d7f272c51622a73" title="Gets the type of the value the reader is currently pointing to; or for a types-only reader gets the t...">_dbus_type_reader_get_current_type</a> (&amp;sub) == <a class="code" href="group__DBusProtocol.html#ga4aa7a463ad2bce4e9aa95e3e397ddcf1" title="Type code marking a D-Bus variant type.">DBUS_TYPE_VARIANT</a>);
<a name="l00227"></a>00227       <a class="code" href="group__DBusMarshal.html#ga082b410820c74b2a6ca816a8e0c91803" title="Initialize a new reader pointing to the first type and corresponding value that&#39;s a child of the curr...">_dbus_type_reader_recurse</a> (&amp;sub, &amp;variant);
<a name="l00228"></a>00228 
<a name="l00229"></a>00229       _dbus_header_cache_one (header, field_code, &amp;variant);
<a name="l00230"></a>00230 
<a name="l00231"></a>00231     next_field:
<a name="l00232"></a>00232       <a class="code" href="group__DBusMarshal.html#ga746c09512d4905f2d2fac7ed4c3c63c2" title="Skip to the next value on this &quot;level&quot;.">_dbus_type_reader_next</a> (&amp;array);
<a name="l00233"></a>00233     }
<a name="l00234"></a>00234 }
<a name="l00235"></a>00235 
<a name="l00243"></a>00243 <span class="keyword">static</span> <a class="code" href="group__DBusTypes.html#ga39c9cb0f3a2a8ad6f55cc4855d035349" title="A boolean, valid values are TRUE and FALSE.">dbus_bool_t</a>
<a name="l00244"></a>00244 _dbus_header_cache_check (<a class="code" href="structDBusHeader.html" title="Message header data and some cached details of it.">DBusHeader</a>    *header,
<a name="l00245"></a>00245                           <span class="keywordtype">int</span>            field)
<a name="l00246"></a>00246 {
<a name="l00247"></a>00247   _dbus_assert (field &lt;= <a class="code" href="group__DBusProtocol.html#ga94f09d2b35473c8ffa6d3190b5f97c5c" title="Value of the highest-numbered header field code, can be used to determine the size of an array indexe...">DBUS_HEADER_FIELD_LAST</a>);
<a name="l00248"></a>00248 
<a name="l00249"></a>00249   <span class="keywordflow">if</span> (header-&gt;<a class="code" href="structDBusHeader.html#ac58a309593d0dc7e8d5a02f3b3442384" title="Track the location of each field in header.">fields</a>[field].<a class="code" href="structDBusHeaderField.html#aa9616d127de7488f6d9dc18c4d0c2133" title="Position of field value, or -1/-2.">value_pos</a> == _DBUS_HEADER_FIELD_VALUE_UNKNOWN)
<a name="l00250"></a>00250     _dbus_header_cache_revalidate (header);
<a name="l00251"></a>00251 
<a name="l00252"></a>00252   <span class="keywordflow">if</span> (header-&gt;<a class="code" href="structDBusHeader.html#ac58a309593d0dc7e8d5a02f3b3442384" title="Track the location of each field in header.">fields</a>[field].<a class="code" href="structDBusHeaderField.html#aa9616d127de7488f6d9dc18c4d0c2133" title="Position of field value, or -1/-2.">value_pos</a> == _DBUS_HEADER_FIELD_VALUE_NONEXISTENT)
<a name="l00253"></a>00253     <span class="keywordflow">return</span> <a class="code" href="group__DBusMacros.html#gaa93f0eb578d23995850d61f7d61c55c1" title="Expands to &quot;0&quot;.">FALSE</a>;
<a name="l00254"></a>00254 
<a name="l00255"></a>00255   <span class="keywordflow">return</span> <a class="code" href="group__DBusMacros.html#gaa8cecfc5c5c054d2875c03e77b7be15d" title="Expands to &quot;1&quot;.">TRUE</a>;
<a name="l00256"></a>00256 }
<a name="l00257"></a>00257 
<a name="l00266"></a>00266 <span class="keyword">static</span> <a class="code" href="group__DBusTypes.html#ga39c9cb0f3a2a8ad6f55cc4855d035349" title="A boolean, valid values are TRUE and FALSE.">dbus_bool_t</a>
<a name="l00267"></a>00267 _dbus_header_cache_known_nonexistent (<a class="code" href="structDBusHeader.html" title="Message header data and some cached details of it.">DBusHeader</a>    *header,
<a name="l00268"></a>00268                                       <span class="keywordtype">int</span>            field)
<a name="l00269"></a>00269 {
<a name="l00270"></a>00270   _dbus_assert (field &lt;= <a class="code" href="group__DBusProtocol.html#ga94f09d2b35473c8ffa6d3190b5f97c5c" title="Value of the highest-numbered header field code, can be used to determine the size of an array indexe...">DBUS_HEADER_FIELD_LAST</a>);
<a name="l00271"></a>00271 
<a name="l00272"></a>00272   <span class="keywordflow">return</span> (header-&gt;<a class="code" href="structDBusHeader.html#ac58a309593d0dc7e8d5a02f3b3442384" title="Track the location of each field in header.">fields</a>[field].<a class="code" href="structDBusHeaderField.html#aa9616d127de7488f6d9dc18c4d0c2133" title="Position of field value, or -1/-2.">value_pos</a> == _DBUS_HEADER_FIELD_VALUE_NONEXISTENT);
<a name="l00273"></a>00273 }
<a name="l00274"></a>00274 
<a name="l00283"></a>00283 <span class="keyword">static</span> <a class="code" href="group__DBusTypes.html#ga39c9cb0f3a2a8ad6f55cc4855d035349" title="A boolean, valid values are TRUE and FALSE.">dbus_bool_t</a>
<a name="l00284"></a>00284 write_basic_field (<a class="code" href="structDBusTypeWriter.html" title="The type writer is an iterator for writing to a block of values.">DBusTypeWriter</a> *writer,
<a name="l00285"></a>00285                    <span class="keywordtype">int</span>             field,
<a name="l00286"></a>00286                    <span class="keywordtype">int</span>             type,
<a name="l00287"></a>00287                    <span class="keyword">const</span> <span class="keywordtype">void</span>     *value)
<a name="l00288"></a>00288 {
<a name="l00289"></a>00289   <a class="code" href="structDBusTypeWriter.html" title="The type writer is an iterator for writing to a block of values.">DBusTypeWriter</a> sub;
<a name="l00290"></a>00290   <a class="code" href="structDBusTypeWriter.html" title="The type writer is an iterator for writing to a block of values.">DBusTypeWriter</a> variant;
<a name="l00291"></a>00291   <span class="keywordtype">int</span> start;
<a name="l00292"></a>00292   <span class="keywordtype">int</span> padding;
<a name="l00293"></a>00293   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> field_byte;
<a name="l00294"></a>00294   <a class="code" href="structDBusString.html">DBusString</a> contained_type;
<a name="l00295"></a>00295   <span class="keywordtype">char</span> buf[2];
<a name="l00296"></a>00296 
<a name="l00297"></a>00297   start = writer-&gt;<a class="code" href="structDBusTypeWriter.html#a27c0475eedd90be65f90a799e5210947" title="next position to write">value_pos</a>;
<a name="l00298"></a>00298   padding = _dbus_string_get_length (writer-&gt;<a class="code" href="structDBusTypeWriter.html#aa4e4b3af31fd7a93d0e54d10882bcc07" title="where to write values">value_str</a>) - start;
<a name="l00299"></a>00299 
<a name="l00300"></a>00300   <span class="keywordflow">if</span> (!<a class="code" href="group__DBusMarshal.html#ga4c0a1036e59dac270141052d951baff2" title="Opens a new container and writes out the initial information for that container.">_dbus_type_writer_recurse</a> (writer, <a class="code" href="group__DBusProtocol.html#gae4b22a74b9edb0ec0ff6e0294794d3f9" title="STRUCT and DICT_ENTRY are sort of special since their codes can&#39;t appear in a type string...">DBUS_TYPE_STRUCT</a>,
<a name="l00301"></a>00301                                   <a class="code" href="group__DBusMacros.html#ga070d2ce7b6bb7e5c05602aa8c308d0c4" title="A null pointer, defined appropriately for C or C++.">NULL</a>, 0, &amp;sub))
<a name="l00302"></a>00302     <span class="keywordflow">goto</span> append_failed;
<a name="l00303"></a>00303 
<a name="l00304"></a>00304   field_byte = field;
<a name="l00305"></a>00305   <span class="keywordflow">if</span> (!<a class="code" href="group__DBusMarshal.html#ga0103b0214766b0ff1ca05bcc7f1e631b" title="Writes out a basic type.">_dbus_type_writer_write_basic</a> (&amp;sub, <a class="code" href="group__DBusProtocol.html#ga355d6d0998164a5eb915a26fb67fce5f" title="Type code marking an 8-bit unsigned integer.">DBUS_TYPE_BYTE</a>,
<a name="l00306"></a>00306                                       &amp;field_byte))
<a name="l00307"></a>00307     <span class="keywordflow">goto</span> append_failed;
<a name="l00308"></a>00308 
<a name="l00309"></a>00309   buf[0] = type;
<a name="l00310"></a>00310   buf[1] = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l00311"></a>00311   <a class="code" href="group__DBusString.html#ga6792a5c1725faa9d635d95f7a3b5bfae" title="Initializes a constant string with a length.">_dbus_string_init_const_len</a> (&amp;contained_type, buf, 1);
<a name="l00312"></a>00312 
<a name="l00313"></a>00313   <span class="keywordflow">if</span> (!<a class="code" href="group__DBusMarshal.html#ga4c0a1036e59dac270141052d951baff2" title="Opens a new container and writes out the initial information for that container.">_dbus_type_writer_recurse</a> (&amp;sub, <a class="code" href="group__DBusProtocol.html#ga4aa7a463ad2bce4e9aa95e3e397ddcf1" title="Type code marking a D-Bus variant type.">DBUS_TYPE_VARIANT</a>,
<a name="l00314"></a>00314                                   &amp;contained_type, 0, &amp;variant))
<a name="l00315"></a>00315     <span class="keywordflow">goto</span> append_failed;
<a name="l00316"></a>00316 
<a name="l00317"></a>00317   <span class="keywordflow">if</span> (!<a class="code" href="group__DBusMarshal.html#ga0103b0214766b0ff1ca05bcc7f1e631b" title="Writes out a basic type.">_dbus_type_writer_write_basic</a> (&amp;variant, type, value))
<a name="l00318"></a>00318     <span class="keywordflow">goto</span> append_failed;
<a name="l00319"></a>00319 
<a name="l00320"></a>00320   <span class="keywordflow">if</span> (!<a class="code" href="group__DBusMarshal.html#gacbe7eddf4f9c19da91b742087fcc111a" title="Closes a container created by _dbus_type_writer_recurse() and writes any additional information to th...">_dbus_type_writer_unrecurse</a> (&amp;sub, &amp;variant))
<a name="l00321"></a>00321     <span class="keywordflow">goto</span> append_failed;
<a name="l00322"></a>00322 
<a name="l00323"></a>00323   <span class="keywordflow">if</span> (!<a class="code" href="group__DBusMarshal.html#gacbe7eddf4f9c19da91b742087fcc111a" title="Closes a container created by _dbus_type_writer_recurse() and writes any additional information to th...">_dbus_type_writer_unrecurse</a> (writer, &amp;sub))
<a name="l00324"></a>00324     <span class="keywordflow">goto</span> append_failed;
<a name="l00325"></a>00325 
<a name="l00326"></a>00326   <span class="keywordflow">return</span> <a class="code" href="group__DBusMacros.html#gaa8cecfc5c5c054d2875c03e77b7be15d" title="Expands to &quot;1&quot;.">TRUE</a>;
<a name="l00327"></a>00327 
<a name="l00328"></a>00328  append_failed:
<a name="l00329"></a>00329   <a class="code" href="group__DBusString.html#ga7e0e164ad5bb094e5ccad9edc7ae4235" title="Deletes a segment of a DBusString with length len starting at start.">_dbus_string_delete</a> (writer-&gt;<a class="code" href="structDBusTypeWriter.html#aa4e4b3af31fd7a93d0e54d10882bcc07" title="where to write values">value_str</a>,
<a name="l00330"></a>00330                        start,
<a name="l00331"></a>00331                        _dbus_string_get_length (writer-&gt;<a class="code" href="structDBusTypeWriter.html#aa4e4b3af31fd7a93d0e54d10882bcc07" title="where to write values">value_str</a>) - start - padding);
<a name="l00332"></a>00332   <span class="keywordflow">return</span> <a class="code" href="group__DBusMacros.html#gaa93f0eb578d23995850d61f7d61c55c1" title="Expands to &quot;0&quot;.">FALSE</a>;
<a name="l00333"></a>00333 }
<a name="l00334"></a>00334 
<a name="l00344"></a>00344 <span class="keyword">static</span> <a class="code" href="group__DBusTypes.html#ga39c9cb0f3a2a8ad6f55cc4855d035349" title="A boolean, valid values are TRUE and FALSE.">dbus_bool_t</a>
<a name="l00345"></a>00345 set_basic_field (<a class="code" href="structDBusTypeReader.html" title="The type reader is an iterator for reading values from a block of values.">DBusTypeReader</a>       *reader,
<a name="l00346"></a>00346                  <span class="keywordtype">int</span>                   field,
<a name="l00347"></a>00347                  <span class="keywordtype">int</span>                   type,
<a name="l00348"></a>00348                  <span class="keyword">const</span> <span class="keywordtype">void</span>           *value,
<a name="l00349"></a>00349                  <span class="keyword">const</span> <a class="code" href="structDBusTypeReader.html" title="The type reader is an iterator for reading values from a block of values.">DBusTypeReader</a> *realign_root)
<a name="l00350"></a>00350 {
<a name="l00351"></a>00351   <a class="code" href="structDBusTypeReader.html" title="The type reader is an iterator for reading values from a block of values.">DBusTypeReader</a> sub;
<a name="l00352"></a>00352   <a class="code" href="structDBusTypeReader.html" title="The type reader is an iterator for reading values from a block of values.">DBusTypeReader</a> variant;
<a name="l00353"></a>00353 
<a name="l00354"></a>00354   <a class="code" href="group__DBusMarshal.html#ga082b410820c74b2a6ca816a8e0c91803" title="Initialize a new reader pointing to the first type and corresponding value that&#39;s a child of the curr...">_dbus_type_reader_recurse</a> (reader, &amp;sub);
<a name="l00355"></a>00355 
<a name="l00356"></a>00356   _dbus_assert (<a class="code" href="group__DBusMarshal.html#gab8e39cb8084247d54d7f272c51622a73" title="Gets the type of the value the reader is currently pointing to; or for a types-only reader gets the t...">_dbus_type_reader_get_current_type</a> (&amp;sub) == <a class="code" href="group__DBusProtocol.html#ga355d6d0998164a5eb915a26fb67fce5f" title="Type code marking an 8-bit unsigned integer.">DBUS_TYPE_BYTE</a>);
<a name="l00357"></a>00357 <span class="preprocessor">#ifndef DBUS_DISABLE_ASSERT</span>
<a name="l00358"></a>00358 <span class="preprocessor"></span> {
<a name="l00359"></a>00359    <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> v_BYTE;
<a name="l00360"></a>00360    <a class="code" href="group__DBusMarshal.html#gaa54355ee98d6721d7a29b5ae7d92eb9a" title="Reads a basic-typed value, as with _dbus_marshal_read_basic().">_dbus_type_reader_read_basic</a> (&amp;sub, &amp;v_BYTE);
<a name="l00361"></a>00361    _dbus_assert (((<span class="keywordtype">int</span>) v_BYTE) == field);
<a name="l00362"></a>00362  }
<a name="l00363"></a>00363 <span class="preprocessor">#endif</span>
<a name="l00364"></a>00364 <span class="preprocessor"></span>
<a name="l00365"></a>00365   <span class="keywordflow">if</span> (!<a class="code" href="group__DBusMarshal.html#ga746c09512d4905f2d2fac7ed4c3c63c2" title="Skip to the next value on this &quot;level&quot;.">_dbus_type_reader_next</a> (&amp;sub))
<a name="l00366"></a>00366     _dbus_assert_not_reached (<span class="stringliteral">&quot;no variant field?&quot;</span>);
<a name="l00367"></a>00367 
<a name="l00368"></a>00368   <a class="code" href="group__DBusMarshal.html#ga082b410820c74b2a6ca816a8e0c91803" title="Initialize a new reader pointing to the first type and corresponding value that&#39;s a child of the curr...">_dbus_type_reader_recurse</a> (&amp;sub, &amp;variant);
<a name="l00369"></a>00369   _dbus_assert (<a class="code" href="group__DBusMarshal.html#gab8e39cb8084247d54d7f272c51622a73" title="Gets the type of the value the reader is currently pointing to; or for a types-only reader gets the t...">_dbus_type_reader_get_current_type</a> (&amp;variant) == type);
<a name="l00370"></a>00370 
<a name="l00371"></a>00371   <span class="keywordflow">if</span> (!<a class="code" href="group__DBusMarshal.html#gaaf11ca429434c2c280f5fad34ed95204" title="Sets a new value for the basic type value pointed to by the reader, leaving the reader valid to conti...">_dbus_type_reader_set_basic</a> (&amp;variant, value, realign_root))
<a name="l00372"></a>00372     <span class="keywordflow">return</span> <a class="code" href="group__DBusMacros.html#gaa93f0eb578d23995850d61f7d61c55c1" title="Expands to &quot;0&quot;.">FALSE</a>;
<a name="l00373"></a>00373 
<a name="l00374"></a>00374   <span class="keywordflow">return</span> <a class="code" href="group__DBusMacros.html#gaa8cecfc5c5c054d2875c03e77b7be15d" title="Expands to &quot;1&quot;.">TRUE</a>;
<a name="l00375"></a>00375 }
<a name="l00376"></a>00376 
<a name="l00383"></a>00383 <span class="keywordtype">int</span>
<a name="l00384"></a><a class="code" href="group__DBusMarshal.html#ga4427247494fc5c988498c5a87d42092d">00384</a> <a class="code" href="group__DBusMarshal.html#ga4427247494fc5c988498c5a87d42092d" title="Gets the type of the message.">_dbus_header_get_message_type</a> (<a class="code" href="structDBusHeader.html" title="Message header data and some cached details of it.">DBusHeader</a> *header)
<a name="l00385"></a>00385 {
<a name="l00386"></a>00386   <span class="keywordtype">int</span> type;
<a name="l00387"></a>00387 
<a name="l00388"></a>00388   type = _dbus_string_get_byte (&amp;header-&gt;<a class="code" href="structDBusHeader.html#a67df8bff43c10e2d4f6ae36b56ee5814" title="Header network data, stored separately from body so we can independently realloc it.">data</a>, <a class="code" href="group__DBusMarshal.html#gaf4fe78df75f4afa2ec63304462614b03" title="Offset to type from start of header.">TYPE_OFFSET</a>);
<a name="l00389"></a>00389   _dbus_assert (type != <a class="code" href="group__DBusProtocol.html#gac975525a6ce258a7a70c583c9741b516" title="This value is never a valid message type, see dbus_message_get_type()">DBUS_MESSAGE_TYPE_INVALID</a>);
<a name="l00390"></a>00390 
<a name="l00391"></a>00391   <span class="keywordflow">return</span> type;
<a name="l00392"></a>00392 }
<a name="l00393"></a>00393 
<a name="l00401"></a>00401 <span class="keywordtype">void</span>
<a name="l00402"></a><a class="code" href="group__DBusMarshal.html#gad92e0b1992cf96a4da642a4a54a5d26d">00402</a> <a class="code" href="group__DBusMarshal.html#gad92e0b1992cf96a4da642a4a54a5d26d" title="Sets the serial number of a header.">_dbus_header_set_serial</a> (<a class="code" href="structDBusHeader.html" title="Message header data and some cached details of it.">DBusHeader</a>    *header,
<a name="l00403"></a>00403                          dbus_uint32_t  serial)
<a name="l00404"></a>00404 {
<a name="l00405"></a>00405   <span class="comment">/* we use this function to set the serial on outgoing</span>
<a name="l00406"></a>00406 <span class="comment">   * messages, and to reset the serial in dbus_message_copy;</span>
<a name="l00407"></a>00407 <span class="comment">   * this assertion should catch a double-set on outgoing.</span>
<a name="l00408"></a>00408 <span class="comment">   */</span>
<a name="l00409"></a>00409   _dbus_assert (<a class="code" href="group__DBusMarshal.html#ga7ec7222423db42935aae4a24499ee0fb" title="See dbus_message_get_serial()">_dbus_header_get_serial</a> (header) == 0 ||
<a name="l00410"></a>00410                 serial == 0);
<a name="l00411"></a>00411 
<a name="l00412"></a>00412   <a class="code" href="group__DBusMarshal.html#ga4bcfb6a664c7e46c7ffc31f96d532a02" title="Sets the 4 bytes at the given offset to a marshaled unsigned integer, replacing anything found there ...">_dbus_marshal_set_uint32</a> (&amp;header-&gt;<a class="code" href="structDBusHeader.html#a67df8bff43c10e2d4f6ae36b56ee5814" title="Header network data, stored separately from body so we can independently realloc it.">data</a>,
<a name="l00413"></a>00413                             <a class="code" href="group__DBusMarshal.html#ga4a9c0639714b478a4905cdd6e999b6b3" title="Offset to client serial from start of header.">SERIAL_OFFSET</a>,
<a name="l00414"></a>00414                             serial,
<a name="l00415"></a>00415                             <a class="code" href="group__DBusMarshal.html#ga65c023673b837c27e8ccda5c2528d806" title="Returns the header&#39;s byte order.">_dbus_header_get_byte_order</a> (header));
<a name="l00416"></a>00416 }
<a name="l00417"></a>00417 
<a name="l00424"></a>00424 dbus_uint32_t
<a name="l00425"></a><a class="code" href="group__DBusMarshal.html#ga7ec7222423db42935aae4a24499ee0fb">00425</a> <a class="code" href="group__DBusMarshal.html#ga7ec7222423db42935aae4a24499ee0fb" title="See dbus_message_get_serial()">_dbus_header_get_serial</a> (<a class="code" href="structDBusHeader.html" title="Message header data and some cached details of it.">DBusHeader</a> *header)
<a name="l00426"></a>00426 {
<a name="l00427"></a>00427   <span class="keywordflow">return</span> <a class="code" href="group__DBusMarshal.html#ga6dd82a202c19758cbf76dbed2946615d" title="Convenience function to demarshal a 32 bit unsigned integer.">_dbus_marshal_read_uint32</a> (&amp;header-&gt;<a class="code" href="structDBusHeader.html#a67df8bff43c10e2d4f6ae36b56ee5814" title="Header network data, stored separately from body so we can independently realloc it.">data</a>,
<a name="l00428"></a>00428                                     <a class="code" href="group__DBusMarshal.html#ga4a9c0639714b478a4905cdd6e999b6b3" title="Offset to client serial from start of header.">SERIAL_OFFSET</a>,
<a name="l00429"></a>00429                                     <a class="code" href="group__DBusMarshal.html#ga65c023673b837c27e8ccda5c2528d806" title="Returns the header&#39;s byte order.">_dbus_header_get_byte_order</a> (header),
<a name="l00430"></a>00430                                     <a class="code" href="group__DBusMacros.html#ga070d2ce7b6bb7e5c05602aa8c308d0c4" title="A null pointer, defined appropriately for C or C++.">NULL</a>);
<a name="l00431"></a>00431 }
<a name="l00432"></a>00432 
<a name="l00440"></a>00440 <span class="keywordtype">void</span>
<a name="l00441"></a><a class="code" href="group__DBusMarshal.html#ga6d41ad4de211c87f4b8a43340b6893e2">00441</a> <a class="code" href="group__DBusMarshal.html#ga6d41ad4de211c87f4b8a43340b6893e2" title="Re-initializes a header that was previously initialized and never freed.">_dbus_header_reinit</a> (<a class="code" href="structDBusHeader.html" title="Message header data and some cached details of it.">DBusHeader</a> *header)
<a name="l00442"></a>00442 {
<a name="l00443"></a>00443   <a class="code" href="group__DBusString.html#ga08c423b93c28dd746dcb93e0461ab95c" title="Sets the length of a string.">_dbus_string_set_length</a> (&amp;header-&gt;<a class="code" href="structDBusHeader.html#a67df8bff43c10e2d4f6ae36b56ee5814" title="Header network data, stored separately from body so we can independently realloc it.">data</a>, 0);
<a name="l00444"></a>00444 
<a name="l00445"></a>00445   header-&gt;<a class="code" href="structDBusHeader.html#aa22a8d00f061310e12716f656b4d9b8f" title="bytes of alignment in header">padding</a> = 0;
<a name="l00446"></a>00446 
<a name="l00447"></a>00447   _dbus_header_cache_invalidate_all (header);
<a name="l00448"></a>00448 }
<a name="l00449"></a>00449 
<a name="l00458"></a>00458 <a class="code" href="group__DBusTypes.html#ga39c9cb0f3a2a8ad6f55cc4855d035349" title="A boolean, valid values are TRUE and FALSE.">dbus_bool_t</a>
<a name="l00459"></a><a class="code" href="group__DBusMarshal.html#gabe1b78193d712976734a39d35842f033">00459</a> <a class="code" href="group__DBusMarshal.html#gabe1b78193d712976734a39d35842f033" title="Initializes a header, but doesn&#39;t prepare it for use; to make the header valid, you have to call _dbu...">_dbus_header_init</a> (<a class="code" href="structDBusHeader.html" title="Message header data and some cached details of it.">DBusHeader</a> *header)
<a name="l00460"></a>00460 {
<a name="l00461"></a>00461   <span class="keywordflow">if</span> (!<a class="code" href="group__DBusString.html#ga569b784beea1b4fa98f05d27e6dd0e72" title="Initializes a string that can be up to the given allocation size before it has to realloc...">_dbus_string_init_preallocated</a> (&amp;header-&gt;<a class="code" href="structDBusHeader.html#a67df8bff43c10e2d4f6ae36b56ee5814" title="Header network data, stored separately from body so we can independently realloc it.">data</a>, 32))
<a name="l00462"></a>00462     <span class="keywordflow">return</span> <a class="code" href="group__DBusMacros.html#gaa93f0eb578d23995850d61f7d61c55c1" title="Expands to &quot;0&quot;.">FALSE</a>;
<a name="l00463"></a>00463 
<a name="l00464"></a>00464   <a class="code" href="group__DBusMarshal.html#ga6d41ad4de211c87f4b8a43340b6893e2" title="Re-initializes a header that was previously initialized and never freed.">_dbus_header_reinit</a> (header);
<a name="l00465"></a>00465 
<a name="l00466"></a>00466   <span class="keywordflow">return</span> <a class="code" href="group__DBusMacros.html#gaa8cecfc5c5c054d2875c03e77b7be15d" title="Expands to &quot;1&quot;.">TRUE</a>;
<a name="l00467"></a>00467 }
<a name="l00468"></a>00468 
<a name="l00474"></a>00474 <span class="keywordtype">void</span>
<a name="l00475"></a><a class="code" href="group__DBusMarshal.html#gab90a814a27aeeace7e02c4ed130539cf">00475</a> <a class="code" href="group__DBusMarshal.html#gab90a814a27aeeace7e02c4ed130539cf" title="Frees a header.">_dbus_header_free</a> (<a class="code" href="structDBusHeader.html" title="Message header data and some cached details of it.">DBusHeader</a> *header)
<a name="l00476"></a>00476 {
<a name="l00477"></a>00477   <a class="code" href="group__DBusString.html#ga781ca91acda49a834dce7d0ed0eef212" title="Frees a string created by _dbus_string_init().">_dbus_string_free</a> (&amp;header-&gt;<a class="code" href="structDBusHeader.html#a67df8bff43c10e2d4f6ae36b56ee5814" title="Header network data, stored separately from body so we can independently realloc it.">data</a>);
<a name="l00478"></a>00478 }
<a name="l00479"></a>00479 
<a name="l00488"></a>00488 <a class="code" href="group__DBusTypes.html#ga39c9cb0f3a2a8ad6f55cc4855d035349" title="A boolean, valid values are TRUE and FALSE.">dbus_bool_t</a>
<a name="l00489"></a><a class="code" href="group__DBusMarshal.html#ga0d5aad82f8bf5a314dcf3f70930e254b">00489</a> <a class="code" href="group__DBusMarshal.html#ga0d5aad82f8bf5a314dcf3f70930e254b" title="Initializes dest with a copy of the given header.">_dbus_header_copy</a> (<span class="keyword">const</span> <a class="code" href="structDBusHeader.html" title="Message header data and some cached details of it.">DBusHeader</a> *header,
<a name="l00490"></a>00490                    <a class="code" href="structDBusHeader.html" title="Message header data and some cached details of it.">DBusHeader</a>       *dest)
<a name="l00491"></a>00491 {
<a name="l00492"></a>00492   *dest = *header;
<a name="l00493"></a>00493 
<a name="l00494"></a>00494   <span class="keywordflow">if</span> (!<a class="code" href="group__DBusString.html#ga569b784beea1b4fa98f05d27e6dd0e72" title="Initializes a string that can be up to the given allocation size before it has to realloc...">_dbus_string_init_preallocated</a> (&amp;dest-&gt;<a class="code" href="structDBusHeader.html#a67df8bff43c10e2d4f6ae36b56ee5814" title="Header network data, stored separately from body so we can independently realloc it.">data</a>,
<a name="l00495"></a>00495                                        _dbus_string_get_length (&amp;header-&gt;<a class="code" href="structDBusHeader.html#a67df8bff43c10e2d4f6ae36b56ee5814" title="Header network data, stored separately from body so we can independently realloc it.">data</a>)))
<a name="l00496"></a>00496     <span class="keywordflow">return</span> <a class="code" href="group__DBusMacros.html#gaa93f0eb578d23995850d61f7d61c55c1" title="Expands to &quot;0&quot;.">FALSE</a>;
<a name="l00497"></a>00497 
<a name="l00498"></a>00498   <span class="keywordflow">if</span> (!<a class="code" href="group__DBusString.html#ga3c10f0d1bcaa3b450025b9c6a8b901d7" title="Like _dbus_string_move(), but does not delete the section of the source string that&#39;s copied to the d...">_dbus_string_copy</a> (&amp;header-&gt;<a class="code" href="structDBusHeader.html#a67df8bff43c10e2d4f6ae36b56ee5814" title="Header network data, stored separately from body so we can independently realloc it.">data</a>, 0, &amp;dest-&gt;<a class="code" href="structDBusHeader.html#a67df8bff43c10e2d4f6ae36b56ee5814" title="Header network data, stored separately from body so we can independently realloc it.">data</a>, 0))
<a name="l00499"></a>00499     {
<a name="l00500"></a>00500       <a class="code" href="group__DBusString.html#ga781ca91acda49a834dce7d0ed0eef212" title="Frees a string created by _dbus_string_init().">_dbus_string_free</a> (&amp;dest-&gt;<a class="code" href="structDBusHeader.html#a67df8bff43c10e2d4f6ae36b56ee5814" title="Header network data, stored separately from body so we can independently realloc it.">data</a>);
<a name="l00501"></a>00501       <span class="keywordflow">return</span> <a class="code" href="group__DBusMacros.html#gaa93f0eb578d23995850d61f7d61c55c1" title="Expands to &quot;0&quot;.">FALSE</a>;
<a name="l00502"></a>00502     }
<a name="l00503"></a>00503 
<a name="l00504"></a>00504   <span class="comment">/* Reset the serial */</span>
<a name="l00505"></a>00505   <a class="code" href="group__DBusMarshal.html#gad92e0b1992cf96a4da642a4a54a5d26d" title="Sets the serial number of a header.">_dbus_header_set_serial</a> (dest, 0);
<a name="l00506"></a>00506 
<a name="l00507"></a>00507   <span class="keywordflow">return</span> <a class="code" href="group__DBusMacros.html#gaa8cecfc5c5c054d2875c03e77b7be15d" title="Expands to &quot;1&quot;.">TRUE</a>;
<a name="l00508"></a>00508 }
<a name="l00509"></a>00509 
<a name="l00525"></a>00525 <a class="code" href="group__DBusTypes.html#ga39c9cb0f3a2a8ad6f55cc4855d035349" title="A boolean, valid values are TRUE and FALSE.">dbus_bool_t</a>
<a name="l00526"></a><a class="code" href="group__DBusMarshal.html#gac7901e4196f10d4763df89b42d5db03e">00526</a> <a class="code" href="group__DBusMarshal.html#gac7901e4196f10d4763df89b42d5db03e" title="Fills in the primary fields of the header, so the header is ready for use.">_dbus_header_create</a> (<a class="code" href="structDBusHeader.html" title="Message header data and some cached details of it.">DBusHeader</a>  *header,
<a name="l00527"></a>00527                      <span class="keywordtype">int</span>          byte_order,
<a name="l00528"></a>00528                      <span class="keywordtype">int</span>          message_type,
<a name="l00529"></a>00529                      <span class="keyword">const</span> <span class="keywordtype">char</span>  *destination,
<a name="l00530"></a>00530                      <span class="keyword">const</span> <span class="keywordtype">char</span>  *path,
<a name="l00531"></a>00531                      <span class="keyword">const</span> <span class="keywordtype">char</span>  *interface,
<a name="l00532"></a>00532                      <span class="keyword">const</span> <span class="keywordtype">char</span>  *member,
<a name="l00533"></a>00533                      <span class="keyword">const</span> <span class="keywordtype">char</span>  *error_name)
<a name="l00534"></a>00534 {
<a name="l00535"></a>00535   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> v_BYTE;
<a name="l00536"></a>00536   dbus_uint32_t v_UINT32;
<a name="l00537"></a>00537   <a class="code" href="structDBusTypeWriter.html" title="The type writer is an iterator for writing to a block of values.">DBusTypeWriter</a> writer;
<a name="l00538"></a>00538   <a class="code" href="structDBusTypeWriter.html" title="The type writer is an iterator for writing to a block of values.">DBusTypeWriter</a> array;
<a name="l00539"></a>00539 
<a name="l00540"></a>00540   _dbus_assert (byte_order == <a class="code" href="group__DBusProtocol.html#gaae5e00bf9091a457e5bb3f9a75d982ca" title="Code marking LSB-first byte order in the wire protocol.">DBUS_LITTLE_ENDIAN</a> ||
<a name="l00541"></a>00541                 byte_order == <a class="code" href="group__DBusProtocol.html#gaed8596f854e755344dfbc811a73b0757" title="Code marking MSB-first byte order in the wire protocol.">DBUS_BIG_ENDIAN</a>);
<a name="l00542"></a>00542   _dbus_assert (((interface || message_type != <a class="code" href="group__DBusProtocol.html#ga728d893ff0c00e126517ba39835220a5" title="Message type of a signal message, see dbus_message_get_type()">DBUS_MESSAGE_TYPE_SIGNAL</a>) &amp;&amp; member) ||
<a name="l00543"></a>00543                 (error_name) ||
<a name="l00544"></a>00544                 !(interface || member || error_name));
<a name="l00545"></a>00545   _dbus_assert (_dbus_string_get_length (&amp;header-&gt;<a class="code" href="structDBusHeader.html#a67df8bff43c10e2d4f6ae36b56ee5814" title="Header network data, stored separately from body so we can independently realloc it.">data</a>) == 0);
<a name="l00546"></a>00546 
<a name="l00547"></a>00547   <span class="keywordflow">if</span> (!reserve_header_padding (header))
<a name="l00548"></a>00548     <span class="keywordflow">return</span> <a class="code" href="group__DBusMacros.html#gaa93f0eb578d23995850d61f7d61c55c1" title="Expands to &quot;0&quot;.">FALSE</a>;
<a name="l00549"></a>00549 
<a name="l00550"></a>00550   <a class="code" href="group__DBusMarshal.html#ga1f101175ce6f33221fcb59f0b46349bd" title="Like _dbus_type_writer_init(), except the type string passed in should correspond to an existing sign...">_dbus_type_writer_init_values_only</a> (&amp;writer, byte_order,
<a name="l00551"></a>00551                                       &amp;_dbus_header_signature_str, 0,
<a name="l00552"></a>00552                                       &amp;header-&gt;<a class="code" href="structDBusHeader.html#a67df8bff43c10e2d4f6ae36b56ee5814" title="Header network data, stored separately from body so we can independently realloc it.">data</a>,
<a name="l00553"></a>00553                                       <a class="code" href="group__DBusMarshal.html#gaef7e86e442aeb887c8bfe5559cd4eabb" title="Compute the end of the header, ignoring padding.">HEADER_END_BEFORE_PADDING</a> (header));
<a name="l00554"></a>00554 
<a name="l00555"></a>00555   v_BYTE = byte_order;
<a name="l00556"></a>00556   <span class="keywordflow">if</span> (!<a class="code" href="group__DBusMarshal.html#ga0103b0214766b0ff1ca05bcc7f1e631b" title="Writes out a basic type.">_dbus_type_writer_write_basic</a> (&amp;writer, <a class="code" href="group__DBusProtocol.html#ga355d6d0998164a5eb915a26fb67fce5f" title="Type code marking an 8-bit unsigned integer.">DBUS_TYPE_BYTE</a>,
<a name="l00557"></a>00557                                       &amp;v_BYTE))
<a name="l00558"></a>00558     <span class="keywordflow">goto</span> oom;
<a name="l00559"></a>00559 
<a name="l00560"></a>00560   v_BYTE = message_type;
<a name="l00561"></a>00561   <span class="keywordflow">if</span> (!<a class="code" href="group__DBusMarshal.html#ga0103b0214766b0ff1ca05bcc7f1e631b" title="Writes out a basic type.">_dbus_type_writer_write_basic</a> (&amp;writer, <a class="code" href="group__DBusProtocol.html#ga355d6d0998164a5eb915a26fb67fce5f" title="Type code marking an 8-bit unsigned integer.">DBUS_TYPE_BYTE</a>,
<a name="l00562"></a>00562                                       &amp;v_BYTE))
<a name="l00563"></a>00563     <span class="keywordflow">goto</span> oom;
<a name="l00564"></a>00564 
<a name="l00565"></a>00565   v_BYTE = 0; <span class="comment">/* flags */</span>
<a name="l00566"></a>00566   <span class="keywordflow">if</span> (!<a class="code" href="group__DBusMarshal.html#ga0103b0214766b0ff1ca05bcc7f1e631b" title="Writes out a basic type.">_dbus_type_writer_write_basic</a> (&amp;writer, <a class="code" href="group__DBusProtocol.html#ga355d6d0998164a5eb915a26fb67fce5f" title="Type code marking an 8-bit unsigned integer.">DBUS_TYPE_BYTE</a>,
<a name="l00567"></a>00567                                       &amp;v_BYTE))
<a name="l00568"></a>00568     <span class="keywordflow">goto</span> oom;
<a name="l00569"></a>00569 
<a name="l00570"></a>00570   v_BYTE = <a class="code" href="group__DBusProtocol.html#gae1ab70067a616d852e5fc264abb66608" title="Protocol version.">DBUS_MAJOR_PROTOCOL_VERSION</a>;
<a name="l00571"></a>00571   <span class="keywordflow">if</span> (!<a class="code" href="group__DBusMarshal.html#ga0103b0214766b0ff1ca05bcc7f1e631b" title="Writes out a basic type.">_dbus_type_writer_write_basic</a> (&amp;writer, <a class="code" href="group__DBusProtocol.html#ga355d6d0998164a5eb915a26fb67fce5f" title="Type code marking an 8-bit unsigned integer.">DBUS_TYPE_BYTE</a>,
<a name="l00572"></a>00572                                       &amp;v_BYTE))
<a name="l00573"></a>00573     <span class="keywordflow">goto</span> oom;
<a name="l00574"></a>00574 
<a name="l00575"></a>00575   v_UINT32 = 0; <span class="comment">/* body length */</span>
<a name="l00576"></a>00576   <span class="keywordflow">if</span> (!<a class="code" href="group__DBusMarshal.html#ga0103b0214766b0ff1ca05bcc7f1e631b" title="Writes out a basic type.">_dbus_type_writer_write_basic</a> (&amp;writer, <a class="code" href="group__DBusProtocol.html#gaedb1740bd8a9174b98ac593eded25d49" title="Type code marking a 32-bit unsigned integer.">DBUS_TYPE_UINT32</a>,
<a name="l00577"></a>00577                                       &amp;v_UINT32))
<a name="l00578"></a>00578     <span class="keywordflow">goto</span> oom;
<a name="l00579"></a>00579 
<a name="l00580"></a>00580   v_UINT32 = 0; <span class="comment">/* serial */</span>
<a name="l00581"></a>00581   <span class="keywordflow">if</span> (!<a class="code" href="group__DBusMarshal.html#ga0103b0214766b0ff1ca05bcc7f1e631b" title="Writes out a basic type.">_dbus_type_writer_write_basic</a> (&amp;writer, <a class="code" href="group__DBusProtocol.html#gaedb1740bd8a9174b98ac593eded25d49" title="Type code marking a 32-bit unsigned integer.">DBUS_TYPE_UINT32</a>,
<a name="l00582"></a>00582                                       &amp;v_UINT32))
<a name="l00583"></a>00583     <span class="keywordflow">goto</span> oom;
<a name="l00584"></a>00584 
<a name="l00585"></a>00585   <span class="keywordflow">if</span> (!<a class="code" href="group__DBusMarshal.html#ga4c0a1036e59dac270141052d951baff2" title="Opens a new container and writes out the initial information for that container.">_dbus_type_writer_recurse</a> (&amp;writer, <a class="code" href="group__DBusProtocol.html#ga8912f600f81a773066ca03d9163613a9" title="Type code marking a D-Bus array type.">DBUS_TYPE_ARRAY</a>,
<a name="l00586"></a>00586                                   &amp;_dbus_header_signature_str,
<a name="l00587"></a>00587                                   <a class="code" href="group__DBusMarshal.html#ga935ea6d7c6bb72a10c670f5ef3e34d49" title="Offset from start of _dbus_header_signature_str to the signature of the fields array.">FIELDS_ARRAY_SIGNATURE_OFFSET</a>,
<a name="l00588"></a>00588                                   &amp;array))
<a name="l00589"></a>00589     <span class="keywordflow">goto</span> oom;
<a name="l00590"></a>00590 
<a name="l00591"></a>00591   <span class="comment">/* Marshal all the fields (Marshall Fields?) */</span>
<a name="l00592"></a>00592 
<a name="l00593"></a>00593   <span class="keywordflow">if</span> (path != <a class="code" href="group__DBusMacros.html#ga070d2ce7b6bb7e5c05602aa8c308d0c4" title="A null pointer, defined appropriately for C or C++.">NULL</a>)
<a name="l00594"></a>00594     {
<a name="l00595"></a>00595       <span class="keywordflow">if</span> (!write_basic_field (&amp;array,
<a name="l00596"></a>00596                               <a class="code" href="group__DBusProtocol.html#ga0cd885e6e808b28ff082a7f8a2c9f579" title="Header field code for the path - the path is the object emitting a signal or the object receiving a m...">DBUS_HEADER_FIELD_PATH</a>,
<a name="l00597"></a>00597                               <a class="code" href="group__DBusProtocol.html#ga31cc59c99a6cbbfcef71756e1390dc4c" title="Type code marking a D-Bus object path.">DBUS_TYPE_OBJECT_PATH</a>,
<a name="l00598"></a>00598                               &amp;path))
<a name="l00599"></a>00599         <span class="keywordflow">goto</span> oom;
<a name="l00600"></a>00600     }
<a name="l00601"></a>00601 
<a name="l00602"></a>00602   <span class="keywordflow">if</span> (destination != <a class="code" href="group__DBusMacros.html#ga070d2ce7b6bb7e5c05602aa8c308d0c4" title="A null pointer, defined appropriately for C or C++.">NULL</a>)
<a name="l00603"></a>00603     {
<a name="l00604"></a>00604       <span class="keywordflow">if</span> (!write_basic_field (&amp;array,
<a name="l00605"></a>00605                               <a class="code" href="group__DBusProtocol.html#gade98f71a08a1e0198d095fdb6d46cab9" title="Header field code for the destination bus name of a message.">DBUS_HEADER_FIELD_DESTINATION</a>,
<a name="l00606"></a>00606                               <a class="code" href="group__DBusProtocol.html#ga7eb77066dadf5415896b44c56d93acce" title="Type code marking a UTF-8 encoded, nul-terminated Unicode string.">DBUS_TYPE_STRING</a>,
<a name="l00607"></a>00607                               &amp;destination))
<a name="l00608"></a>00608         <span class="keywordflow">goto</span> oom;
<a name="l00609"></a>00609     }
<a name="l00610"></a>00610 
<a name="l00611"></a>00611   <span class="keywordflow">if</span> (interface != <a class="code" href="group__DBusMacros.html#ga070d2ce7b6bb7e5c05602aa8c308d0c4" title="A null pointer, defined appropriately for C or C++.">NULL</a>)
<a name="l00612"></a>00612     {
<a name="l00613"></a>00613       <span class="keywordflow">if</span> (!write_basic_field (&amp;array,
<a name="l00614"></a>00614                               <a class="code" href="group__DBusProtocol.html#ga296b5f099b6c347f65d53ef0a6fa2b0d" title="Header field code for the interface containing a member (method or signal).">DBUS_HEADER_FIELD_INTERFACE</a>,
<a name="l00615"></a>00615                               <a class="code" href="group__DBusProtocol.html#ga7eb77066dadf5415896b44c56d93acce" title="Type code marking a UTF-8 encoded, nul-terminated Unicode string.">DBUS_TYPE_STRING</a>,
<a name="l00616"></a>00616                               &amp;interface))
<a name="l00617"></a>00617         <span class="keywordflow">goto</span> oom;
<a name="l00618"></a>00618     }
<a name="l00619"></a>00619 
<a name="l00620"></a>00620   <span class="keywordflow">if</span> (member != <a class="code" href="group__DBusMacros.html#ga070d2ce7b6bb7e5c05602aa8c308d0c4" title="A null pointer, defined appropriately for C or C++.">NULL</a>)
<a name="l00621"></a>00621     {
<a name="l00622"></a>00622       <span class="keywordflow">if</span> (!write_basic_field (&amp;array,
<a name="l00623"></a>00623                               <a class="code" href="group__DBusProtocol.html#ga2aa9d65ef983ac9c08c1d4cb31366818" title="Header field code for a member (method or signal).">DBUS_HEADER_FIELD_MEMBER</a>,
<a name="l00624"></a>00624                               <a class="code" href="group__DBusProtocol.html#ga7eb77066dadf5415896b44c56d93acce" title="Type code marking a UTF-8 encoded, nul-terminated Unicode string.">DBUS_TYPE_STRING</a>,
<a name="l00625"></a>00625                               &amp;member))
<a name="l00626"></a>00626         <span class="keywordflow">goto</span> oom;
<a name="l00627"></a>00627     }
<a name="l00628"></a>00628 
<a name="l00629"></a>00629   <span class="keywordflow">if</span> (error_name != <a class="code" href="group__DBusMacros.html#ga070d2ce7b6bb7e5c05602aa8c308d0c4" title="A null pointer, defined appropriately for C or C++.">NULL</a>)
<a name="l00630"></a>00630     {
<a name="l00631"></a>00631       <span class="keywordflow">if</span> (!write_basic_field (&amp;array,
<a name="l00632"></a>00632                               <a class="code" href="group__DBusProtocol.html#gac551be0f921390d01104cce30a814a5e" title="Header field code for an error name (found in DBUS_MESSAGE_TYPE_ERROR messages).">DBUS_HEADER_FIELD_ERROR_NAME</a>,
<a name="l00633"></a>00633                               <a class="code" href="group__DBusProtocol.html#ga7eb77066dadf5415896b44c56d93acce" title="Type code marking a UTF-8 encoded, nul-terminated Unicode string.">DBUS_TYPE_STRING</a>,
<a name="l00634"></a>00634                               &amp;error_name))
<a name="l00635"></a>00635         <span class="keywordflow">goto</span> oom;
<a name="l00636"></a>00636     }
<a name="l00637"></a>00637 
<a name="l00638"></a>00638   <span class="keywordflow">if</span> (!<a class="code" href="group__DBusMarshal.html#gacbe7eddf4f9c19da91b742087fcc111a" title="Closes a container created by _dbus_type_writer_recurse() and writes any additional information to th...">_dbus_type_writer_unrecurse</a> (&amp;writer, &amp;array))
<a name="l00639"></a>00639     <span class="keywordflow">goto</span> oom;
<a name="l00640"></a>00640 
<a name="l00641"></a>00641   correct_header_padding (header);
<a name="l00642"></a>00642 
<a name="l00643"></a>00643   <span class="keywordflow">return</span> <a class="code" href="group__DBusMacros.html#gaa8cecfc5c5c054d2875c03e77b7be15d" title="Expands to &quot;1&quot;.">TRUE</a>;
<a name="l00644"></a>00644 
<a name="l00645"></a>00645  oom:
<a name="l00646"></a>00646   <a class="code" href="group__DBusString.html#ga7e0e164ad5bb094e5ccad9edc7ae4235" title="Deletes a segment of a DBusString with length len starting at start.">_dbus_string_delete</a> (&amp;header-&gt;<a class="code" href="structDBusHeader.html#a67df8bff43c10e2d4f6ae36b56ee5814" title="Header network data, stored separately from body so we can independently realloc it.">data</a>, 0,
<a name="l00647"></a>00647                        _dbus_string_get_length (&amp;header-&gt;<a class="code" href="structDBusHeader.html#a67df8bff43c10e2d4f6ae36b56ee5814" title="Header network data, stored separately from body so we can independently realloc it.">data</a>) - header-&gt;<a class="code" href="structDBusHeader.html#aa22a8d00f061310e12716f656b4d9b8f" title="bytes of alignment in header">padding</a>);
<a name="l00648"></a>00648   correct_header_padding (header);
<a name="l00649"></a>00649 
<a name="l00650"></a>00650   <span class="keywordflow">return</span> <a class="code" href="group__DBusMacros.html#gaa93f0eb578d23995850d61f7d61c55c1" title="Expands to &quot;0&quot;.">FALSE</a>;
<a name="l00651"></a>00651 }
<a name="l00652"></a>00652 
<a name="l00670"></a>00670 <a class="code" href="group__DBusTypes.html#ga39c9cb0f3a2a8ad6f55cc4855d035349" title="A boolean, valid values are TRUE and FALSE.">dbus_bool_t</a>
<a name="l00671"></a><a class="code" href="group__DBusMarshal.html#ga674d74081baf6e7531e0d4a286724210">00671</a> <a class="code" href="group__DBusMarshal.html#ga674d74081baf6e7531e0d4a286724210" title="Given data long enough to contain the length of the message body and the fields array, check whether the data is long enough to contain the entire message (assuming the claimed lengths are accurate).">_dbus_header_have_message_untrusted</a> (<span class="keywordtype">int</span>                max_message_length,
<a name="l00672"></a>00672                                      <a class="code" href="group__DBusMarshal.html#ga0c4521d30d6650a33673a4d7f9cc007c" title="This is primarily used in unit testing, so we can verify that each invalid message is invalid for the...">DBusValidity</a>      *validity,
<a name="l00673"></a>00673                                      <span class="keywordtype">int</span>               *byte_order,
<a name="l00674"></a>00674                                      <span class="keywordtype">int</span>               *fields_array_len,
<a name="l00675"></a>00675                                      <span class="keywordtype">int</span>               *header_len,
<a name="l00676"></a>00676                                      <span class="keywordtype">int</span>               *body_len,
<a name="l00677"></a>00677                                      <span class="keyword">const</span> <a class="code" href="structDBusString.html">DBusString</a>  *str,
<a name="l00678"></a>00678                                      <span class="keywordtype">int</span>                start,
<a name="l00679"></a>00679                                      <span class="keywordtype">int</span>                len)
<a name="l00680"></a>00680 
<a name="l00681"></a>00681 {
<a name="l00682"></a>00682   dbus_uint32_t header_len_unsigned;
<a name="l00683"></a>00683   dbus_uint32_t fields_array_len_unsigned;
<a name="l00684"></a>00684   dbus_uint32_t body_len_unsigned;
<a name="l00685"></a>00685 
<a name="l00686"></a>00686   _dbus_assert (start &gt;= 0);
<a name="l00687"></a>00687   _dbus_assert (start &lt; _DBUS_INT32_MAX / 2);
<a name="l00688"></a>00688   _dbus_assert (len &gt;= 0);
<a name="l00689"></a>00689 
<a name="l00690"></a>00690   _dbus_assert (start == (<span class="keywordtype">int</span>) _DBUS_ALIGN_VALUE (start, 8));
<a name="l00691"></a>00691 
<a name="l00692"></a>00692   *byte_order = _dbus_string_get_byte (str, start + <a class="code" href="group__DBusMarshal.html#gaa5b7e77f37761139698892e4b8aad029" title="Offset to byte order from start of header.">BYTE_ORDER_OFFSET</a>);
<a name="l00693"></a>00693 
<a name="l00694"></a>00694   <span class="keywordflow">if</span> (*byte_order != <a class="code" href="group__DBusProtocol.html#gaae5e00bf9091a457e5bb3f9a75d982ca" title="Code marking LSB-first byte order in the wire protocol.">DBUS_LITTLE_ENDIAN</a> &amp;&amp; *byte_order != <a class="code" href="group__DBusProtocol.html#gaed8596f854e755344dfbc811a73b0757" title="Code marking MSB-first byte order in the wire protocol.">DBUS_BIG_ENDIAN</a>)
<a name="l00695"></a>00695     {
<a name="l00696"></a>00696       *validity = DBUS_INVALID_BAD_BYTE_ORDER;
<a name="l00697"></a>00697       <span class="keywordflow">return</span> <a class="code" href="group__DBusMacros.html#gaa93f0eb578d23995850d61f7d61c55c1" title="Expands to &quot;0&quot;.">FALSE</a>;
<a name="l00698"></a>00698     }
<a name="l00699"></a>00699 
<a name="l00700"></a>00700   _dbus_assert (<a class="code" href="group__DBusMarshal.html#gae9759e0de1d8a650f37632c3dc22427e" title="Offset to fields array length from start of header.">FIELDS_ARRAY_LENGTH_OFFSET</a> + 4 &lt;= len);
<a name="l00701"></a>00701   fields_array_len_unsigned = <a class="code" href="group__DBusMarshal.html#ga6dd82a202c19758cbf76dbed2946615d" title="Convenience function to demarshal a 32 bit unsigned integer.">_dbus_marshal_read_uint32</a> (str, start + <a class="code" href="group__DBusMarshal.html#gae9759e0de1d8a650f37632c3dc22427e" title="Offset to fields array length from start of header.">FIELDS_ARRAY_LENGTH_OFFSET</a>,
<a name="l00702"></a>00702                                                          *byte_order, <a class="code" href="group__DBusMacros.html#ga070d2ce7b6bb7e5c05602aa8c308d0c4" title="A null pointer, defined appropriately for C or C++.">NULL</a>);
<a name="l00703"></a>00703 
<a name="l00704"></a>00704   <span class="keywordflow">if</span> (fields_array_len_unsigned &gt; (<span class="keywordtype">unsigned</span>) max_message_length)
<a name="l00705"></a>00705     {
<a name="l00706"></a>00706       *validity = DBUS_INVALID_INSANE_FIELDS_ARRAY_LENGTH;
<a name="l00707"></a>00707       <span class="keywordflow">return</span> <a class="code" href="group__DBusMacros.html#gaa93f0eb578d23995850d61f7d61c55c1" title="Expands to &quot;0&quot;.">FALSE</a>;
<a name="l00708"></a>00708     }
<a name="l00709"></a>00709 
<a name="l00710"></a>00710   _dbus_assert (<a class="code" href="group__DBusMarshal.html#ga190a2d89e79c9d76fcba4f06ec8b5b5c" title="Offset to body length from start of header.">BODY_LENGTH_OFFSET</a> + 4 &lt; len);
<a name="l00711"></a>00711   body_len_unsigned = <a class="code" href="group__DBusMarshal.html#ga6dd82a202c19758cbf76dbed2946615d" title="Convenience function to demarshal a 32 bit unsigned integer.">_dbus_marshal_read_uint32</a> (str, start + <a class="code" href="group__DBusMarshal.html#ga190a2d89e79c9d76fcba4f06ec8b5b5c" title="Offset to body length from start of header.">BODY_LENGTH_OFFSET</a>,
<a name="l00712"></a>00712                                                  *byte_order, <a class="code" href="group__DBusMacros.html#ga070d2ce7b6bb7e5c05602aa8c308d0c4" title="A null pointer, defined appropriately for C or C++.">NULL</a>);
<a name="l00713"></a>00713 
<a name="l00714"></a>00714   <span class="keywordflow">if</span> (body_len_unsigned &gt; (<span class="keywordtype">unsigned</span>) max_message_length)
<a name="l00715"></a>00715     {
<a name="l00716"></a>00716       *validity = DBUS_INVALID_INSANE_BODY_LENGTH;
<a name="l00717"></a>00717       <span class="keywordflow">return</span> <a class="code" href="group__DBusMacros.html#gaa93f0eb578d23995850d61f7d61c55c1" title="Expands to &quot;0&quot;.">FALSE</a>;
<a name="l00718"></a>00718     }
<a name="l00719"></a>00719 
<a name="l00720"></a>00720   header_len_unsigned = <a class="code" href="group__DBusMarshal.html#gaaa085e57f49f527ef210e842be999929" title="Offset to first field in header.">FIRST_FIELD_OFFSET</a> + fields_array_len_unsigned;
<a name="l00721"></a>00721   header_len_unsigned = _DBUS_ALIGN_VALUE (header_len_unsigned, 8);
<a name="l00722"></a>00722 
<a name="l00723"></a>00723   <span class="comment">/* overflow should be impossible since the lengths aren&#39;t allowed to</span>
<a name="l00724"></a>00724 <span class="comment">   * be huge.</span>
<a name="l00725"></a>00725 <span class="comment">   */</span>
<a name="l00726"></a>00726   _dbus_assert (max_message_length &lt; _DBUS_INT32_MAX / 2);
<a name="l00727"></a>00727   <span class="keywordflow">if</span> (body_len_unsigned + header_len_unsigned &gt; (<span class="keywordtype">unsigned</span>) max_message_length)
<a name="l00728"></a>00728     {
<a name="l00729"></a>00729       *validity = DBUS_INVALID_MESSAGE_TOO_LONG;
<a name="l00730"></a>00730       <span class="keywordflow">return</span> <a class="code" href="group__DBusMacros.html#gaa93f0eb578d23995850d61f7d61c55c1" title="Expands to &quot;0&quot;.">FALSE</a>;
<a name="l00731"></a>00731     }
<a name="l00732"></a>00732 
<a name="l00733"></a>00733   _dbus_assert (body_len_unsigned &lt; (<span class="keywordtype">unsigned</span>) _DBUS_INT32_MAX);
<a name="l00734"></a>00734   _dbus_assert (fields_array_len_unsigned &lt; (<span class="keywordtype">unsigned</span>) _DBUS_INT32_MAX);
<a name="l00735"></a>00735   _dbus_assert (header_len_unsigned &lt; (<span class="keywordtype">unsigned</span>) _DBUS_INT32_MAX);
<a name="l00736"></a>00736 
<a name="l00737"></a>00737   *body_len = body_len_unsigned;
<a name="l00738"></a>00738   *fields_array_len = fields_array_len_unsigned;
<a name="l00739"></a>00739   *header_len = header_len_unsigned;
<a name="l00740"></a>00740 
<a name="l00741"></a>00741   *validity = DBUS_VALID;
<a name="l00742"></a>00742 
<a name="l00743"></a>00743   _dbus_verbose (<span class="stringliteral">&quot;have %d bytes, need body %u + header %u = %u\n&quot;</span>,
<a name="l00744"></a>00744                  len, body_len_unsigned, header_len_unsigned,
<a name="l00745"></a>00745                  body_len_unsigned + header_len_unsigned);
<a name="l00746"></a>00746 
<a name="l00747"></a>00747   <span class="keywordflow">return</span> (body_len_unsigned + header_len_unsigned) &lt;= (unsigned) len;
<a name="l00748"></a>00748 }
<a name="l00749"></a>00749 
<a name="l00750"></a>00750 <span class="keyword">static</span> <a class="code" href="group__DBusMarshal.html#ga0c4521d30d6650a33673a4d7f9cc007c" title="This is primarily used in unit testing, so we can verify that each invalid message is invalid for the...">DBusValidity</a>
<a name="l00751"></a>00751 check_mandatory_fields (<a class="code" href="structDBusHeader.html" title="Message header data and some cached details of it.">DBusHeader</a> *header)
<a name="l00752"></a>00752 {
<a name="l00753"></a>00753 <span class="preprocessor">#define REQUIRE_FIELD(name) do { if (header-&gt;fields[DBUS_HEADER_FIELD_##name].value_pos &lt; 0) return DBUS_INVALID_MISSING_##name; } while (0)</span>
<a name="l00754"></a>00754 <span class="preprocessor"></span>
<a name="l00755"></a>00755   <span class="keywordflow">switch</span> (<a class="code" href="group__DBusMarshal.html#ga4427247494fc5c988498c5a87d42092d" title="Gets the type of the message.">_dbus_header_get_message_type</a> (header))
<a name="l00756"></a>00756     {
<a name="l00757"></a>00757     <span class="keywordflow">case</span> <a class="code" href="group__DBusProtocol.html#ga728d893ff0c00e126517ba39835220a5" title="Message type of a signal message, see dbus_message_get_type()">DBUS_MESSAGE_TYPE_SIGNAL</a>:
<a name="l00758"></a>00758       REQUIRE_FIELD (INTERFACE);
<a name="l00759"></a>00759       <span class="comment">/* FALL THRU - signals also require the path and member */</span>
<a name="l00760"></a>00760     <span class="keywordflow">case</span> <a class="code" href="group__DBusProtocol.html#ga09416afd76b65139eddd31e1085d9ebf" title="Message type of a method call message, see dbus_message_get_type()">DBUS_MESSAGE_TYPE_METHOD_CALL</a>:
<a name="l00761"></a>00761       REQUIRE_FIELD (PATH);
<a name="l00762"></a>00762       REQUIRE_FIELD (MEMBER);
<a name="l00763"></a>00763       <span class="keywordflow">break</span>;
<a name="l00764"></a>00764     <span class="keywordflow">case</span> <a class="code" href="group__DBusProtocol.html#ga2b9423d95066313d73eeea8eeaf86812" title="Message type of an error reply message, see dbus_message_get_type()">DBUS_MESSAGE_TYPE_ERROR</a>:
<a name="l00765"></a>00765       REQUIRE_FIELD (ERROR_NAME);
<a name="l00766"></a>00766       REQUIRE_FIELD (REPLY_SERIAL);
<a name="l00767"></a>00767       <span class="keywordflow">break</span>;
<a name="l00768"></a>00768     <span class="keywordflow">case</span> <a class="code" href="group__DBusProtocol.html#ga4a9012edd7f22342f845e98150aeb858" title="Message type of a method return message, see dbus_message_get_type()">DBUS_MESSAGE_TYPE_METHOD_RETURN</a>:
<a name="l00769"></a>00769       REQUIRE_FIELD (REPLY_SERIAL);
<a name="l00770"></a>00770       <span class="keywordflow">break</span>;
<a name="l00771"></a>00771     <span class="keywordflow">default</span>:
<a name="l00772"></a>00772       <span class="comment">/* other message types allowed but ignored */</span>
<a name="l00773"></a>00773       <span class="keywordflow">break</span>;
<a name="l00774"></a>00774     }
<a name="l00775"></a>00775 
<a name="l00776"></a>00776   <span class="keywordflow">return</span> DBUS_VALID;
<a name="l00777"></a>00777 }
<a name="l00778"></a>00778 
<a name="l00779"></a>00779 <span class="keyword">static</span> <a class="code" href="group__DBusMarshal.html#ga0c4521d30d6650a33673a4d7f9cc007c" title="This is primarily used in unit testing, so we can verify that each invalid message is invalid for the...">DBusValidity</a>
<a name="l00780"></a>00780 load_and_validate_field (<a class="code" href="structDBusHeader.html" title="Message header data and some cached details of it.">DBusHeader</a>     *header,
<a name="l00781"></a>00781                          <span class="keywordtype">int</span>             field,
<a name="l00782"></a>00782                          <a class="code" href="structDBusTypeReader.html" title="The type reader is an iterator for reading values from a block of values.">DBusTypeReader</a> *variant_reader)
<a name="l00783"></a>00783 {
<a name="l00784"></a>00784   <span class="keywordtype">int</span> type;
<a name="l00785"></a>00785   <span class="keywordtype">int</span> expected_type;
<a name="l00786"></a>00786   <span class="keyword">const</span> <a class="code" href="structDBusString.html">DBusString</a> *value_str;
<a name="l00787"></a>00787   <span class="keywordtype">int</span> value_pos;
<a name="l00788"></a>00788   <span class="keywordtype">int</span> str_data_pos;
<a name="l00789"></a>00789   dbus_uint32_t v_UINT32;
<a name="l00790"></a>00790   <span class="keywordtype">int</span> bad_string_code;
<a name="l00791"></a>00791   <a class="code" href="group__DBusTypes.html#ga39c9cb0f3a2a8ad6f55cc4855d035349" title="A boolean, valid values are TRUE and FALSE.">dbus_bool_t</a> (* string_validation_func) (<span class="keyword">const</span> <a class="code" href="structDBusString.html">DBusString</a> *str,
<a name="l00792"></a>00792                                           <span class="keywordtype">int</span> start, <span class="keywordtype">int</span> len);
<a name="l00793"></a>00793 
<a name="l00794"></a>00794   <span class="comment">/* Supposed to have been checked already */</span>
<a name="l00795"></a>00795   _dbus_assert (field &lt;= <a class="code" href="group__DBusProtocol.html#ga94f09d2b35473c8ffa6d3190b5f97c5c" title="Value of the highest-numbered header field code, can be used to determine the size of an array indexe...">DBUS_HEADER_FIELD_LAST</a>);
<a name="l00796"></a>00796   _dbus_assert (field != <a class="code" href="group__DBusProtocol.html#ga075b0efc570129393d3fb653ce4bbd76" title="Not equal to any valid header field code.">DBUS_HEADER_FIELD_INVALID</a>);
<a name="l00797"></a>00797 
<a name="l00798"></a>00798   <span class="comment">/* Before we can cache a field, we need to know it has the right type */</span>
<a name="l00799"></a>00799   type = <a class="code" href="group__DBusMarshal.html#gab8e39cb8084247d54d7f272c51622a73" title="Gets the type of the value the reader is currently pointing to; or for a types-only reader gets the t...">_dbus_type_reader_get_current_type</a> (variant_reader);
<a name="l00800"></a>00800 
<a name="l00801"></a>00801   _dbus_assert (_dbus_header_field_types[field].code == field);
<a name="l00802"></a>00802 
<a name="l00803"></a>00803   expected_type = <a class="code" href="group__DBusMarshal.html#ga37be3d294f5be31c95bc7620e451b0b2" title="Macro to look up the correct type for a field.">EXPECTED_TYPE_OF_FIELD</a> (field);
<a name="l00804"></a>00804   <span class="keywordflow">if</span> (type != expected_type)
<a name="l00805"></a>00805     {
<a name="l00806"></a>00806       _dbus_verbose (<span class="stringliteral">&quot;Field %d should have type %d but has %d\n&quot;</span>,
<a name="l00807"></a>00807                      field, expected_type, type);
<a name="l00808"></a>00808       <span class="keywordflow">return</span> DBUS_INVALID_HEADER_FIELD_HAS_WRONG_TYPE;
<a name="l00809"></a>00809     }
<a name="l00810"></a>00810 
<a name="l00811"></a>00811   <span class="comment">/* If the field was provided twice, we aren&#39;t happy */</span>
<a name="l00812"></a>00812   <span class="keywordflow">if</span> (header-&gt;<a class="code" href="structDBusHeader.html#ac58a309593d0dc7e8d5a02f3b3442384" title="Track the location of each field in header.">fields</a>[field].<a class="code" href="structDBusHeaderField.html#aa9616d127de7488f6d9dc18c4d0c2133" title="Position of field value, or -1/-2.">value_pos</a> &gt;= 0)
<a name="l00813"></a>00813     {
<a name="l00814"></a>00814       _dbus_verbose (<span class="stringliteral">&quot;Header field %d seen a second time\n&quot;</span>, field);
<a name="l00815"></a>00815       <span class="keywordflow">return</span> DBUS_INVALID_HEADER_FIELD_APPEARS_TWICE;
<a name="l00816"></a>00816     }
<a name="l00817"></a>00817 
<a name="l00818"></a>00818   <span class="comment">/* Now we can cache and look at the field content */</span>
<a name="l00819"></a>00819   _dbus_verbose (<span class="stringliteral">&quot;initially caching field %d\n&quot;</span>, field);
<a name="l00820"></a>00820   _dbus_header_cache_one (header, field, variant_reader);
<a name="l00821"></a>00821 
<a name="l00822"></a>00822   string_validation_func = <a class="code" href="group__DBusMacros.html#ga070d2ce7b6bb7e5c05602aa8c308d0c4" title="A null pointer, defined appropriately for C or C++.">NULL</a>;
<a name="l00823"></a>00823 
<a name="l00824"></a>00824   <span class="comment">/* make compiler happy that all this is initialized */</span>
<a name="l00825"></a>00825   v_UINT32 = 0;
<a name="l00826"></a>00826   value_str = <a class="code" href="group__DBusMacros.html#ga070d2ce7b6bb7e5c05602aa8c308d0c4" title="A null pointer, defined appropriately for C or C++.">NULL</a>;
<a name="l00827"></a>00827   value_pos = -1;
<a name="l00828"></a>00828   str_data_pos = -1;
<a name="l00829"></a>00829   bad_string_code = DBUS_VALID;
<a name="l00830"></a>00830 
<a name="l00831"></a>00831   <span class="keywordflow">if</span> (expected_type == <a class="code" href="group__DBusProtocol.html#gaedb1740bd8a9174b98ac593eded25d49" title="Type code marking a 32-bit unsigned integer.">DBUS_TYPE_UINT32</a>)
<a name="l00832"></a>00832     {
<a name="l00833"></a>00833       <a class="code" href="group__DBusMarshal.html#ga499973a18dcb17d854eaf14101a66736" title="Gets the value of a field with basic type.">_dbus_header_get_field_basic</a> (header, field, expected_type,
<a name="l00834"></a>00834                                     &amp;v_UINT32);
<a name="l00835"></a>00835     }
<a name="l00836"></a>00836   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (expected_type == <a class="code" href="group__DBusProtocol.html#ga7eb77066dadf5415896b44c56d93acce" title="Type code marking a UTF-8 encoded, nul-terminated Unicode string.">DBUS_TYPE_STRING</a> ||
<a name="l00837"></a>00837            expected_type == <a class="code" href="group__DBusProtocol.html#ga31cc59c99a6cbbfcef71756e1390dc4c" title="Type code marking a D-Bus object path.">DBUS_TYPE_OBJECT_PATH</a> ||
<a name="l00838"></a>00838            expected_type == <a class="code" href="group__DBusProtocol.html#ga26ed6c20c3d9f0b50ea0a1cf80be3279" title="Type code marking a D-Bus type signature.">DBUS_TYPE_SIGNATURE</a>)
<a name="l00839"></a>00839     {
<a name="l00840"></a>00840       <a class="code" href="group__DBusMarshal.html#gaf4661ba8e7067f349ba03c9f5776bbb0" title="Gets the raw marshaled data for a field.">_dbus_header_get_field_raw</a> (header, field,
<a name="l00841"></a>00841                                   &amp;value_str, &amp;value_pos);
<a name="l00842"></a>00842       str_data_pos = _DBUS_ALIGN_VALUE (value_pos, 4) + 4;
<a name="l00843"></a>00843     }
<a name="l00844"></a>00844   <span class="keywordflow">else</span>
<a name="l00845"></a>00845     {
<a name="l00846"></a>00846       _dbus_assert_not_reached (<span class="stringliteral">&quot;none of the known fields should have this type&quot;</span>);
<a name="l00847"></a>00847     }
<a name="l00848"></a>00848 
<a name="l00849"></a>00849   <span class="keywordflow">switch</span> (field)
<a name="l00850"></a>00850     {
<a name="l00851"></a>00851     <span class="keywordflow">case</span> <a class="code" href="group__DBusProtocol.html#gade98f71a08a1e0198d095fdb6d46cab9" title="Header field code for the destination bus name of a message.">DBUS_HEADER_FIELD_DESTINATION</a>:
<a name="l00852"></a>00852       string_validation_func = <a class="code" href="group__DBusMarshal.html#gaab91a04fa2a96b8ce8843beae7327cd0" title="Checks that the given range of the string is a valid bus name in the D-Bus protocol.">_dbus_validate_bus_name</a>;
<a name="l00853"></a>00853       bad_string_code = DBUS_INVALID_BAD_DESTINATION;
<a name="l00854"></a>00854       <span class="keywordflow">break</span>;
<a name="l00855"></a>00855     <span class="keywordflow">case</span> <a class="code" href="group__DBusProtocol.html#ga296b5f099b6c347f65d53ef0a6fa2b0d" title="Header field code for the interface containing a member (method or signal).">DBUS_HEADER_FIELD_INTERFACE</a>:
<a name="l00856"></a>00856       string_validation_func = <a class="code" href="group__DBusMarshal.html#ga0ad919783f887a9b6f428e262beaeed9" title="Checks that the given range of the string is a valid interface name in the D-Bus protocol.">_dbus_validate_interface</a>;
<a name="l00857"></a>00857       bad_string_code = DBUS_INVALID_BAD_INTERFACE;
<a name="l00858"></a>00858 
<a name="l00859"></a>00859       <span class="keywordflow">if</span> (<a class="code" href="group__DBusString.html#ga2095c2a797ae245521a7588b32279110" title="Tests two sub-parts of two DBusString for equality.">_dbus_string_equal_substring</a> (&amp;_dbus_local_interface_str,
<a name="l00860"></a>00860                                         0,
<a name="l00861"></a>00861                                         _dbus_string_get_length (&amp;_dbus_local_interface_str),
<a name="l00862"></a>00862                                         value_str, str_data_pos))
<a name="l00863"></a>00863         {
<a name="l00864"></a>00864           _dbus_verbose (<span class="stringliteral">&quot;Message is on the local interface\n&quot;</span>);
<a name="l00865"></a>00865           <span class="keywordflow">return</span> DBUS_INVALID_USES_LOCAL_INTERFACE;
<a name="l00866"></a>00866         }
<a name="l00867"></a>00867       <span class="keywordflow">break</span>;
<a name="l00868"></a>00868 
<a name="l00869"></a>00869     <span class="keywordflow">case</span> <a class="code" href="group__DBusProtocol.html#ga2aa9d65ef983ac9c08c1d4cb31366818" title="Header field code for a member (method or signal).">DBUS_HEADER_FIELD_MEMBER</a>:
<a name="l00870"></a>00870       string_validation_func = <a class="code" href="group__DBusMarshal.html#gaf647272768029cb23a4e0d3f493587da" title="Checks that the given range of the string is a valid member name in the D-Bus protocol.">_dbus_validate_member</a>;
<a name="l00871"></a>00871       bad_string_code = DBUS_INVALID_BAD_MEMBER;
<a name="l00872"></a>00872       <span class="keywordflow">break</span>;
<a name="l00873"></a>00873 
<a name="l00874"></a>00874     <span class="keywordflow">case</span> <a class="code" href="group__DBusProtocol.html#gac551be0f921390d01104cce30a814a5e" title="Header field code for an error name (found in DBUS_MESSAGE_TYPE_ERROR messages).">DBUS_HEADER_FIELD_ERROR_NAME</a>:
<a name="l00875"></a>00875       string_validation_func = <a class="code" href="group__DBusMarshal.html#ga6d8075f3b60e2e71aad061aa44b120fe" title="Checks that the given range of the string is a valid error name in the D-Bus protocol.">_dbus_validate_error_name</a>;
<a name="l00876"></a>00876       bad_string_code = DBUS_INVALID_BAD_ERROR_NAME;
<a name="l00877"></a>00877       <span class="keywordflow">break</span>;
<a name="l00878"></a>00878 
<a name="l00879"></a>00879     <span class="keywordflow">case</span> <a class="code" href="group__DBusProtocol.html#ga3ba84ae623951832bd73e2796bb13e71" title="Header field code for the sender of a message; usually initialized by the message bus...">DBUS_HEADER_FIELD_SENDER</a>:
<a name="l00880"></a>00880       string_validation_func = <a class="code" href="group__DBusMarshal.html#gaab91a04fa2a96b8ce8843beae7327cd0" title="Checks that the given range of the string is a valid bus name in the D-Bus protocol.">_dbus_validate_bus_name</a>;
<a name="l00881"></a>00881       bad_string_code = DBUS_INVALID_BAD_SENDER;
<a name="l00882"></a>00882       <span class="keywordflow">break</span>;
<a name="l00883"></a>00883 
<a name="l00884"></a>00884     <span class="keywordflow">case</span> <a class="code" href="group__DBusProtocol.html#ga0cd885e6e808b28ff082a7f8a2c9f579" title="Header field code for the path - the path is the object emitting a signal or the object receiving a m...">DBUS_HEADER_FIELD_PATH</a>:
<a name="l00885"></a>00885       <span class="comment">/* OBJECT_PATH was validated generically due to its type */</span>
<a name="l00886"></a>00886       string_validation_func = <a class="code" href="group__DBusMacros.html#ga070d2ce7b6bb7e5c05602aa8c308d0c4" title="A null pointer, defined appropriately for C or C++.">NULL</a>;
<a name="l00887"></a>00887 
<a name="l00888"></a>00888       <span class="keywordflow">if</span> (<a class="code" href="group__DBusString.html#ga2095c2a797ae245521a7588b32279110" title="Tests two sub-parts of two DBusString for equality.">_dbus_string_equal_substring</a> (&amp;_dbus_local_path_str,
<a name="l00889"></a>00889                                         0,
<a name="l00890"></a>00890                                         _dbus_string_get_length (&amp;_dbus_local_path_str),
<a name="l00891"></a>00891                                         value_str, str_data_pos))
<a name="l00892"></a>00892         {
<a name="l00893"></a>00893           _dbus_verbose (<span class="stringliteral">&quot;Message is from the local path\n&quot;</span>);
<a name="l00894"></a>00894           <span class="keywordflow">return</span> DBUS_INVALID_USES_LOCAL_PATH;
<a name="l00895"></a>00895         }
<a name="l00896"></a>00896       <span class="keywordflow">break</span>;
<a name="l00897"></a>00897 
<a name="l00898"></a>00898     <span class="keywordflow">case</span> <a class="code" href="group__DBusProtocol.html#ga1067e28a7151a161e5fd601a3b017584" title="Header field code for a reply serial, used to match a DBUS_MESSAGE_TYPE_METHOD_RETURN message with th...">DBUS_HEADER_FIELD_REPLY_SERIAL</a>:
<a name="l00899"></a>00899       <span class="comment">/* Can&#39;t be 0 */</span>
<a name="l00900"></a>00900       <span class="keywordflow">if</span> (v_UINT32 == 0)
<a name="l00901"></a>00901         {
<a name="l00902"></a>00902           <span class="keywordflow">return</span> DBUS_INVALID_BAD_SERIAL;
<a name="l00903"></a>00903         }
<a name="l00904"></a>00904       <span class="keywordflow">break</span>;
<a name="l00905"></a>00905 
<a name="l00906"></a>00906     <span class="keywordflow">case</span> <a class="code" href="group__DBusProtocol.html#ga03b9c24acbfd1e3da19804c739612885" title="Header field code for the number of unix file descriptors associated with this message.">DBUS_HEADER_FIELD_UNIX_FDS</a>:
<a name="l00907"></a>00907       <span class="comment">/* Every value makes sense */</span>
<a name="l00908"></a>00908       <span class="keywordflow">break</span>;
<a name="l00909"></a>00909 
<a name="l00910"></a>00910     <span class="keywordflow">case</span> <a class="code" href="group__DBusProtocol.html#ga450d63fa110d3cb891082e23291580b4" title="Header field code for the type signature of a message.">DBUS_HEADER_FIELD_SIGNATURE</a>:
<a name="l00911"></a>00911       <span class="comment">/* SIGNATURE validated generically due to its type */</span>
<a name="l00912"></a>00912       string_validation_func = <a class="code" href="group__DBusMacros.html#ga070d2ce7b6bb7e5c05602aa8c308d0c4" title="A null pointer, defined appropriately for C or C++.">NULL</a>;
<a name="l00913"></a>00913       <span class="keywordflow">break</span>;
<a name="l00914"></a>00914 
<a name="l00915"></a>00915     <span class="keywordflow">default</span>:
<a name="l00916"></a>00916       _dbus_assert_not_reached (<span class="stringliteral">&quot;unknown field shouldn&#39;t be seen here&quot;</span>);
<a name="l00917"></a>00917       <span class="keywordflow">break</span>;
<a name="l00918"></a>00918     }
<a name="l00919"></a>00919 
<a name="l00920"></a>00920   <span class="keywordflow">if</span> (string_validation_func)
<a name="l00921"></a>00921     {
<a name="l00922"></a>00922       dbus_uint32_t len;
<a name="l00923"></a>00923 
<a name="l00924"></a>00924       _dbus_assert (bad_string_code != DBUS_VALID);
<a name="l00925"></a>00925 
<a name="l00926"></a>00926       len = <a class="code" href="group__DBusMarshal.html#ga6dd82a202c19758cbf76dbed2946615d" title="Convenience function to demarshal a 32 bit unsigned integer.">_dbus_marshal_read_uint32</a> (value_str, value_pos,
<a name="l00927"></a>00927                                        <a class="code" href="group__DBusMarshal.html#ga65c023673b837c27e8ccda5c2528d806" title="Returns the header&#39;s byte order.">_dbus_header_get_byte_order</a> (header),
<a name="l00928"></a>00928                                        <a class="code" href="group__DBusMacros.html#ga070d2ce7b6bb7e5c05602aa8c308d0c4" title="A null pointer, defined appropriately for C or C++.">NULL</a>);
<a name="l00929"></a>00929 
<a name="l00930"></a>00930 <span class="preprocessor">#if 0</span>
<a name="l00931"></a>00931 <span class="preprocessor"></span>      _dbus_verbose (<span class="stringliteral">&quot;Validating string header field; code %d if fails\n&quot;</span>,
<a name="l00932"></a>00932                      bad_string_code);
<a name="l00933"></a>00933 <span class="preprocessor">#endif</span>
<a name="l00934"></a>00934 <span class="preprocessor"></span>      <span class="keywordflow">if</span> (!(*string_validation_func) (value_str, str_data_pos, len))
<a name="l00935"></a>00935         <span class="keywordflow">return</span> bad_string_code;
<a name="l00936"></a>00936     }
<a name="l00937"></a>00937 
<a name="l00938"></a>00938   <span class="keywordflow">return</span> DBUS_VALID;
<a name="l00939"></a>00939 }
<a name="l00940"></a>00940 
<a name="l00967"></a>00967 <a class="code" href="group__DBusTypes.html#ga39c9cb0f3a2a8ad6f55cc4855d035349" title="A boolean, valid values are TRUE and FALSE.">dbus_bool_t</a>
<a name="l00968"></a><a class="code" href="group__DBusMarshal.html#ga0c3a3f95d9a53b91a0cd0b260196685b">00968</a> <a class="code" href="group__DBusMarshal.html#ga0c3a3f95d9a53b91a0cd0b260196685b" title="Creates a message header from potentially-untrusted data.">_dbus_header_load</a> (<a class="code" href="structDBusHeader.html" title="Message header data and some cached details of it.">DBusHeader</a>        *header,
<a name="l00969"></a>00969                    <a class="code" href="group__DBusMarshal.html#gaf9dce059725fa793c44b219460cbbe6d" title="This is used rather than a bool for high visibility.">DBusValidationMode</a> mode,
<a name="l00970"></a>00970                    <a class="code" href="group__DBusMarshal.html#ga0c4521d30d6650a33673a4d7f9cc007c" title="This is primarily used in unit testing, so we can verify that each invalid message is invalid for the...">DBusValidity</a>      *validity,
<a name="l00971"></a>00971                    <span class="keywordtype">int</span>                byte_order,
<a name="l00972"></a>00972                    <span class="keywordtype">int</span>                fields_array_len,
<a name="l00973"></a>00973                    <span class="keywordtype">int</span>                header_len,
<a name="l00974"></a>00974                    <span class="keywordtype">int</span>                body_len,
<a name="l00975"></a>00975                    <span class="keyword">const</span> <a class="code" href="structDBusString.html">DBusString</a>  *str,
<a name="l00976"></a>00976                    <span class="keywordtype">int</span>                start,
<a name="l00977"></a>00977                    <span class="keywordtype">int</span>                len)
<a name="l00978"></a>00978 {
<a name="l00979"></a>00979   <span class="keywordtype">int</span> leftover;
<a name="l00980"></a>00980   <a class="code" href="group__DBusMarshal.html#ga0c4521d30d6650a33673a4d7f9cc007c" title="This is primarily used in unit testing, so we can verify that each invalid message is invalid for the...">DBusValidity</a> v;
<a name="l00981"></a>00981   <a class="code" href="structDBusTypeReader.html" title="The type reader is an iterator for reading values from a block of values.">DBusTypeReader</a> reader;
<a name="l00982"></a>00982   <a class="code" href="structDBusTypeReader.html" title="The type reader is an iterator for reading values from a block of values.">DBusTypeReader</a> array_reader;
<a name="l00983"></a>00983   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> v_byte;
<a name="l00984"></a>00984   dbus_uint32_t v_uint32;
<a name="l00985"></a>00985   dbus_uint32_t serial;
<a name="l00986"></a>00986   <span class="keywordtype">int</span> padding_start;
<a name="l00987"></a>00987   <span class="keywordtype">int</span> padding_len;
<a name="l00988"></a>00988   <span class="keywordtype">int</span> i;
<a name="l00989"></a>00989 
<a name="l00990"></a>00990   _dbus_assert (start == (<span class="keywordtype">int</span>) _DBUS_ALIGN_VALUE (start, 8));
<a name="l00991"></a>00991   _dbus_assert (header_len &lt;= len);
<a name="l00992"></a>00992   _dbus_assert (_dbus_string_get_length (&amp;header-&gt;<a class="code" href="structDBusHeader.html#a67df8bff43c10e2d4f6ae36b56ee5814" title="Header network data, stored separately from body so we can independently realloc it.">data</a>) == 0);
<a name="l00993"></a>00993 
<a name="l00994"></a>00994   <span class="keywordflow">if</span> (!<a class="code" href="group__DBusString.html#gaf5f13bc7ac7a623516930d26ae2589bf" title="Like _dbus_string_copy(), but can copy a segment from the middle of the source string.">_dbus_string_copy_len</a> (str, start, header_len, &amp;header-&gt;<a class="code" href="structDBusHeader.html#a67df8bff43c10e2d4f6ae36b56ee5814" title="Header network data, stored separately from body so we can independently realloc it.">data</a>, 0))
<a name="l00995"></a>00995     {
<a name="l00996"></a>00996       _dbus_verbose (<span class="stringliteral">&quot;Failed to copy buffer into new header\n&quot;</span>);
<a name="l00997"></a>00997       *validity = DBUS_VALIDITY_UNKNOWN_OOM_ERROR;
<a name="l00998"></a>00998       <span class="keywordflow">return</span> <a class="code" href="group__DBusMacros.html#gaa93f0eb578d23995850d61f7d61c55c1" title="Expands to &quot;0&quot;.">FALSE</a>;
<a name="l00999"></a>00999     }
<a name="l01000"></a>01000 
<a name="l01001"></a>01001   <span class="keywordflow">if</span> (mode == DBUS_VALIDATION_MODE_WE_TRUST_THIS_DATA_ABSOLUTELY)
<a name="l01002"></a>01002     {
<a name="l01003"></a>01003       leftover = len - header_len - body_len - start;
<a name="l01004"></a>01004     }
<a name="l01005"></a>01005   <span class="keywordflow">else</span>
<a name="l01006"></a>01006     {
<a name="l01007"></a>01007       v = <a class="code" href="group__DBusMarshal.html#gae997884ec8091aacb5492c2b5a7eaef9" title="Verifies that the range of value_str from value_pos to value_end is a legitimate value of type expect...">_dbus_validate_body_with_reason</a> (&amp;_dbus_header_signature_str, 0,
<a name="l01008"></a>01008                                            byte_order,
<a name="l01009"></a>01009                                            &amp;leftover,
<a name="l01010"></a>01010                                            str, start, len);
<a name="l01011"></a>01011       
<a name="l01012"></a>01012       <span class="keywordflow">if</span> (v != DBUS_VALID)
<a name="l01013"></a>01013         {
<a name="l01014"></a>01014           *validity = v;
<a name="l01015"></a>01015           <span class="keywordflow">goto</span> invalid;
<a name="l01016"></a>01016         }
<a name="l01017"></a>01017     }
<a name="l01018"></a>01018 
<a name="l01019"></a>01019   _dbus_assert (leftover &lt; len);
<a name="l01020"></a>01020 
<a name="l01021"></a>01021   padding_len = header_len - (<a class="code" href="group__DBusMarshal.html#gaaa085e57f49f527ef210e842be999929" title="Offset to first field in header.">FIRST_FIELD_OFFSET</a> + fields_array_len);
<a name="l01022"></a>01022   padding_start = start + <a class="code" href="group__DBusMarshal.html#gaaa085e57f49f527ef210e842be999929" title="Offset to first field in header.">FIRST_FIELD_OFFSET</a> + fields_array_len;
<a name="l01023"></a>01023   _dbus_assert (start + header_len == (<span class="keywordtype">int</span>) _DBUS_ALIGN_VALUE (padding_start, 8));
<a name="l01024"></a>01024   _dbus_assert (start + header_len == padding_start + padding_len);
<a name="l01025"></a>01025 
<a name="l01026"></a>01026   <span class="keywordflow">if</span> (mode != DBUS_VALIDATION_MODE_WE_TRUST_THIS_DATA_ABSOLUTELY)
<a name="l01027"></a>01027     {
<a name="l01028"></a>01028       <span class="keywordflow">if</span> (!<a class="code" href="group__DBusString.html#ga199d0fc00ee3cd0300a1b3870d7986a3" title="Checks that the given range of the string is all nul bytes.">_dbus_string_validate_nul</a> (str, padding_start, padding_len))
<a name="l01029"></a>01029         {
<a name="l01030"></a>01030           *validity = DBUS_INVALID_ALIGNMENT_PADDING_NOT_NUL;
<a name="l01031"></a>01031           <span class="keywordflow">goto</span> invalid;
<a name="l01032"></a>01032         }
<a name="l01033"></a>01033     }
<a name="l01034"></a>01034 
<a name="l01035"></a>01035   header-&gt;<a class="code" href="structDBusHeader.html#aa22a8d00f061310e12716f656b4d9b8f" title="bytes of alignment in header">padding</a> = padding_len;
<a name="l01036"></a>01036 
<a name="l01037"></a>01037   <span class="keywordflow">if</span> (mode == DBUS_VALIDATION_MODE_WE_TRUST_THIS_DATA_ABSOLUTELY)
<a name="l01038"></a>01038     {
<a name="l01039"></a>01039       *validity = DBUS_VALID;
<a name="l01040"></a>01040       <span class="keywordflow">return</span> <a class="code" href="group__DBusMacros.html#gaa8cecfc5c5c054d2875c03e77b7be15d" title="Expands to &quot;1&quot;.">TRUE</a>;
<a name="l01041"></a>01041     }
<a name="l01042"></a>01042 
<a name="l01043"></a>01043   <span class="comment">/* We now know the data is well-formed, but we have to check that</span>
<a name="l01044"></a>01044 <span class="comment">   * it&#39;s valid.</span>
<a name="l01045"></a>01045 <span class="comment">   */</span>
<a name="l01046"></a>01046 
<a name="l01047"></a>01047   <a class="code" href="group__DBusMarshal.html#ga35d70cf69b1196518367e3e68e9b2dd2" title="Initializes a type reader.">_dbus_type_reader_init</a> (&amp;reader,
<a name="l01048"></a>01048                           byte_order,
<a name="l01049"></a>01049                           &amp;_dbus_header_signature_str, 0,
<a name="l01050"></a>01050                           str, start);
<a name="l01051"></a>01051 
<a name="l01052"></a>01052   <span class="comment">/* BYTE ORDER */</span>
<a name="l01053"></a>01053   _dbus_assert (<a class="code" href="group__DBusMarshal.html#gab8e39cb8084247d54d7f272c51622a73" title="Gets the type of the value the reader is currently pointing to; or for a types-only reader gets the t...">_dbus_type_reader_get_current_type</a> (&amp;reader) == <a class="code" href="group__DBusProtocol.html#ga355d6d0998164a5eb915a26fb67fce5f" title="Type code marking an 8-bit unsigned integer.">DBUS_TYPE_BYTE</a>);
<a name="l01054"></a>01054   _dbus_assert (<a class="code" href="group__DBusMarshal.html#ga2a8ab1152821950b1fe29e000954981c" title="Gets the current position in the value block.">_dbus_type_reader_get_value_pos</a> (&amp;reader) == <a class="code" href="group__DBusMarshal.html#gaa5b7e77f37761139698892e4b8aad029" title="Offset to byte order from start of header.">BYTE_ORDER_OFFSET</a>);
<a name="l01055"></a>01055   <a class="code" href="group__DBusMarshal.html#gaa54355ee98d6721d7a29b5ae7d92eb9a" title="Reads a basic-typed value, as with _dbus_marshal_read_basic().">_dbus_type_reader_read_basic</a> (&amp;reader, &amp;v_byte);
<a name="l01056"></a>01056   <a class="code" href="group__DBusMarshal.html#ga746c09512d4905f2d2fac7ed4c3c63c2" title="Skip to the next value on this &quot;level&quot;.">_dbus_type_reader_next</a> (&amp;reader);
<a name="l01057"></a>01057 
<a name="l01058"></a>01058   _dbus_assert (v_byte == byte_order);
<a name="l01059"></a>01059 
<a name="l01060"></a>01060   <span class="comment">/* MESSAGE TYPE */</span>
<a name="l01061"></a>01061   _dbus_assert (<a class="code" href="group__DBusMarshal.html#gab8e39cb8084247d54d7f272c51622a73" title="Gets the type of the value the reader is currently pointing to; or for a types-only reader gets the t...">_dbus_type_reader_get_current_type</a> (&amp;reader) == <a class="code" href="group__DBusProtocol.html#ga355d6d0998164a5eb915a26fb67fce5f" title="Type code marking an 8-bit unsigned integer.">DBUS_TYPE_BYTE</a>);
<a name="l01062"></a>01062   _dbus_assert (<a class="code" href="group__DBusMarshal.html#ga2a8ab1152821950b1fe29e000954981c" title="Gets the current position in the value block.">_dbus_type_reader_get_value_pos</a> (&amp;reader) == <a class="code" href="group__DBusMarshal.html#gaf4fe78df75f4afa2ec63304462614b03" title="Offset to type from start of header.">TYPE_OFFSET</a>);
<a name="l01063"></a>01063   <a class="code" href="group__DBusMarshal.html#gaa54355ee98d6721d7a29b5ae7d92eb9a" title="Reads a basic-typed value, as with _dbus_marshal_read_basic().">_dbus_type_reader_read_basic</a> (&amp;reader, &amp;v_byte);
<a name="l01064"></a>01064   <a class="code" href="group__DBusMarshal.html#ga746c09512d4905f2d2fac7ed4c3c63c2" title="Skip to the next value on this &quot;level&quot;.">_dbus_type_reader_next</a> (&amp;reader);
<a name="l01065"></a>01065 
<a name="l01066"></a>01066   <span class="comment">/* unknown message types are supposed to be ignored, so only validation here is</span>
<a name="l01067"></a>01067 <span class="comment">   * that it isn&#39;t invalid</span>
<a name="l01068"></a>01068 <span class="comment">   */</span>
<a name="l01069"></a>01069   <span class="keywordflow">if</span> (v_byte == <a class="code" href="group__DBusProtocol.html#gac975525a6ce258a7a70c583c9741b516" title="This value is never a valid message type, see dbus_message_get_type()">DBUS_MESSAGE_TYPE_INVALID</a>)
<a name="l01070"></a>01070     {
<a name="l01071"></a>01071       *validity = DBUS_INVALID_BAD_MESSAGE_TYPE;
<a name="l01072"></a>01072       <span class="keywordflow">goto</span> invalid;
<a name="l01073"></a>01073     }
<a name="l01074"></a>01074 
<a name="l01075"></a>01075   <span class="comment">/* FLAGS */</span>
<a name="l01076"></a>01076   _dbus_assert (<a class="code" href="group__DBusMarshal.html#gab8e39cb8084247d54d7f272c51622a73" title="Gets the type of the value the reader is currently pointing to; or for a types-only reader gets the t...">_dbus_type_reader_get_current_type</a> (&amp;reader) == <a class="code" href="group__DBusProtocol.html#ga355d6d0998164a5eb915a26fb67fce5f" title="Type code marking an 8-bit unsigned integer.">DBUS_TYPE_BYTE</a>);
<a name="l01077"></a>01077   _dbus_assert (<a class="code" href="group__DBusMarshal.html#ga2a8ab1152821950b1fe29e000954981c" title="Gets the current position in the value block.">_dbus_type_reader_get_value_pos</a> (&amp;reader) == <a class="code" href="group__DBusMarshal.html#ga7fe1bac4010cdc7e27de1e19702c071e" title="Offset to flags from start of header.">FLAGS_OFFSET</a>);
<a name="l01078"></a>01078   <a class="code" href="group__DBusMarshal.html#gaa54355ee98d6721d7a29b5ae7d92eb9a" title="Reads a basic-typed value, as with _dbus_marshal_read_basic().">_dbus_type_reader_read_basic</a> (&amp;reader, &amp;v_byte);
<a name="l01079"></a>01079   <a class="code" href="group__DBusMarshal.html#ga746c09512d4905f2d2fac7ed4c3c63c2" title="Skip to the next value on this &quot;level&quot;.">_dbus_type_reader_next</a> (&amp;reader);
<a name="l01080"></a>01080 
<a name="l01081"></a>01081   <span class="comment">/* unknown flags should be ignored */</span>
<a name="l01082"></a>01082 
<a name="l01083"></a>01083   <span class="comment">/* PROTOCOL VERSION */</span>
<a name="l01084"></a>01084   _dbus_assert (<a class="code" href="group__DBusMarshal.html#gab8e39cb8084247d54d7f272c51622a73" title="Gets the type of the value the reader is currently pointing to; or for a types-only reader gets the t...">_dbus_type_reader_get_current_type</a> (&amp;reader) == <a class="code" href="group__DBusProtocol.html#ga355d6d0998164a5eb915a26fb67fce5f" title="Type code marking an 8-bit unsigned integer.">DBUS_TYPE_BYTE</a>);
<a name="l01085"></a>01085   _dbus_assert (<a class="code" href="group__DBusMarshal.html#ga2a8ab1152821950b1fe29e000954981c" title="Gets the current position in the value block.">_dbus_type_reader_get_value_pos</a> (&amp;reader) == <a class="code" href="group__DBusMarshal.html#ga4f04ecce1223b00d263c0accdea144ad" title="Offset to version from start of header.">VERSION_OFFSET</a>);
<a name="l01086"></a>01086   <a class="code" href="group__DBusMarshal.html#gaa54355ee98d6721d7a29b5ae7d92eb9a" title="Reads a basic-typed value, as with _dbus_marshal_read_basic().">_dbus_type_reader_read_basic</a> (&amp;reader, &amp;v_byte);
<a name="l01087"></a>01087   <a class="code" href="group__DBusMarshal.html#ga746c09512d4905f2d2fac7ed4c3c63c2" title="Skip to the next value on this &quot;level&quot;.">_dbus_type_reader_next</a> (&amp;reader);
<a name="l01088"></a>01088 
<a name="l01089"></a>01089   <span class="keywordflow">if</span> (v_byte != <a class="code" href="group__DBusProtocol.html#gae1ab70067a616d852e5fc264abb66608" title="Protocol version.">DBUS_MAJOR_PROTOCOL_VERSION</a>)
<a name="l01090"></a>01090     {
<a name="l01091"></a>01091       *validity = DBUS_INVALID_BAD_PROTOCOL_VERSION;
<a name="l01092"></a>01092       <span class="keywordflow">goto</span> invalid;
<a name="l01093"></a>01093     }
<a name="l01094"></a>01094 
<a name="l01095"></a>01095   <span class="comment">/* BODY LENGTH */</span>
<a name="l01096"></a>01096   _dbus_assert (<a class="code" href="group__DBusMarshal.html#gab8e39cb8084247d54d7f272c51622a73" title="Gets the type of the value the reader is currently pointing to; or for a types-only reader gets the t...">_dbus_type_reader_get_current_type</a> (&amp;reader) == <a class="code" href="group__DBusProtocol.html#gaedb1740bd8a9174b98ac593eded25d49" title="Type code marking a 32-bit unsigned integer.">DBUS_TYPE_UINT32</a>);
<a name="l01097"></a>01097   _dbus_assert (<a class="code" href="group__DBusMarshal.html#ga2a8ab1152821950b1fe29e000954981c" title="Gets the current position in the value block.">_dbus_type_reader_get_value_pos</a> (&amp;reader) == <a class="code" href="group__DBusMarshal.html#ga190a2d89e79c9d76fcba4f06ec8b5b5c" title="Offset to body length from start of header.">BODY_LENGTH_OFFSET</a>);
<a name="l01098"></a>01098   <a class="code" href="group__DBusMarshal.html#gaa54355ee98d6721d7a29b5ae7d92eb9a" title="Reads a basic-typed value, as with _dbus_marshal_read_basic().">_dbus_type_reader_read_basic</a> (&amp;reader, &amp;v_uint32);
<a name="l01099"></a>01099   <a class="code" href="group__DBusMarshal.html#ga746c09512d4905f2d2fac7ed4c3c63c2" title="Skip to the next value on this &quot;level&quot;.">_dbus_type_reader_next</a> (&amp;reader);
<a name="l01100"></a>01100 
<a name="l01101"></a>01101   _dbus_assert (body_len == (<span class="keywordtype">signed</span>) v_uint32);
<a name="l01102"></a>01102 
<a name="l01103"></a>01103   <span class="comment">/* SERIAL */</span>
<a name="l01104"></a>01104   _dbus_assert (<a class="code" href="group__DBusMarshal.html#gab8e39cb8084247d54d7f272c51622a73" title="Gets the type of the value the reader is currently pointing to; or for a types-only reader gets the t...">_dbus_type_reader_get_current_type</a> (&amp;reader) == <a class="code" href="group__DBusProtocol.html#gaedb1740bd8a9174b98ac593eded25d49" title="Type code marking a 32-bit unsigned integer.">DBUS_TYPE_UINT32</a>);
<a name="l01105"></a>01105   _dbus_assert (<a class="code" href="group__DBusMarshal.html#ga2a8ab1152821950b1fe29e000954981c" title="Gets the current position in the value block.">_dbus_type_reader_get_value_pos</a> (&amp;reader) == <a class="code" href="group__DBusMarshal.html#ga4a9c0639714b478a4905cdd6e999b6b3" title="Offset to client serial from start of header.">SERIAL_OFFSET</a>);
<a name="l01106"></a>01106   <a class="code" href="group__DBusMarshal.html#gaa54355ee98d6721d7a29b5ae7d92eb9a" title="Reads a basic-typed value, as with _dbus_marshal_read_basic().">_dbus_type_reader_read_basic</a> (&amp;reader, &amp;serial);
<a name="l01107"></a>01107   <a class="code" href="group__DBusMarshal.html#ga746c09512d4905f2d2fac7ed4c3c63c2" title="Skip to the next value on this &quot;level&quot;.">_dbus_type_reader_next</a> (&amp;reader);
<a name="l01108"></a>01108 
<a name="l01109"></a>01109   <span class="keywordflow">if</span> (serial == 0)
<a name="l01110"></a>01110     {
<a name="l01111"></a>01111       *validity = DBUS_INVALID_BAD_SERIAL;
<a name="l01112"></a>01112       <span class="keywordflow">goto</span> invalid;
<a name="l01113"></a>01113     }
<a name="l01114"></a>01114 
<a name="l01115"></a>01115   _dbus_assert (<a class="code" href="group__DBusMarshal.html#gab8e39cb8084247d54d7f272c51622a73" title="Gets the type of the value the reader is currently pointing to; or for a types-only reader gets the t...">_dbus_type_reader_get_current_type</a> (&amp;reader) == <a class="code" href="group__DBusProtocol.html#ga8912f600f81a773066ca03d9163613a9" title="Type code marking a D-Bus array type.">DBUS_TYPE_ARRAY</a>);
<a name="l01116"></a>01116   _dbus_assert (<a class="code" href="group__DBusMarshal.html#ga2a8ab1152821950b1fe29e000954981c" title="Gets the current position in the value block.">_dbus_type_reader_get_value_pos</a> (&amp;reader) == <a class="code" href="group__DBusMarshal.html#gae9759e0de1d8a650f37632c3dc22427e" title="Offset to fields array length from start of header.">FIELDS_ARRAY_LENGTH_OFFSET</a>);
<a name="l01117"></a>01117 
<a name="l01118"></a>01118   <a class="code" href="group__DBusMarshal.html#ga082b410820c74b2a6ca816a8e0c91803" title="Initialize a new reader pointing to the first type and corresponding value that&#39;s a child of the curr...">_dbus_type_reader_recurse</a> (&amp;reader, &amp;array_reader);
<a name="l01119"></a>01119   <span class="keywordflow">while</span> (<a class="code" href="group__DBusMarshal.html#gab8e39cb8084247d54d7f272c51622a73" title="Gets the type of the value the reader is currently pointing to; or for a types-only reader gets the t...">_dbus_type_reader_get_current_type</a> (&amp;array_reader) != <a class="code" href="group__DBusProtocol.html#gaa9588da889743b2119dc6664712ae51e" title="Type code that is never equal to a legitimate type code.">DBUS_TYPE_INVALID</a>)
<a name="l01120"></a>01120     {
<a name="l01121"></a>01121       <a class="code" href="structDBusTypeReader.html" title="The type reader is an iterator for reading values from a block of values.">DBusTypeReader</a> struct_reader;
<a name="l01122"></a>01122       <a class="code" href="structDBusTypeReader.html" title="The type reader is an iterator for reading values from a block of values.">DBusTypeReader</a> variant_reader;
<a name="l01123"></a>01123       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> field_code;
<a name="l01124"></a>01124 
<a name="l01125"></a>01125       _dbus_assert (<a class="code" href="group__DBusMarshal.html#gab8e39cb8084247d54d7f272c51622a73" title="Gets the type of the value the reader is currently pointing to; or for a types-only reader gets the t...">_dbus_type_reader_get_current_type</a> (&amp;array_reader) == <a class="code" href="group__DBusProtocol.html#gae4b22a74b9edb0ec0ff6e0294794d3f9" title="STRUCT and DICT_ENTRY are sort of special since their codes can&#39;t appear in a type string...">DBUS_TYPE_STRUCT</a>);
<a name="l01126"></a>01126 
<a name="l01127"></a>01127       <a class="code" href="group__DBusMarshal.html#ga082b410820c74b2a6ca816a8e0c91803" title="Initialize a new reader pointing to the first type and corresponding value that&#39;s a child of the curr...">_dbus_type_reader_recurse</a> (&amp;array_reader, &amp;struct_reader);
<a name="l01128"></a>01128 
<a name="l01129"></a>01129       _dbus_assert (<a class="code" href="group__DBusMarshal.html#gab8e39cb8084247d54d7f272c51622a73" title="Gets the type of the value the reader is currently pointing to; or for a types-only reader gets the t...">_dbus_type_reader_get_current_type</a> (&amp;struct_reader) == <a class="code" href="group__DBusProtocol.html#ga355d6d0998164a5eb915a26fb67fce5f" title="Type code marking an 8-bit unsigned integer.">DBUS_TYPE_BYTE</a>);
<a name="l01130"></a>01130       <a class="code" href="group__DBusMarshal.html#gaa54355ee98d6721d7a29b5ae7d92eb9a" title="Reads a basic-typed value, as with _dbus_marshal_read_basic().">_dbus_type_reader_read_basic</a> (&amp;struct_reader, &amp;field_code);
<a name="l01131"></a>01131       <a class="code" href="group__DBusMarshal.html#ga746c09512d4905f2d2fac7ed4c3c63c2" title="Skip to the next value on this &quot;level&quot;.">_dbus_type_reader_next</a> (&amp;struct_reader);
<a name="l01132"></a>01132 
<a name="l01133"></a>01133       <span class="keywordflow">if</span> (field_code == <a class="code" href="group__DBusProtocol.html#ga075b0efc570129393d3fb653ce4bbd76" title="Not equal to any valid header field code.">DBUS_HEADER_FIELD_INVALID</a>)
<a name="l01134"></a>01134         {
<a name="l01135"></a>01135           _dbus_verbose (<span class="stringliteral">&quot;invalid header field code\n&quot;</span>);
<a name="l01136"></a>01136           *validity = DBUS_INVALID_HEADER_FIELD_CODE;
<a name="l01137"></a>01137           <span class="keywordflow">goto</span> invalid;
<a name="l01138"></a>01138         }
<a name="l01139"></a>01139 
<a name="l01140"></a>01140       <span class="keywordflow">if</span> (field_code &gt; <a class="code" href="group__DBusProtocol.html#ga94f09d2b35473c8ffa6d3190b5f97c5c" title="Value of the highest-numbered header field code, can be used to determine the size of an array indexe...">DBUS_HEADER_FIELD_LAST</a>)
<a name="l01141"></a>01141         {
<a name="l01142"></a>01142           _dbus_verbose (<span class="stringliteral">&quot;unknown header field code %d, skipping\n&quot;</span>,
<a name="l01143"></a>01143                          field_code);
<a name="l01144"></a>01144           <span class="keywordflow">goto</span> next_field;
<a name="l01145"></a>01145         }
<a name="l01146"></a>01146 
<a name="l01147"></a>01147       _dbus_assert (<a class="code" href="group__DBusMarshal.html#gab8e39cb8084247d54d7f272c51622a73" title="Gets the type of the value the reader is currently pointing to; or for a types-only reader gets the t...">_dbus_type_reader_get_current_type</a> (&amp;struct_reader) == <a class="code" href="group__DBusProtocol.html#ga4aa7a463ad2bce4e9aa95e3e397ddcf1" title="Type code marking a D-Bus variant type.">DBUS_TYPE_VARIANT</a>);
<a name="l01148"></a>01148       <a class="code" href="group__DBusMarshal.html#ga082b410820c74b2a6ca816a8e0c91803" title="Initialize a new reader pointing to the first type and corresponding value that&#39;s a child of the curr...">_dbus_type_reader_recurse</a> (&amp;struct_reader, &amp;variant_reader);
<a name="l01149"></a>01149 
<a name="l01150"></a>01150       v = load_and_validate_field (header, field_code, &amp;variant_reader);
<a name="l01151"></a>01151       <span class="keywordflow">if</span> (v != DBUS_VALID)
<a name="l01152"></a>01152         {
<a name="l01153"></a>01153           _dbus_verbose (<span class="stringliteral">&quot;Field %d was invalid\n&quot;</span>, field_code);
<a name="l01154"></a>01154           *validity = v;
<a name="l01155"></a>01155           <span class="keywordflow">goto</span> invalid;
<a name="l01156"></a>01156         }
<a name="l01157"></a>01157 
<a name="l01158"></a>01158     next_field:
<a name="l01159"></a>01159       <a class="code" href="group__DBusMarshal.html#ga746c09512d4905f2d2fac7ed4c3c63c2" title="Skip to the next value on this &quot;level&quot;.">_dbus_type_reader_next</a> (&amp;array_reader);
<a name="l01160"></a>01160     }
<a name="l01161"></a>01161 
<a name="l01162"></a>01162   <span class="comment">/* Anything we didn&#39;t fill in is now known not to exist */</span>
<a name="l01163"></a>01163   i = 0;
<a name="l01164"></a>01164   <span class="keywordflow">while</span> (i &lt;= <a class="code" href="group__DBusProtocol.html#ga94f09d2b35473c8ffa6d3190b5f97c5c" title="Value of the highest-numbered header field code, can be used to determine the size of an array indexe...">DBUS_HEADER_FIELD_LAST</a>)
<a name="l01165"></a>01165     {
<a name="l01166"></a>01166       <span class="keywordflow">if</span> (header-&gt;<a class="code" href="structDBusHeader.html#ac58a309593d0dc7e8d5a02f3b3442384" title="Track the location of each field in header.">fields</a>[i].<a class="code" href="structDBusHeaderField.html#aa9616d127de7488f6d9dc18c4d0c2133" title="Position of field value, or -1/-2.">value_pos</a> == _DBUS_HEADER_FIELD_VALUE_UNKNOWN)
<a name="l01167"></a>01167         header-&gt;<a class="code" href="structDBusHeader.html#ac58a309593d0dc7e8d5a02f3b3442384" title="Track the location of each field in header.">fields</a>[i].<a class="code" href="structDBusHeaderField.html#aa9616d127de7488f6d9dc18c4d0c2133" title="Position of field value, or -1/-2.">value_pos</a> = _DBUS_HEADER_FIELD_VALUE_NONEXISTENT;
<a name="l01168"></a>01168       ++i;
<a name="l01169"></a>01169     }
<a name="l01170"></a>01170 
<a name="l01171"></a>01171   v = check_mandatory_fields (header);
<a name="l01172"></a>01172   <span class="keywordflow">if</span> (v != DBUS_VALID)
<a name="l01173"></a>01173     {
<a name="l01174"></a>01174       _dbus_verbose (<span class="stringliteral">&quot;Mandatory fields were missing, code %d\n&quot;</span>, v);
<a name="l01175"></a>01175       *validity = v;
<a name="l01176"></a>01176       <span class="keywordflow">goto</span> invalid;
<a name="l01177"></a>01177     }
<a name="l01178"></a>01178 
<a name="l01179"></a>01179   *validity = DBUS_VALID;
<a name="l01180"></a>01180   <span class="keywordflow">return</span> <a class="code" href="group__DBusMacros.html#gaa8cecfc5c5c054d2875c03e77b7be15d" title="Expands to &quot;1&quot;.">TRUE</a>;
<a name="l01181"></a>01181 
<a name="l01182"></a>01182  invalid:
<a name="l01183"></a>01183   <a class="code" href="group__DBusString.html#ga08c423b93c28dd746dcb93e0461ab95c" title="Sets the length of a string.">_dbus_string_set_length</a> (&amp;header-&gt;<a class="code" href="structDBusHeader.html#a67df8bff43c10e2d4f6ae36b56ee5814" title="Header network data, stored separately from body so we can independently realloc it.">data</a>, 0);
<a name="l01184"></a>01184   <span class="keywordflow">return</span> <a class="code" href="group__DBusMacros.html#gaa93f0eb578d23995850d61f7d61c55c1" title="Expands to &quot;0&quot;.">FALSE</a>;
<a name="l01185"></a>01185 }
<a name="l01186"></a>01186 
<a name="l01193"></a>01193 <span class="keywordtype">void</span>
<a name="l01194"></a><a class="code" href="group__DBusMarshal.html#ga0cff04252f97f6a25552c368199897f5">01194</a> <a class="code" href="group__DBusMarshal.html#ga0cff04252f97f6a25552c368199897f5" title="Fills in the correct body length.">_dbus_header_update_lengths</a> (<a class="code" href="structDBusHeader.html" title="Message header data and some cached details of it.">DBusHeader</a> *header,
<a name="l01195"></a>01195                              <span class="keywordtype">int</span>         body_len)
<a name="l01196"></a>01196 {
<a name="l01197"></a>01197   <a class="code" href="group__DBusMarshal.html#ga4bcfb6a664c7e46c7ffc31f96d532a02" title="Sets the 4 bytes at the given offset to a marshaled unsigned integer, replacing anything found there ...">_dbus_marshal_set_uint32</a> (&amp;header-&gt;<a class="code" href="structDBusHeader.html#a67df8bff43c10e2d4f6ae36b56ee5814" title="Header network data, stored separately from body so we can independently realloc it.">data</a>,
<a name="l01198"></a>01198                             <a class="code" href="group__DBusMarshal.html#ga190a2d89e79c9d76fcba4f06ec8b5b5c" title="Offset to body length from start of header.">BODY_LENGTH_OFFSET</a>,
<a name="l01199"></a>01199                             body_len,
<a name="l01200"></a>01200                             <a class="code" href="group__DBusMarshal.html#ga65c023673b837c27e8ccda5c2528d806" title="Returns the header&#39;s byte order.">_dbus_header_get_byte_order</a> (header));
<a name="l01201"></a>01201 }
<a name="l01202"></a>01202 
<a name="l01216"></a>01216 <span class="keyword">static</span> <a class="code" href="group__DBusTypes.html#ga39c9cb0f3a2a8ad6f55cc4855d035349" title="A boolean, valid values are TRUE and FALSE.">dbus_bool_t</a>
<a name="l01217"></a>01217 find_field_for_modification (<a class="code" href="structDBusHeader.html" title="Message header data and some cached details of it.">DBusHeader</a>     *header,
<a name="l01218"></a>01218                              <span class="keywordtype">int</span>             field,
<a name="l01219"></a>01219                              <a class="code" href="structDBusTypeReader.html" title="The type reader is an iterator for reading values from a block of values.">DBusTypeReader</a> *reader,
<a name="l01220"></a>01220                              <a class="code" href="structDBusTypeReader.html" title="The type reader is an iterator for reading values from a block of values.">DBusTypeReader</a> *realign_root)
<a name="l01221"></a>01221 {
<a name="l01222"></a>01222   <a class="code" href="group__DBusTypes.html#ga39c9cb0f3a2a8ad6f55cc4855d035349" title="A boolean, valid values are TRUE and FALSE.">dbus_bool_t</a> retval;
<a name="l01223"></a>01223 
<a name="l01224"></a>01224   retval = <a class="code" href="group__DBusMacros.html#gaa93f0eb578d23995850d61f7d61c55c1" title="Expands to &quot;0&quot;.">FALSE</a>;
<a name="l01225"></a>01225 
<a name="l01226"></a>01226   <a class="code" href="group__DBusMarshal.html#ga35d70cf69b1196518367e3e68e9b2dd2" title="Initializes a type reader.">_dbus_type_reader_init</a> (realign_root,
<a name="l01227"></a>01227                           <a class="code" href="group__DBusMarshal.html#ga65c023673b837c27e8ccda5c2528d806" title="Returns the header&#39;s byte order.">_dbus_header_get_byte_order</a> (header),
<a name="l01228"></a>01228                           &amp;_dbus_header_signature_str,
<a name="l01229"></a>01229                           <a class="code" href="group__DBusMarshal.html#ga935ea6d7c6bb72a10c670f5ef3e34d49" title="Offset from start of _dbus_header_signature_str to the signature of the fields array.">FIELDS_ARRAY_SIGNATURE_OFFSET</a>,
<a name="l01230"></a>01230                           &amp;header-&gt;<a class="code" href="structDBusHeader.html#a67df8bff43c10e2d4f6ae36b56ee5814" title="Header network data, stored separately from body so we can independently realloc it.">data</a>,
<a name="l01231"></a>01231                           <a class="code" href="group__DBusMarshal.html#gae9759e0de1d8a650f37632c3dc22427e" title="Offset to fields array length from start of header.">FIELDS_ARRAY_LENGTH_OFFSET</a>);
<a name="l01232"></a>01232 
<a name="l01233"></a>01233   <a class="code" href="group__DBusMarshal.html#ga082b410820c74b2a6ca816a8e0c91803" title="Initialize a new reader pointing to the first type and corresponding value that&#39;s a child of the curr...">_dbus_type_reader_recurse</a> (realign_root, reader);
<a name="l01234"></a>01234 
<a name="l01235"></a>01235   <span class="keywordflow">while</span> (<a class="code" href="group__DBusMarshal.html#gab8e39cb8084247d54d7f272c51622a73" title="Gets the type of the value the reader is currently pointing to; or for a types-only reader gets the t...">_dbus_type_reader_get_current_type</a> (reader) != <a class="code" href="group__DBusProtocol.html#gaa9588da889743b2119dc6664712ae51e" title="Type code that is never equal to a legitimate type code.">DBUS_TYPE_INVALID</a>)
<a name="l01236"></a>01236     {
<a name="l01237"></a>01237       <a class="code" href="structDBusTypeReader.html" title="The type reader is an iterator for reading values from a block of values.">DBusTypeReader</a> sub;
<a name="l01238"></a>01238       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> field_code;
<a name="l01239"></a>01239 
<a name="l01240"></a>01240       <a class="code" href="group__DBusMarshal.html#ga082b410820c74b2a6ca816a8e0c91803" title="Initialize a new reader pointing to the first type and corresponding value that&#39;s a child of the curr...">_dbus_type_reader_recurse</a> (reader, &amp;sub);
<a name="l01241"></a>01241 
<a name="l01242"></a>01242       _dbus_assert (<a class="code" href="group__DBusMarshal.html#gab8e39cb8084247d54d7f272c51622a73" title="Gets the type of the value the reader is currently pointing to; or for a types-only reader gets the t...">_dbus_type_reader_get_current_type</a> (&amp;sub) == <a class="code" href="group__DBusProtocol.html#ga355d6d0998164a5eb915a26fb67fce5f" title="Type code marking an 8-bit unsigned integer.">DBUS_TYPE_BYTE</a>);
<a name="l01243"></a>01243       <a class="code" href="group__DBusMarshal.html#gaa54355ee98d6721d7a29b5ae7d92eb9a" title="Reads a basic-typed value, as with _dbus_marshal_read_basic().">_dbus_type_reader_read_basic</a> (&amp;sub, &amp;field_code);
<a name="l01244"></a>01244 
<a name="l01245"></a>01245       <span class="keywordflow">if</span> (field_code == (<span class="keywordtype">unsigned</span>) field)
<a name="l01246"></a>01246         {
<a name="l01247"></a>01247           _dbus_assert (<a class="code" href="group__DBusMarshal.html#gab8e39cb8084247d54d7f272c51622a73" title="Gets the type of the value the reader is currently pointing to; or for a types-only reader gets the t...">_dbus_type_reader_get_current_type</a> (reader) == <a class="code" href="group__DBusProtocol.html#gae4b22a74b9edb0ec0ff6e0294794d3f9" title="STRUCT and DICT_ENTRY are sort of special since their codes can&#39;t appear in a type string...">DBUS_TYPE_STRUCT</a>);
<a name="l01248"></a>01248           retval = <a class="code" href="group__DBusMacros.html#gaa8cecfc5c5c054d2875c03e77b7be15d" title="Expands to &quot;1&quot;.">TRUE</a>;
<a name="l01249"></a>01249           <span class="keywordflow">goto</span> done;
<a name="l01250"></a>01250         }
<a name="l01251"></a>01251 
<a name="l01252"></a>01252       <a class="code" href="group__DBusMarshal.html#ga746c09512d4905f2d2fac7ed4c3c63c2" title="Skip to the next value on this &quot;level&quot;.">_dbus_type_reader_next</a> (reader);
<a name="l01253"></a>01253     }
<a name="l01254"></a>01254 
<a name="l01255"></a>01255  done:
<a name="l01256"></a>01256   <span class="keywordflow">return</span> retval;
<a name="l01257"></a>01257 }
<a name="l01258"></a>01258 
<a name="l01270"></a>01270 <a class="code" href="group__DBusTypes.html#ga39c9cb0f3a2a8ad6f55cc4855d035349" title="A boolean, valid values are TRUE and FALSE.">dbus_bool_t</a>
<a name="l01271"></a><a class="code" href="group__DBusMarshal.html#ga4349de00b7754a337526e36fda133464">01271</a> <a class="code" href="group__DBusMarshal.html#ga4349de00b7754a337526e36fda133464" title="Sets the value of a field with basic type.">_dbus_header_set_field_basic</a> (<a class="code" href="structDBusHeader.html" title="Message header data and some cached details of it.">DBusHeader</a>       *header,
<a name="l01272"></a>01272                               <span class="keywordtype">int</span>               field,
<a name="l01273"></a>01273                               <span class="keywordtype">int</span>               type,
<a name="l01274"></a>01274                               <span class="keyword">const</span> <span class="keywordtype">void</span>       *value)
<a name="l01275"></a>01275 {
<a name="l01276"></a>01276   _dbus_assert (field &lt;= <a class="code" href="group__DBusProtocol.html#ga94f09d2b35473c8ffa6d3190b5f97c5c" title="Value of the highest-numbered header field code, can be used to determine the size of an array indexe...">DBUS_HEADER_FIELD_LAST</a>);
<a name="l01277"></a>01277 
<a name="l01278"></a>01278   <span class="keywordflow">if</span> (!reserve_header_padding (header))
<a name="l01279"></a>01279     <span class="keywordflow">return</span> <a class="code" href="group__DBusMacros.html#gaa93f0eb578d23995850d61f7d61c55c1" title="Expands to &quot;0&quot;.">FALSE</a>;
<a name="l01280"></a>01280 
<a name="l01281"></a>01281   <span class="comment">/* If the field exists we set, otherwise we append */</span>
<a name="l01282"></a>01282   <span class="keywordflow">if</span> (_dbus_header_cache_check (header, field))
<a name="l01283"></a>01283     {
<a name="l01284"></a>01284       <a class="code" href="structDBusTypeReader.html" title="The type reader is an iterator for reading values from a block of values.">DBusTypeReader</a> reader;
<a name="l01285"></a>01285       <a class="code" href="structDBusTypeReader.html" title="The type reader is an iterator for reading values from a block of values.">DBusTypeReader</a> realign_root;
<a name="l01286"></a>01286 
<a name="l01287"></a>01287       <span class="keywordflow">if</span> (!find_field_for_modification (header, field,
<a name="l01288"></a>01288                                         &amp;reader, &amp;realign_root))
<a name="l01289"></a>01289         _dbus_assert_not_reached (<span class="stringliteral">&quot;field was marked present in cache but wasn&#39;t found&quot;</span>);
<a name="l01290"></a>01290 
<a name="l01291"></a>01291       <span class="keywordflow">if</span> (!set_basic_field (&amp;reader, field, type, value, &amp;realign_root))
<a name="l01292"></a>01292         <span class="keywordflow">return</span> <a class="code" href="group__DBusMacros.html#gaa93f0eb578d23995850d61f7d61c55c1" title="Expands to &quot;0&quot;.">FALSE</a>;
<a name="l01293"></a>01293     }
<a name="l01294"></a>01294   <span class="keywordflow">else</span>
<a name="l01295"></a>01295     {
<a name="l01296"></a>01296       <a class="code" href="structDBusTypeWriter.html" title="The type writer is an iterator for writing to a block of values.">DBusTypeWriter</a> writer;
<a name="l01297"></a>01297       <a class="code" href="structDBusTypeWriter.html" title="The type writer is an iterator for writing to a block of values.">DBusTypeWriter</a> array;
<a name="l01298"></a>01298 
<a name="l01299"></a>01299       <a class="code" href="group__DBusMarshal.html#ga1f101175ce6f33221fcb59f0b46349bd" title="Like _dbus_type_writer_init(), except the type string passed in should correspond to an existing sign...">_dbus_type_writer_init_values_only</a> (&amp;writer,
<a name="l01300"></a>01300                                           <a class="code" href="group__DBusMarshal.html#ga65c023673b837c27e8ccda5c2528d806" title="Returns the header&#39;s byte order.">_dbus_header_get_byte_order</a> (header),
<a name="l01301"></a>01301                                           &amp;_dbus_header_signature_str,
<a name="l01302"></a>01302                                           <a class="code" href="group__DBusMarshal.html#ga935ea6d7c6bb72a10c670f5ef3e34d49" title="Offset from start of _dbus_header_signature_str to the signature of the fields array.">FIELDS_ARRAY_SIGNATURE_OFFSET</a>,
<a name="l01303"></a>01303                                           &amp;header-&gt;<a class="code" href="structDBusHeader.html#a67df8bff43c10e2d4f6ae36b56ee5814" title="Header network data, stored separately from body so we can independently realloc it.">data</a>,
<a name="l01304"></a>01304                                           <a class="code" href="group__DBusMarshal.html#gae9759e0de1d8a650f37632c3dc22427e" title="Offset to fields array length from start of header.">FIELDS_ARRAY_LENGTH_OFFSET</a>);
<a name="l01305"></a>01305 
<a name="l01306"></a>01306       <span class="comment">/* recurse into array without creating a new length, and jump to</span>
<a name="l01307"></a>01307 <span class="comment">       * end of array.</span>
<a name="l01308"></a>01308 <span class="comment">       */</span>
<a name="l01309"></a>01309       <span class="keywordflow">if</span> (!<a class="code" href="group__DBusMarshal.html#gacc2b4c348f93898f6269feb0bf055617" title="Append to an existing array.">_dbus_type_writer_append_array</a> (&amp;writer,
<a name="l01310"></a>01310                                            &amp;_dbus_header_signature_str,
<a name="l01311"></a>01311                                            <a class="code" href="group__DBusMarshal.html#gaca36ac2e9b37067279d1bc967793e071" title="Offset from start of _dbus_header_signature_str to the signature of an element of the fields array...">FIELDS_ARRAY_ELEMENT_SIGNATURE_OFFSET</a>,
<a name="l01312"></a>01312                                            &amp;array))
<a name="l01313"></a>01313         _dbus_assert_not_reached (<span class="stringliteral">&quot;recurse into ARRAY should not have used memory&quot;</span>);
<a name="l01314"></a>01314 
<a name="l01315"></a>01315       _dbus_assert (array.<a class="code" href="structDBusTypeWriter.html#afe24080d2be45fb6033833a1a38d5d1a" title="class-specific data">u</a>.array.len_pos == <a class="code" href="group__DBusMarshal.html#gae9759e0de1d8a650f37632c3dc22427e" title="Offset to fields array length from start of header.">FIELDS_ARRAY_LENGTH_OFFSET</a>);
<a name="l01316"></a>01316       _dbus_assert (array.<a class="code" href="structDBusTypeWriter.html#afe24080d2be45fb6033833a1a38d5d1a" title="class-specific data">u</a>.array.start_pos == <a class="code" href="group__DBusMarshal.html#gaaa085e57f49f527ef210e842be999929" title="Offset to first field in header.">FIRST_FIELD_OFFSET</a>);
<a name="l01317"></a>01317       _dbus_assert (array.<a class="code" href="structDBusTypeWriter.html#a27c0475eedd90be65f90a799e5210947" title="next position to write">value_pos</a> == <a class="code" href="group__DBusMarshal.html#gaef7e86e442aeb887c8bfe5559cd4eabb" title="Compute the end of the header, ignoring padding.">HEADER_END_BEFORE_PADDING</a> (header));
<a name="l01318"></a>01318 
<a name="l01319"></a>01319       <span class="keywordflow">if</span> (!write_basic_field (&amp;array,
<a name="l01320"></a>01320                               field, type, value))
<a name="l01321"></a>01321         <span class="keywordflow">return</span> <a class="code" href="group__DBusMacros.html#gaa93f0eb578d23995850d61f7d61c55c1" title="Expands to &quot;0&quot;.">FALSE</a>;
<a name="l01322"></a>01322 
<a name="l01323"></a>01323       <span class="keywordflow">if</span> (!<a class="code" href="group__DBusMarshal.html#gacbe7eddf4f9c19da91b742087fcc111a" title="Closes a container created by _dbus_type_writer_recurse() and writes any additional information to th...">_dbus_type_writer_unrecurse</a> (&amp;writer, &amp;array))
<a name="l01324"></a>01324         _dbus_assert_not_reached (<span class="stringliteral">&quot;unrecurse from ARRAY should not have used memory&quot;</span>);
<a name="l01325"></a>01325     }
<a name="l01326"></a>01326 
<a name="l01327"></a>01327   correct_header_padding (header);
<a name="l01328"></a>01328 
<a name="l01329"></a>01329   <span class="comment">/* We could be smarter about this (only invalidate fields after the</span>
<a name="l01330"></a>01330 <span class="comment">   * one we modified, or even only if the one we modified changed</span>
<a name="l01331"></a>01331 <span class="comment">   * length). But this hack is a start.</span>
<a name="l01332"></a>01332 <span class="comment">   */</span>
<a name="l01333"></a>01333   _dbus_header_cache_invalidate_all (header);
<a name="l01334"></a>01334 
<a name="l01335"></a>01335   <span class="keywordflow">return</span> <a class="code" href="group__DBusMacros.html#gaa8cecfc5c5c054d2875c03e77b7be15d" title="Expands to &quot;1&quot;.">TRUE</a>;
<a name="l01336"></a>01336 }
<a name="l01337"></a>01337 
<a name="l01348"></a>01348 <a class="code" href="group__DBusTypes.html#ga39c9cb0f3a2a8ad6f55cc4855d035349" title="A boolean, valid values are TRUE and FALSE.">dbus_bool_t</a>
<a name="l01349"></a><a class="code" href="group__DBusMarshal.html#ga499973a18dcb17d854eaf14101a66736">01349</a> <a class="code" href="group__DBusMarshal.html#ga499973a18dcb17d854eaf14101a66736" title="Gets the value of a field with basic type.">_dbus_header_get_field_basic</a> (<a class="code" href="structDBusHeader.html" title="Message header data and some cached details of it.">DBusHeader</a>    *header,
<a name="l01350"></a>01350                               <span class="keywordtype">int</span>            field,
<a name="l01351"></a>01351                               <span class="keywordtype">int</span>            type,
<a name="l01352"></a>01352                               <span class="keywordtype">void</span>          *value)
<a name="l01353"></a>01353 {
<a name="l01354"></a>01354   _dbus_assert (field != <a class="code" href="group__DBusProtocol.html#ga075b0efc570129393d3fb653ce4bbd76" title="Not equal to any valid header field code.">DBUS_HEADER_FIELD_INVALID</a>);
<a name="l01355"></a>01355   _dbus_assert (field &lt;= <a class="code" href="group__DBusProtocol.html#ga94f09d2b35473c8ffa6d3190b5f97c5c" title="Value of the highest-numbered header field code, can be used to determine the size of an array indexe...">DBUS_HEADER_FIELD_LAST</a>);
<a name="l01356"></a>01356   _dbus_assert (_dbus_header_field_types[field].code == field);
<a name="l01357"></a>01357   <span class="comment">/* in light of this you might ask why the type is passed in;</span>
<a name="l01358"></a>01358 <span class="comment">   * the only rationale I can think of is so the caller has</span>
<a name="l01359"></a>01359 <span class="comment">   * to specify its expectation and breaks if we change it</span>
<a name="l01360"></a>01360 <span class="comment">   */</span>
<a name="l01361"></a>01361   _dbus_assert (type == <a class="code" href="group__DBusMarshal.html#ga37be3d294f5be31c95bc7620e451b0b2" title="Macro to look up the correct type for a field.">EXPECTED_TYPE_OF_FIELD</a> (field));
<a name="l01362"></a>01362 
<a name="l01363"></a>01363   <span class="keywordflow">if</span> (!_dbus_header_cache_check (header, field))
<a name="l01364"></a>01364     <span class="keywordflow">return</span> <a class="code" href="group__DBusMacros.html#gaa93f0eb578d23995850d61f7d61c55c1" title="Expands to &quot;0&quot;.">FALSE</a>;
<a name="l01365"></a>01365 
<a name="l01366"></a>01366   _dbus_assert (header-&gt;<a class="code" href="structDBusHeader.html#ac58a309593d0dc7e8d5a02f3b3442384" title="Track the location of each field in header.">fields</a>[field].<a class="code" href="structDBusHeaderField.html#aa9616d127de7488f6d9dc18c4d0c2133" title="Position of field value, or -1/-2.">value_pos</a> &gt;= 0);
<a name="l01367"></a>01367 
<a name="l01368"></a>01368   <a class="code" href="group__DBusMarshal.html#gab331e099fa8cf3d94cf33ad7b20c81ae" title="Demarshals a basic-typed value.">_dbus_marshal_read_basic</a> (&amp;header-&gt;<a class="code" href="structDBusHeader.html#a67df8bff43c10e2d4f6ae36b56ee5814" title="Header network data, stored separately from body so we can independently realloc it.">data</a>,
<a name="l01369"></a>01369                             header-&gt;<a class="code" href="structDBusHeader.html#ac58a309593d0dc7e8d5a02f3b3442384" title="Track the location of each field in header.">fields</a>[field].<a class="code" href="structDBusHeaderField.html#aa9616d127de7488f6d9dc18c4d0c2133" title="Position of field value, or -1/-2.">value_pos</a>,
<a name="l01370"></a>01370                             type, value, <a class="code" href="group__DBusMarshal.html#ga65c023673b837c27e8ccda5c2528d806" title="Returns the header&#39;s byte order.">_dbus_header_get_byte_order</a> (header),
<a name="l01371"></a>01371                             <a class="code" href="group__DBusMacros.html#ga070d2ce7b6bb7e5c05602aa8c308d0c4" title="A null pointer, defined appropriately for C or C++.">NULL</a>);
<a name="l01372"></a>01372 
<a name="l01373"></a>01373   <span class="keywordflow">return</span> <a class="code" href="group__DBusMacros.html#gaa8cecfc5c5c054d2875c03e77b7be15d" title="Expands to &quot;1&quot;.">TRUE</a>;
<a name="l01374"></a>01374 }
<a name="l01375"></a>01375 
<a name="l01389"></a>01389 <a class="code" href="group__DBusTypes.html#ga39c9cb0f3a2a8ad6f55cc4855d035349" title="A boolean, valid values are TRUE and FALSE.">dbus_bool_t</a>
<a name="l01390"></a><a class="code" href="group__DBusMarshal.html#gaf4661ba8e7067f349ba03c9f5776bbb0">01390</a> <a class="code" href="group__DBusMarshal.html#gaf4661ba8e7067f349ba03c9f5776bbb0" title="Gets the raw marshaled data for a field.">_dbus_header_get_field_raw</a> (<a class="code" href="structDBusHeader.html" title="Message header data and some cached details of it.">DBusHeader</a>        *header,
<a name="l01391"></a>01391                             <span class="keywordtype">int</span>                field,
<a name="l01392"></a>01392                             <span class="keyword">const</span> <a class="code" href="structDBusString.html">DBusString</a> **str,
<a name="l01393"></a>01393                             <span class="keywordtype">int</span>               *pos)
<a name="l01394"></a>01394 {
<a name="l01395"></a>01395   <span class="keywordflow">if</span> (!_dbus_header_cache_check (header, field))
<a name="l01396"></a>01396     <span class="keywordflow">return</span> <a class="code" href="group__DBusMacros.html#gaa93f0eb578d23995850d61f7d61c55c1" title="Expands to &quot;0&quot;.">FALSE</a>;
<a name="l01397"></a>01397 
<a name="l01398"></a>01398   <span class="keywordflow">if</span> (str)
<a name="l01399"></a>01399     *str = &amp;header-&gt;<a class="code" href="structDBusHeader.html#a67df8bff43c10e2d4f6ae36b56ee5814" title="Header network data, stored separately from body so we can independently realloc it.">data</a>;
<a name="l01400"></a>01400   <span class="keywordflow">if</span> (pos)
<a name="l01401"></a>01401     *pos = header-&gt;<a class="code" href="structDBusHeader.html#ac58a309593d0dc7e8d5a02f3b3442384" title="Track the location of each field in header.">fields</a>[field].<a class="code" href="structDBusHeaderField.html#aa9616d127de7488f6d9dc18c4d0c2133" title="Position of field value, or -1/-2.">value_pos</a>;
<a name="l01402"></a>01402 
<a name="l01403"></a>01403   <span class="keywordflow">return</span> <a class="code" href="group__DBusMacros.html#gaa8cecfc5c5c054d2875c03e77b7be15d" title="Expands to &quot;1&quot;.">TRUE</a>;
<a name="l01404"></a>01404 }
<a name="l01405"></a>01405 
<a name="l01413"></a>01413 <a class="code" href="group__DBusTypes.html#ga39c9cb0f3a2a8ad6f55cc4855d035349" title="A boolean, valid values are TRUE and FALSE.">dbus_bool_t</a>
<a name="l01414"></a><a class="code" href="group__DBusMarshal.html#ga7814248f4d74d109d29dc00487cd9b0c">01414</a> <a class="code" href="group__DBusMarshal.html#ga7814248f4d74d109d29dc00487cd9b0c" title="Deletes a field, if it exists.">_dbus_header_delete_field</a> (<a class="code" href="structDBusHeader.html" title="Message header data and some cached details of it.">DBusHeader</a> *header,
<a name="l01415"></a>01415                            <span class="keywordtype">int</span>         field)
<a name="l01416"></a>01416 {
<a name="l01417"></a>01417   <a class="code" href="structDBusTypeReader.html" title="The type reader is an iterator for reading values from a block of values.">DBusTypeReader</a> reader;
<a name="l01418"></a>01418   <a class="code" href="structDBusTypeReader.html" title="The type reader is an iterator for reading values from a block of values.">DBusTypeReader</a> realign_root;
<a name="l01419"></a>01419 
<a name="l01420"></a>01420   <span class="keywordflow">if</span> (_dbus_header_cache_known_nonexistent (header, field))
<a name="l01421"></a>01421     <span class="keywordflow">return</span> <a class="code" href="group__DBusMacros.html#gaa8cecfc5c5c054d2875c03e77b7be15d" title="Expands to &quot;1&quot;.">TRUE</a>; <span class="comment">/* nothing to do */</span>
<a name="l01422"></a>01422 
<a name="l01423"></a>01423   <span class="comment">/* Scan to the field we want, delete and realign, reappend</span>
<a name="l01424"></a>01424 <span class="comment">   * padding. Field may turn out not to exist.</span>
<a name="l01425"></a>01425 <span class="comment">   */</span>
<a name="l01426"></a>01426   <span class="keywordflow">if</span> (!find_field_for_modification (header, field,
<a name="l01427"></a>01427                                     &amp;reader, &amp;realign_root))
<a name="l01428"></a>01428     <span class="keywordflow">return</span> <a class="code" href="group__DBusMacros.html#gaa8cecfc5c5c054d2875c03e77b7be15d" title="Expands to &quot;1&quot;.">TRUE</a>; <span class="comment">/* nothing to do */</span>
<a name="l01429"></a>01429 
<a name="l01430"></a>01430   <span class="keywordflow">if</span> (!reserve_header_padding (header))
<a name="l01431"></a>01431     <span class="keywordflow">return</span> <a class="code" href="group__DBusMacros.html#gaa93f0eb578d23995850d61f7d61c55c1" title="Expands to &quot;0&quot;.">FALSE</a>;
<a name="l01432"></a>01432 
<a name="l01433"></a>01433   <span class="keywordflow">if</span> (!<a class="code" href="group__DBusMarshal.html#gaa4057610b3d9e81fed212c17f6599516" title="Recursively deletes any value pointed to by the reader, leaving the reader valid to continue reading...">_dbus_type_reader_delete</a> (&amp;reader,
<a name="l01434"></a>01434                                  &amp;realign_root))
<a name="l01435"></a>01435     <span class="keywordflow">return</span> <a class="code" href="group__DBusMacros.html#gaa93f0eb578d23995850d61f7d61c55c1" title="Expands to &quot;0&quot;.">FALSE</a>;
<a name="l01436"></a>01436 
<a name="l01437"></a>01437   correct_header_padding (header);
<a name="l01438"></a>01438 
<a name="l01439"></a>01439   _dbus_header_cache_invalidate_all (header);
<a name="l01440"></a>01440 
<a name="l01441"></a>01441   _dbus_assert (!_dbus_header_cache_check (header, field)); <span class="comment">/* Expensive assertion ... */</span>
<a name="l01442"></a>01442 
<a name="l01443"></a>01443   <span class="keywordflow">return</span> <a class="code" href="group__DBusMacros.html#gaa8cecfc5c5c054d2875c03e77b7be15d" title="Expands to &quot;1&quot;.">TRUE</a>;
<a name="l01444"></a>01444 }
<a name="l01445"></a>01445 
<a name="l01454"></a>01454 <span class="keywordtype">void</span>
<a name="l01455"></a><a class="code" href="group__DBusMarshal.html#gad2073f8f2f2ba3b710aa929dced34cc3">01455</a> <a class="code" href="group__DBusMarshal.html#gad2073f8f2f2ba3b710aa929dced34cc3" title="Toggles a message flag bit, turning on the bit if value = TRUE and flipping it off if value = FALSE...">_dbus_header_toggle_flag</a> (<a class="code" href="structDBusHeader.html" title="Message header data and some cached details of it.">DBusHeader</a>   *header,
<a name="l01456"></a>01456                           dbus_uint32_t flag,
<a name="l01457"></a>01457                           <a class="code" href="group__DBusTypes.html#ga39c9cb0f3a2a8ad6f55cc4855d035349" title="A boolean, valid values are TRUE and FALSE.">dbus_bool_t</a>   value)
<a name="l01458"></a>01458 {
<a name="l01459"></a>01459   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *flags_p;
<a name="l01460"></a>01460 
<a name="l01461"></a>01461   flags_p = <a class="code" href="group__DBusString.html#ga7a73fb373398606e6e1d0a86c4587a3c" title="Gets a sub-portion of the raw character buffer from the string.">_dbus_string_get_data_len</a> (&amp;header-&gt;<a class="code" href="structDBusHeader.html#a67df8bff43c10e2d4f6ae36b56ee5814" title="Header network data, stored separately from body so we can independently realloc it.">data</a>, <a class="code" href="group__DBusMarshal.html#ga7fe1bac4010cdc7e27de1e19702c071e" title="Offset to flags from start of header.">FLAGS_OFFSET</a>, 1);
<a name="l01462"></a>01462 
<a name="l01463"></a>01463   <span class="keywordflow">if</span> (value)
<a name="l01464"></a>01464     *flags_p |= flag;
<a name="l01465"></a>01465   <span class="keywordflow">else</span>
<a name="l01466"></a>01466     *flags_p &amp;= ~flag;
<a name="l01467"></a>01467 }
<a name="l01468"></a>01468 
<a name="l01476"></a>01476 <a class="code" href="group__DBusTypes.html#ga39c9cb0f3a2a8ad6f55cc4855d035349" title="A boolean, valid values are TRUE and FALSE.">dbus_bool_t</a>
<a name="l01477"></a><a class="code" href="group__DBusMarshal.html#ga56619efed3088554b8760edd246b4157">01477</a> <a class="code" href="group__DBusMarshal.html#ga56619efed3088554b8760edd246b4157" title="Gets a message flag bit, returning TRUE if the bit is set.">_dbus_header_get_flag</a> (<a class="code" href="structDBusHeader.html" title="Message header data and some cached details of it.">DBusHeader</a>   *header,
<a name="l01478"></a>01478                        dbus_uint32_t flag)
<a name="l01479"></a>01479 {
<a name="l01480"></a>01480   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *flags_p;
<a name="l01481"></a>01481 
<a name="l01482"></a>01482   flags_p = _dbus_string_get_const_data_len (&amp;header-&gt;<a class="code" href="structDBusHeader.html#a67df8bff43c10e2d4f6ae36b56ee5814" title="Header network data, stored separately from body so we can independently realloc it.">data</a>, <a class="code" href="group__DBusMarshal.html#ga7fe1bac4010cdc7e27de1e19702c071e" title="Offset to flags from start of header.">FLAGS_OFFSET</a>, 1);
<a name="l01483"></a>01483 
<a name="l01484"></a>01484   <span class="keywordflow">return</span> (*flags_p &amp; flag) != 0;
<a name="l01485"></a>01485 }
<a name="l01486"></a>01486 
<a name="l01493"></a>01493 <span class="keywordtype">void</span>
<a name="l01494"></a><a class="code" href="group__DBusMarshal.html#gae5277c7b7bfb7b85e421baceac0398c8">01494</a> <a class="code" href="group__DBusMarshal.html#gae5277c7b7bfb7b85e421baceac0398c8" title="Swaps the header into the given order if required.">_dbus_header_byteswap</a> (<a class="code" href="structDBusHeader.html" title="Message header data and some cached details of it.">DBusHeader</a> *header,
<a name="l01495"></a>01495                        <span class="keywordtype">int</span>         new_order)
<a name="l01496"></a>01496 {
<a name="l01497"></a>01497   <span class="keywordtype">char</span> byte_order;
<a name="l01498"></a>01498 
<a name="l01499"></a>01499   byte_order = <a class="code" href="group__DBusMarshal.html#ga65c023673b837c27e8ccda5c2528d806" title="Returns the header&#39;s byte order.">_dbus_header_get_byte_order</a> (header);
<a name="l01500"></a>01500 
<a name="l01501"></a>01501   <span class="keywordflow">if</span> (byte_order == new_order)
<a name="l01502"></a>01502     <span class="keywordflow">return</span>;
<a name="l01503"></a>01503 
<a name="l01504"></a>01504   <a class="code" href="group__DBusMarshal.html#ga609a4b8c0b65096890766fda73a4c40f" title="Byteswaps the marshaled data in the given value_str.">_dbus_marshal_byteswap</a> (&amp;_dbus_header_signature_str,
<a name="l01505"></a>01505                           0, byte_order,
<a name="l01506"></a>01506                           new_order,
<a name="l01507"></a>01507                           &amp;header-&gt;<a class="code" href="structDBusHeader.html#a67df8bff43c10e2d4f6ae36b56ee5814" title="Header network data, stored separately from body so we can independently realloc it.">data</a>, 0);
<a name="l01508"></a>01508 
<a name="l01509"></a>01509   _dbus_string_set_byte (&amp;header-&gt;<a class="code" href="structDBusHeader.html#a67df8bff43c10e2d4f6ae36b56ee5814" title="Header network data, stored separately from body so we can independently realloc it.">data</a>, <a class="code" href="group__DBusMarshal.html#gaa5b7e77f37761139698892e4b8aad029" title="Offset to byte order from start of header.">BYTE_ORDER_OFFSET</a>, new_order);
<a name="l01510"></a>01510 }
<a name="l01511"></a>01511 
</pre></div></div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Fri Dec 21 2012 17:59:18 for D-Bus by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
